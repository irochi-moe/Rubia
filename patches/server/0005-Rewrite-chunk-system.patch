From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sun, 23 Jan 2022 22:58:11 -0800
Subject: [PATCH] Rewrite chunk system

fixup! MC Utils
fixup! ConcurrentUtil
Rewrite chunk system

Original by Spottedleaf <Spottedleaf@users.noreply.github.com>

Copyright (C) 2022 PaperMC Team

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program.  If not, see <http://www.gnu.org/licenses/>.

diff --git a/src/main/java/ca/spottedleaf/concurrentutil/collection/SRSWLinkedQueue.java b/src/main/java/ca/spottedleaf/concurrentutil/collection/SRSWLinkedQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..597659f38aa816646dcda4ca39c002b6d9f9a792
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/collection/SRSWLinkedQueue.java
@@ -0,0 +1,148 @@
+package ca.spottedleaf.concurrentutil.collection;
+
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import ca.spottedleaf.concurrentutil.util.Validate;
+import java.lang.invoke.VarHandle;
+import java.util.ConcurrentModificationException;
+
+/**
+ * Single reader thread single writer thread queue. The reader side of the queue is ordered by acquire semantics,
+ * and the writer side of the queue is ordered by release semantics.
+ */
+// TODO test
+public class SRSWLinkedQueue<E> {
+
+    // always non-null
+    protected LinkedNode<E> head;
+
+    // always non-null
+    protected LinkedNode<E> tail;
+
+    /* IMPL NOTE: Leave hashCode and equals to their defaults */
+
+    public SRSWLinkedQueue() {
+        final LinkedNode<E> dummy = new LinkedNode<>(null, null);
+        this.head = this.tail = dummy;
+    }
+
+    /**
+     * Must be the reader thread.
+     *
+     * <p>
+     * Returns, without removing, the first element of this queue.
+     * </p>
+     * @return Returns, without removing, the first element of this queue.
+     */
+    public E peekFirst() {
+        LinkedNode<E> head = this.head;
+        E ret = head.getElementPlain();
+        if (ret == null) {
+            head = head.getNextAcquire();
+            if (head == null) {
+                // empty
+                return null;
+            }
+            // update head reference for next poll() call
+            this.head = head;
+            // guaranteed to be non-null
+            ret = head.getElementPlain();
+            if (ret == null) {
+                throw new ConcurrentModificationException("Multiple reader threads");
+            }
+        }
+
+        return ret;
+    }
+
+    /**
+     * Must be the reader thread.
+     *
+     * <p>
+     * Returns and removes the first element of this queue.
+     * </p>
+     * @return Returns and removes the first element of this queue.
+     */
+    public E poll() {
+        LinkedNode<E> head = this.head;
+        E ret = head.getElementPlain();
+        if (ret == null) {
+            head = head.getNextAcquire();
+            if (head == null) {
+                // empty
+                return null;
+            }
+            // guaranteed to be non-null
+            ret = head.getElementPlain();
+            if (ret == null) {
+                throw new ConcurrentModificationException("Multiple reader threads");
+            }
+        }
+
+        head.setElementPlain(null);
+        LinkedNode<E> next = head.getNextAcquire();
+        this.head = next == null ? head : next;
+
+        return ret;
+    }
+
+    /**
+     * Must be the writer thread.
+     *
+     * <p>
+     * Adds the element to the end of the queue.
+     * </p>
+     *
+     * @throws NullPointerException If the provided element is null
+     */
+    public void addLast(final E element) {
+        Validate.notNull(element, "Provided element cannot be null");
+        final LinkedNode<E> append = new LinkedNode<>(element, null);
+
+        this.tail.setNextRelease(append);
+        this.tail = append;
+    }
+
+    protected static final class LinkedNode<E> {
+
+        protected volatile Object element;
+        protected volatile LinkedNode<E> next;
+
+        protected static final VarHandle ELEMENT_HANDLE = ConcurrentUtil.getVarHandle(LinkedNode.class, "element", Object.class);
+        protected static final VarHandle NEXT_HANDLE = ConcurrentUtil.getVarHandle(LinkedNode.class, "next", LinkedNode.class);
+
+        protected LinkedNode(final Object element, final LinkedNode<E> next) {
+            ELEMENT_HANDLE.set(this, element);
+            NEXT_HANDLE.set(this, next);
+        }
+
+        /* element */
+
+        @SuppressWarnings("unchecked")
+        protected final E getElementPlain() {
+            return (E)ELEMENT_HANDLE.get(this);
+        }
+
+        protected final void setElementPlain(final E update) {
+            ELEMENT_HANDLE.set(this, (Object)update);
+        }
+        /* next */
+
+        @SuppressWarnings("unchecked")
+        protected final LinkedNode<E> getNextPlain() {
+            return (LinkedNode<E>)NEXT_HANDLE.get(this);
+        }
+
+        @SuppressWarnings("unchecked")
+        protected final LinkedNode<E> getNextAcquire() {
+            return (LinkedNode<E>)NEXT_HANDLE.getAcquire(this);
+        }
+
+        protected final void setNextPlain(final LinkedNode<E> next) {
+            NEXT_HANDLE.set(this, next);
+        }
+
+        protected final void setNextRelease(final LinkedNode<E> next) {
+            NEXT_HANDLE.setRelease(this, next);
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/executor/BaseExecutor.java b/src/main/java/ca/spottedleaf/concurrentutil/executor/BaseExecutor.java
index 716a0fd3f558df748e355069746272facb91de22..8c452b0988da4725762d543f6bee09915c328ae6 100644
--- a/src/main/java/ca/spottedleaf/concurrentutil/executor/BaseExecutor.java
+++ b/src/main/java/ca/spottedleaf/concurrentutil/executor/BaseExecutor.java
@@ -51,11 +51,11 @@ public interface BaseExecutor {
      * @throws IllegalStateException If the current thread is not allowed to wait
      */
     public default void waitUntilAllExecuted() throws IllegalStateException {
-        long failures = 9L; // start out at 1ms
+        long failures = 1L; // start at 0.25ms
 
         while (!this.haveAllTasksExecuted()) {
             Thread.yield();
-            failures = ConcurrentUtil.linearLongBackoff(failures, 500_000L, 5_000_000L); // 500us, 5ms
+            failures = ConcurrentUtil.linearLongBackoff(failures, 250_000L, 5_000_000L); // 500us, 5ms
         }
     }
 
diff --git a/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java b/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java
index ef8dcbb6bbc0769e9ccfdadb05e6a46c070eda98..f6dfaaa0ccd8caeb4bd4b94254aebe7e96732f12 100644
--- a/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java
+++ b/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java
@@ -41,14 +41,14 @@ public final class StarLightInterface {
     protected final ArrayDeque<SkyStarLightEngine> cachedSkyPropagators;
     protected final ArrayDeque<BlockStarLightEngine> cachedBlockPropagators;
 
-    protected final LightQueue lightQueue = new LightQueue(this);
+    public final io.papermc.paper.chunk.system.light.LightQueue lightQueue; // Paper - replace light queue
 
     protected final LayerLightEventListener skyReader;
     protected final LayerLightEventListener blockReader;
     protected final boolean isClientSide;
 
-    protected final int minSection;
-    protected final int maxSection;
+    public final int minSection; // Paper - public
+    public final int maxSection; // Paper - public
     protected final int minLightSection;
     protected final int maxLightSection;
 
@@ -182,6 +182,7 @@ public final class StarLightInterface {
                 StarLightInterface.this.sectionChange(pos, notReady);
             }
         };
+        this.lightQueue = new io.papermc.paper.chunk.system.light.LightQueue(this); // Paper - replace light queue
     }
 
     protected int getSkyLightValue(final BlockPos blockPos, final ChunkAccess chunk) {
@@ -325,7 +326,7 @@ public final class StarLightInterface {
         return this.lightAccess;
     }
 
-    protected final SkyStarLightEngine getSkyLightEngine() {
+    public final SkyStarLightEngine getSkyLightEngine() { // Paper - public
         if (this.cachedSkyPropagators == null) {
             return null;
         }
@@ -340,7 +341,7 @@ public final class StarLightInterface {
         return ret;
     }
 
-    protected final void releaseSkyLightEngine(final SkyStarLightEngine engine) {
+    public final void releaseSkyLightEngine(final SkyStarLightEngine engine) { // Paper - public
         if (this.cachedSkyPropagators == null) {
             return;
         }
@@ -349,7 +350,7 @@ public final class StarLightInterface {
         }
     }
 
-    protected final BlockStarLightEngine getBlockLightEngine() {
+    public final BlockStarLightEngine getBlockLightEngine() { // Paper - public
         if (this.cachedBlockPropagators == null) {
             return null;
         }
@@ -364,7 +365,7 @@ public final class StarLightInterface {
         return ret;
     }
 
-    protected final void releaseBlockLightEngine(final BlockStarLightEngine engine) {
+    public final void releaseBlockLightEngine(final BlockStarLightEngine engine) { // Paper - public
         if (this.cachedBlockPropagators == null) {
             return;
         }
@@ -511,57 +512,15 @@ public final class StarLightInterface {
     }
 
     public void scheduleChunkLight(final ChunkPos pos, final Runnable run) {
-        this.lightQueue.queueChunkLighting(pos, run);
+        throw new UnsupportedOperationException("No longer implemented, use the new lightQueue field to queue tasks"); // Paper - replace light queue
     }
 
     public void removeChunkTasks(final ChunkPos pos) {
-        this.lightQueue.removeChunk(pos);
+        throw new UnsupportedOperationException("No longer implemented, use the new lightQueue field to queue tasks"); // Paper - replace light queue
     }
 
     public void propagateChanges() {
-        if (this.lightQueue.isEmpty()) {
-            return;
-        }
-
-        final SkyStarLightEngine skyEngine = this.getSkyLightEngine();
-        final BlockStarLightEngine blockEngine = this.getBlockLightEngine();
-
-        try {
-            LightQueue.ChunkTasks task;
-            while ((task = this.lightQueue.removeFirstTask()) != null) {
-                if (task.lightTasks != null) {
-                    for (final Runnable run : task.lightTasks) {
-                        run.run();
-                    }
-                }
-
-                final long coordinate = task.chunkCoordinate;
-                final int chunkX = CoordinateUtils.getChunkX(coordinate);
-                final int chunkZ = CoordinateUtils.getChunkZ(coordinate);
-
-                final Set<BlockPos> positions = task.changedPositions;
-                final Boolean[] sectionChanges = task.changedSectionSet;
-
-                if (skyEngine != null && (!positions.isEmpty() || sectionChanges != null)) {
-                    skyEngine.blocksChangedInChunk(this.lightAccess, chunkX, chunkZ, positions, sectionChanges);
-                }
-                if (blockEngine != null && (!positions.isEmpty() || sectionChanges != null)) {
-                    blockEngine.blocksChangedInChunk(this.lightAccess, chunkX, chunkZ, positions, sectionChanges);
-                }
-
-                if (skyEngine != null && task.queuedEdgeChecksSky != null) {
-                    skyEngine.checkChunkEdges(this.lightAccess, chunkX, chunkZ, task.queuedEdgeChecksSky);
-                }
-                if (blockEngine != null && task.queuedEdgeChecksBlock != null) {
-                    blockEngine.checkChunkEdges(this.lightAccess, chunkX, chunkZ, task.queuedEdgeChecksBlock);
-                }
-
-                task.onComplete.complete(null);
-            }
-        } finally {
-            this.releaseSkyLightEngine(skyEngine);
-            this.releaseBlockLightEngine(blockEngine);
-        }
+        throw new UnsupportedOperationException("No longer implemented, task draining is now performed by the light thread"); // Paper - replace light queue
     }
 
     protected static final class LightQueue {
diff --git a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
index 7c89a96d54641904e2d4562fe28c59deecfb5444..7b95b599c29ddb9c249ab1f8e51b69789c63bdc4 100644
--- a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
+++ b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
@@ -45,7 +45,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         public static final PaperFileIOThread INSTANCE = new PaperFileIOThread();
 
         static {
-            INSTANCE.start();
+             // Paper - fail hard on usage
         }
     }
 
@@ -89,39 +89,16 @@ public final class PaperFileIOThread extends QueueExecutorThread {
      * @param priority Priority level to try to bump to
      */
     public void bumpPriority(final ServerLevel world, final int chunkX, final int chunkZ, final int priority) {
-        if (!PrioritizedTaskQueue.validPriority(priority)) {
-            throw new IllegalArgumentException("Invalid priority: " + priority);
-        }
-
-        final Long key = Long.valueOf(IOUtil.getCoordinateKey(chunkX, chunkZ));
-
-        final ChunkDataTask poiTask = world.poiDataController.tasks.get(key);
-        final ChunkDataTask chunkTask = world.chunkDataController.tasks.get(key);
-
-        if (poiTask != null) {
-            poiTask.raisePriority(priority);
-        }
-        if (chunkTask != null) {
-            chunkTask.raisePriority(priority);
-        }
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     public CompoundTag getPendingWrite(final ServerLevel world, final int chunkX, final int chunkZ, final boolean poiData) {
-        final ChunkDataController taskController = poiData ? world.poiDataController : world.chunkDataController;
-
-        final ChunkDataTask dataTask = taskController.tasks.get(Long.valueOf(IOUtil.getCoordinateKey(chunkX, chunkZ)));
-
-        if (dataTask == null) {
-            return null;
-        }
-
-        final ChunkDataController.InProgressWrite write = dataTask.inProgressWrite;
-
-        if (write == null) {
-            return null;
-        }
-
-        return write.data;
+        // Paper start - rewrite chunk system
+        return io.papermc.paper.chunk.system.io.RegionFileIOThread.getPendingWrite(
+            world, chunkX, chunkZ, poiData ? io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA :
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA
+            );
+        // Paper end - rewrite chunk system
     }
 
     /**
@@ -132,21 +109,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
      * @param priority Priority level to set to
      */
     public void setPriority(final ServerLevel world, final int chunkX, final int chunkZ, final int priority) {
-        if (!PrioritizedTaskQueue.validPriority(priority)) {
-            throw new IllegalArgumentException("Invalid priority: " + priority);
-        }
-
-        final Long key = Long.valueOf(IOUtil.getCoordinateKey(chunkX, chunkZ));
-
-        final ChunkDataTask poiTask = world.poiDataController.tasks.get(key);
-        final ChunkDataTask chunkTask = world.chunkDataController.tasks.get(key);
-
-        if (poiTask != null) {
-            poiTask.updatePriority(priority);
-        }
-        if (chunkTask != null) {
-            chunkTask.updatePriority(priority);
-        }
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     /**
@@ -173,58 +136,12 @@ public final class PaperFileIOThread extends QueueExecutorThread {
     public void scheduleSave(final ServerLevel world, final int chunkX, final int chunkZ,
                              final CompoundTag poiData, final CompoundTag chunkData,
                              final int priority) throws IllegalArgumentException {
-        if (!PrioritizedTaskQueue.validPriority(priority)) {
-            throw new IllegalArgumentException("Invalid priority: " + priority);
-        }
-
-        final long writeCounter = this.writeCounter.getAndIncrement();
-
-        if (poiData != null) {
-            this.scheduleWrite(world.poiDataController, world, chunkX, chunkZ, poiData, priority, writeCounter);
-        }
-        if (chunkData != null) {
-            this.scheduleWrite(world.chunkDataController, world, chunkX, chunkZ, chunkData, priority, writeCounter);
-        }
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     private void scheduleWrite(final ChunkDataController dataController, final ServerLevel world,
                                final int chunkX, final int chunkZ, final CompoundTag data, final int priority, final long writeCounter) {
-        dataController.tasks.compute(Long.valueOf(IOUtil.getCoordinateKey(chunkX, chunkZ)), (final Long keyInMap, final ChunkDataTask taskRunning) -> {
-            if (taskRunning == null) {
-                // no task is scheduled
-
-                // create task
-                final ChunkDataTask newTask = new ChunkDataTask(priority, world, chunkX, chunkZ, dataController);
-                newTask.inProgressWrite = new ChunkDataController.InProgressWrite();
-                newTask.inProgressWrite.writeCounter = writeCounter;
-                newTask.inProgressWrite.data = data;
-
-                PaperFileIOThread.this.queueTask(newTask); // schedule
-                return newTask;
-            }
-
-            taskRunning.raisePriority(priority);
-
-            if (taskRunning.inProgressWrite == null) {
-                taskRunning.inProgressWrite = new ChunkDataController.InProgressWrite();
-            }
-
-            boolean reschedule = taskRunning.inProgressWrite.writeCounter == -1L;
-
-            // synchronize for readers
-            //noinspection SynchronizationOnLocalVariableOrMethodParameter
-            synchronized (taskRunning) {
-                taskRunning.inProgressWrite.data = data;
-                taskRunning.inProgressWrite.writeCounter = writeCounter;
-            }
-
-            if (reschedule) {
-                // We need to reschedule this task since the previous one is not currently scheduled since it failed
-                taskRunning.reschedule(priority);
-            }
-
-            return taskRunning;
-        });
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     /**
@@ -283,45 +200,45 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         }
 
         final ChunkData complete = new ChunkData();
-        final boolean[] requireCompletion = new boolean[] { readPoiData, readChunkData };
-
+        // Paper start - rewrite chunk system
+        final java.util.List<io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType> types = new java.util.ArrayList<>();
         if (readPoiData) {
-            this.scheduleRead(world.poiDataController, world, chunkX, chunkZ, (final CompoundTag poiData) -> {
-                complete.poiData = poiData;
-
-                final boolean finished;
-
-                // avoid a race condition where the file io thread completes and we complete synchronously
-                // Note: Synchronization can be elided if both of the accesses are volatile
-                synchronized (requireCompletion) {
-                    requireCompletion[0] = false; // 0 -> poi data
-                    finished = !requireCompletion[1]; // 1 -> chunk data
-                }
-
-                if (finished) {
-                    onComplete.accept(complete);
-                }
-            }, priority, intendingToBlock);
+            types.add(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA);
         }
-
         if (readChunkData) {
-            this.scheduleRead(world.chunkDataController, world, chunkX, chunkZ, (final CompoundTag chunkData) -> {
-                complete.chunkData = chunkData;
-
-                final boolean finished;
-
-                // avoid a race condition where the file io thread completes and we complete synchronously
-                // Note: Synchronization can be elided if both of the accesses are volatile
-                synchronized (requireCompletion) {
-                    requireCompletion[1] = false; // 1 -> chunk data
-                    finished = !requireCompletion[0]; // 0 -> poi data
+            types.add(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA);
+        }
+        final ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority newPriority;
+        switch (priority) {
+            case PrioritizedTaskQueue.HIGHEST_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.BLOCKING;
+            case PrioritizedTaskQueue.HIGHER_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.HIGHEST;
+            case PrioritizedTaskQueue.HIGH_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.HIGH;
+            case PrioritizedTaskQueue.NORMAL_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL;
+            case PrioritizedTaskQueue.LOW_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.LOW;
+            case PrioritizedTaskQueue.LOWEST_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.IDLE;
+            default -> throw new IllegalStateException("Legacy priority " + priority + " should be valid");
+        }
+        final Consumer<io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileData> transformComplete = (io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileData data) -> {
+            if (readPoiData) {
+                if (data.getThrowable(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA) != null) {
+                    complete.poiData = FAILURE_VALUE;
+                } else {
+                    complete.poiData = data.getData(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA);
                 }
+            }
 
-                if (finished) {
-                    onComplete.accept(complete);
+            if (readChunkData) {
+                if (data.getThrowable(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA) != null) {
+                    complete.chunkData = FAILURE_VALUE;
+                } else {
+                    complete.chunkData = data.getData(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA);
                 }
-            }, priority, intendingToBlock);
-        }
+            }
+
+            onComplete.accept(complete);
+        };
+        io.papermc.paper.chunk.system.io.RegionFileIOThread.loadChunkData(world, chunkX, chunkZ, transformComplete, intendingToBlock, newPriority, types.toArray(new io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType[0]));
+        // Paper end - rewrite chunk system
 
     }
 
@@ -329,49 +246,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
     private void scheduleRead(final ChunkDataController dataController, final ServerLevel world,
                               final int chunkX, final int chunkZ, final Consumer<CompoundTag> onComplete, final int priority,
                               final boolean intendingToBlock) {
-
-        Function<RegionFile, Boolean> tryLoadFunction = (final RegionFile file) -> {
-            if (file == null) {
-                return Boolean.TRUE;
-            }
-            return Boolean.valueOf(file.hasChunk(new ChunkPos(chunkX, chunkZ)));
-        };
-
-        dataController.tasks.compute(Long.valueOf(IOUtil.getCoordinateKey(chunkX, chunkZ)), (final Long keyInMap, final ChunkDataTask running) -> {
-            if (running == null) {
-                // not scheduled
-
-                final Boolean shouldSchedule = intendingToBlock ? dataController.computeForRegionFile(chunkX, chunkZ, tryLoadFunction) :
-                    dataController.computeForRegionFileIfLoaded(chunkX, chunkZ, tryLoadFunction);
-
-                if (shouldSchedule == Boolean.FALSE) {
-                    // not on disk
-                    onComplete.accept(null);
-                    return null;
-                }
-
-                // set up task
-                final ChunkDataTask newTask = new ChunkDataTask(priority, world, chunkX, chunkZ, dataController);
-                newTask.inProgressRead = new ChunkDataController.InProgressRead();
-                newTask.inProgressRead.readFuture.thenAccept(onComplete);
-
-                PaperFileIOThread.this.queueTask(newTask); // schedule task
-                return newTask;
-            }
-
-            running.raisePriority(priority);
-
-            if (running.inProgressWrite == null) {
-                // chain to the read future
-                running.inProgressRead.readFuture.thenAccept(onComplete);
-                return running;
-            }
-
-            // at this stage we have to use the in progress write's data to avoid an order issue
-            // we don't synchronize since all writes to data occur in the compute() call
-            onComplete.accept(running.inProgressWrite.data);
-            return running;
-        });
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     /**
@@ -391,7 +266,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
      * </p>
      */
     public void runTask(final int priority, final Runnable runnable) {
-        this.queueTask(new GeneralTask(priority, runnable));
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     static final class GeneralTask extends PrioritizedTaskQueue.PrioritizedTask implements Runnable {
@@ -471,7 +346,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         @Override
         public String toString() {
             return "Task for world: '" + this.world.getWorld().getName() + "' at " + this.x + "," + this.z +
-                " poi: " + (this.taskController == this.world.poiDataController) + ", hash: " + this.hashCode();
+                " poi: " + (this.taskController == null) + ", hash: " + this.hashCode(); // Paper - TODO rewrite chunk system
         }
 
         /*
@@ -501,6 +376,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
 
         @Override
         public void run() {
+            if (true) throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
             ChunkDataController.InProgressRead read = this.inProgressRead;
             if (read != null) {
                 CompoundTag compound = PaperFileIOThread.FAILURE_VALUE;
diff --git a/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java b/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
index 68860a3b6db2aa50373d71aec9502c18d48ab8b9..193f492ce1fb6a7ebf2c19f092c268422c7435c3 100644
--- a/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
+++ b/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
@@ -86,24 +86,7 @@ public final class ChunkTaskManager {
     }
 
     public static void dumpAllChunkLoadInfo() {
-        ChunkInfo[] chunks = getChunkInfos();
-        if (chunks.length > 0) {
-            PaperFileIOThread.LOGGER.error("Chunk wait task info below: ");
-
-            for (final ChunkInfo chunkInfo : chunks) {
-                final long key = IOUtil.getCoordinateKey(chunkInfo.chunkX, chunkInfo.chunkZ);
-                final ChunkLoadTask loadTask = chunkInfo.world.asyncChunkTaskManager.chunkLoadTasks.get(key);
-                final ChunkSaveTask saveTask = chunkInfo.world.asyncChunkTaskManager.chunkSaveTasks.get(key);
-
-                PaperFileIOThread.LOGGER.error(chunkInfo.chunkX + "," + chunkInfo.chunkZ + " in '" + chunkInfo.world.getWorld().getName() + ":");
-                PaperFileIOThread.LOGGER.error("Load Task - " + (loadTask == null ? "none" : loadTask.toString()));
-                PaperFileIOThread.LOGGER.error("Save Task - " + (saveTask == null ? "none" : saveTask.toString()));
-                // log current status of chunk to indicate whether we're waiting on generation or loading
-                ChunkHolder chunkHolder = chunkInfo.world.getChunkSource().chunkMap.getVisibleChunkIfPresent(key);
-
-                dumpChunkInfo(new HashSet<>(), chunkHolder, chunkInfo.chunkX, chunkInfo.chunkZ);
-            }
-        }
+        // Paper - rewrite chunk system
     }
 
     static void dumpChunkInfo(Set<ChunkHolder> seenChunks, ChunkHolder chunkHolder, int x, int z) {
@@ -111,49 +94,7 @@ public final class ChunkTaskManager {
     }
 
     static void dumpChunkInfo(Set<ChunkHolder> seenChunks, ChunkHolder chunkHolder, int x, int z, int indent, int maxDepth) {
-        if (seenChunks.contains(chunkHolder)) {
-            return;
-        }
-        if (indent > maxDepth) {
-            return;
-        }
-        seenChunks.add(chunkHolder);
-        String indentStr = StringUtils.repeat("  ", indent);
-        if (chunkHolder == null) {
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Holder - null for (" + x +"," + z +")");
-        } else {
-            ChunkAccess chunk = chunkHolder.getLastAvailable();
-            ChunkStatus holderStatus = chunkHolder.getChunkHolderStatus();
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Holder - non-null");
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Status - " + ((chunk == null) ? "null chunk" : chunk.getStatus().toString()));
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Ticket Status - "  + ChunkHolder.getStatus(chunkHolder.getTicketLevel()));
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Holder Status - " + ((holderStatus == null) ? "null" : holderStatus.toString()));
-            // Paper start
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Holder Priority - " + chunkHolder.queueLevel);
-
-            if (!chunkHolder.neighbors.isEmpty()) {
-                if (indent >= maxDepth) {
-                    PaperFileIOThread.LOGGER.error(indentStr + "Chunk Neighbors: (Can't show, too deeply nested)");
-                    return;
-                }
-                PaperFileIOThread.LOGGER.error(indentStr + "Chunk Neighbors: ");
-                for (ChunkHolder neighbor : chunkHolder.neighbors.keySet()) {
-                    ChunkStatus status = neighbor.getChunkHolderStatus();
-                    if (status != null && status.isOrAfter(ChunkHolder.getStatus(neighbor.getTicketLevel()))) {
-                        continue;
-                    }
-                    int nx = neighbor.pos.x;
-                    int nz = neighbor.pos.z;
-                    if (seenChunks.contains(neighbor)) {
-                        PaperFileIOThread.LOGGER.error(indentStr + "  " + nx + "," + nz + " in " + chunkHolder.getWorld().getWorld().getName() + " (CIRCULAR)");
-                        continue;
-                    }
-                    PaperFileIOThread.LOGGER.error(indentStr + "  " + nx + "," + nz + " in " + chunkHolder.getWorld().getWorld().getName() + ":");
-                    dumpChunkInfo(seenChunks, neighbor, nx, nz, indent + 1, maxDepth);
-                }
-            }
-            // Paper end
-        }
+        // Paper - rewrite chunk system
     }
 
     public static void processConfiguration(GlobalConfiguration.AsyncChunks config) {
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java b/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java
new file mode 100644
index 0000000000000000000000000000000000000000..190c5f0b02a3d99054704ae1afbffb3498ddffe1
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java
@@ -0,0 +1,125 @@
+package com.destroystokyo.paper.util.maplist;
+
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ * @author Spottedleaf
+ */
+public final class ReferenceList<E> implements Iterable<E> {
+
+    protected final Reference2IntOpenHashMap<E> referenceToIndex = new Reference2IntOpenHashMap<>(2, 0.8f);
+    {
+        this.referenceToIndex.defaultReturnValue(Integer.MIN_VALUE);
+    }
+
+    protected static final Object[] EMPTY_LIST = new Object[0];
+
+    protected Object[] references = EMPTY_LIST;
+    protected int count;
+
+    public int size() {
+        return this.count;
+    }
+
+    public boolean contains(final E obj) {
+        return this.referenceToIndex.containsKey(obj);
+    }
+
+    public boolean remove(final E obj) {
+        final int index = this.referenceToIndex.removeInt(obj);
+        if (index == Integer.MIN_VALUE) {
+            return false;
+        }
+
+        // move the object at the end to this index
+        final int endIndex = --this.count;
+        final E end = (E)this.references[endIndex];
+        if (index != endIndex) {
+            // not empty after this call
+            this.referenceToIndex.put(end, index); // update index
+        }
+        this.references[index] = end;
+        this.references[endIndex] = null;
+
+        return true;
+    }
+
+    public boolean add(final E obj) {
+        final int count = this.count;
+        final int currIndex = this.referenceToIndex.putIfAbsent(obj, count);
+
+        if (currIndex != Integer.MIN_VALUE) {
+            return false; // already in this list
+        }
+
+        Object[] list = this.references;
+
+        if (list.length == count) {
+            // resize required
+            list = this.references = Arrays.copyOf(list, (int)Math.max(4L, count * 2L)); // overflow results in negative
+        }
+
+        list[count] = obj;
+        this.count = count + 1;
+
+        return true;
+    }
+
+    public E getChecked(final int index) {
+        if (index < 0 || index >= this.count) {
+            throw new IndexOutOfBoundsException("Index: " + index + " is out of bounds, size: " + this.count);
+        }
+        return (E)this.references[index];
+    }
+
+    public E getUnchecked(final int index) {
+        return (E)this.references[index];
+    }
+
+    public Object[] getRawData() {
+        return this.references;
+    }
+
+    public void clear() {
+        this.referenceToIndex.clear();
+        Arrays.fill(this.references, 0, this.count, null);
+        this.count = 0;
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return new Iterator<>() {
+            private E lastRet;
+            private int current;
+
+            @Override
+            public boolean hasNext() {
+                return this.current < ReferenceList.this.count;
+            }
+
+            @Override
+            public E next() {
+                if (this.current >= ReferenceList.this.count) {
+                    throw new NoSuchElementException();
+                }
+                return this.lastRet = (E)ReferenceList.this.references[this.current++];
+            }
+
+            @Override
+            public void remove() {
+                final E lastRet = this.lastRet;
+
+                if (lastRet == null) {
+                    throw new IllegalStateException();
+                }
+                this.lastRet = null;
+
+                ReferenceList.this.remove(lastRet);
+                --this.current;
+            }
+        };
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd1d99582b1e872c9a6b8e1be7d71b217f198605
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -0,0 +1,844 @@
+package io.papermc.paper.chunk.system.entity;
+
+import com.destroystokyo.paper.util.maplist.EntityList;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import io.papermc.paper.util.WorldUtil;
+import io.papermc.paper.world.ChunkEntitySlices;
+import it.unimi.dsi.fastutil.ints.Int2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2ReferenceOpenHashMap;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.ChunkSystem;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.level.entity.EntityInLevelCallback;
+import net.minecraft.world.level.entity.EntityTypeTest;
+import net.minecraft.world.level.entity.LevelCallback;
+import net.minecraft.world.level.entity.LevelEntityGetter;
+import net.minecraft.world.level.entity.Visibility;
+import net.minecraft.world.phys.AABB;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.slf4j.Logger;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.UUID;
+import java.util.concurrent.locks.StampedLock;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+public final class EntityLookup implements LevelEntityGetter<Entity> {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    protected static final int REGION_SHIFT = 5;
+    protected static final int REGION_MASK = (1 << REGION_SHIFT) - 1;
+    protected static final int REGION_SIZE = 1 << REGION_SHIFT;
+
+    public final ServerLevel world;
+
+    private final StampedLock stateLock = new StampedLock();
+    protected final Long2ObjectOpenHashMap<ChunkSlicesRegion> regions = new Long2ObjectOpenHashMap<>(128, 0.5f);
+
+    private final int minSection; // inclusive
+    private final int maxSection; // inclusive
+    private final LevelCallback<Entity> worldCallback;
+
+    private final StampedLock entityByLock = new StampedLock();
+    private final Int2ReferenceOpenHashMap<Entity> entityById = new Int2ReferenceOpenHashMap<>();
+    private final Object2ReferenceOpenHashMap<UUID, Entity> entityByUUID = new Object2ReferenceOpenHashMap<>();
+    private final EntityList accessibleEntities = new EntityList();
+
+    public EntityLookup(final ServerLevel world, final LevelCallback<Entity> worldCallback) {
+        this.world = world;
+        this.minSection = WorldUtil.getMinSection(world);
+        this.maxSection = WorldUtil.getMaxSection(world);
+        this.worldCallback = worldCallback;
+    }
+
+    private static Entity maskNonAccessible(final Entity entity) {
+        if (entity == null) {
+            return null;
+        }
+        final Visibility visibility = EntityLookup.getEntityStatus(entity);
+        return visibility.isAccessible() ? entity : null;
+    }
+
+    @Nullable
+    @Override
+    public Entity get(final int id) {
+        final long attempt = this.entityByLock.tryOptimisticRead();
+        if (attempt != 0L) {
+            try {
+                final Entity ret = this.entityById.get(id);
+
+                if (this.entityByLock.validate(attempt)) {
+                    return maskNonAccessible(ret);
+                }
+            } catch (final Error error) {
+                throw error;
+            } catch (final Throwable thr) {
+                // ignore
+            }
+        }
+
+        this.entityByLock.readLock();
+        try {
+            return maskNonAccessible(this.entityById.get(id));
+        } finally {
+            this.entityByLock.tryUnlockRead();
+        }
+    }
+
+    @Nullable
+    @Override
+    public Entity get(final UUID id) {
+        final long attempt = this.entityByLock.tryOptimisticRead();
+        if (attempt != 0L) {
+            try {
+                final Entity ret = this.entityByUUID.get(id);
+
+                if (this.entityByLock.validate(attempt)) {
+                    return maskNonAccessible(ret);
+                }
+            } catch (final Error error) {
+                throw error;
+            } catch (final Throwable thr) {
+                // ignore
+            }
+        }
+
+        this.entityByLock.readLock();
+        try {
+            return maskNonAccessible(this.entityByUUID.get(id));
+        } finally {
+            this.entityByLock.tryUnlockRead();
+        }
+    }
+
+    public boolean hasEntity(final UUID uuid) {
+        return this.get(uuid) != null;
+    }
+
+    public String getDebugInfo() {
+        return "count_id:" + this.entityById.size() + ",count_uuid:" + this.entityByUUID.size() + ",region_count:" + this.regions.size();
+    }
+
+    static final class ArrayIterable<T> implements Iterable<T> {
+
+        private final T[] array;
+        private final int off;
+        private final int length;
+
+        public ArrayIterable(final T[] array, final int off, final int length) {
+            this.array = array;
+            this.off = off;
+            this.length = length;
+            if (length > array.length) {
+                throw new IllegalArgumentException("Length must be no greater-than the array length");
+            }
+        }
+
+        @NotNull
+        @Override
+        public Iterator<T> iterator() {
+            return new ArrayIterator<>(this.array, this.off, this.length);
+        }
+
+        static final class ArrayIterator<T> implements Iterator<T> {
+
+            private final T[] array;
+            private int off;
+            private final int length;
+
+            public ArrayIterator(final T[] array, final int off, final int length) {
+                this.array = array;
+                this.off = off;
+                this.length = length;
+            }
+
+            @Override
+            public boolean hasNext() {
+                return this.off < this.length;
+            }
+
+            @Override
+            public T next() {
+                if (this.off >= this.length) {
+                    throw new NoSuchElementException();
+                }
+                return this.array[this.off++];
+            }
+
+            @Override
+            public void remove() {
+                throw new UnsupportedOperationException();
+            }
+        }
+    }
+
+    @Override
+    public Iterable<Entity> getAll() {
+        return new ArrayIterable<>(this.accessibleEntities.getRawData(), 0, this.accessibleEntities.size());
+    }
+
+    @Override
+    public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final Consumer<U> action) {
+        for (final Entity entity : this.entityById.values()) {
+            final Visibility visibility = EntityLookup.getEntityStatus(entity);
+            if (!visibility.isAccessible()) {
+                continue;
+            }
+            final U casted = filter.tryCast(entity);
+            if (casted != null) {
+                action.accept(casted);
+            }
+        }
+    }
+
+    @Override
+    public void get(final AABB box, final Consumer<Entity> action) {
+        List<Entity> entities = new ArrayList<>();
+        this.getEntitiesWithoutDragonParts(null, box, entities, null);
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            action.accept(entities.get(i));
+        }
+    }
+
+    @Override
+    public void get(final AABB box, final Consumer<Entity> action, final boolean isContainerSearch) {
+        this.get(box, action); // container search needs to be reworked
+    }
+
+    @Override
+    public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final AABB box, final Consumer<U> action) {
+        List<Entity> entities = new ArrayList<>();
+        this.getEntitiesWithoutDragonParts(null, box, entities, null);
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            final U casted = filter.tryCast(entities.get(i));
+            if (casted != null) {
+                action.accept(casted);
+            }
+        }
+    }
+
+    public void entityStatusChange(final Entity entity, final ChunkEntitySlices slices, final Visibility oldVisibility, final Visibility newVisibility, final boolean moved,
+                                   final boolean created, final boolean destroyed) {
+        TickThread.ensureTickThread(entity, "Entity status change must only happen on the main thread");
+
+        if (entity.updatingSectionStatus) {
+            // recursive status update
+            LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable());
+            return;
+        }
+
+        final boolean entityStatusUpdateBefore = slices == null ? false : slices.startPreventingStatusUpdates();
+
+        if (entityStatusUpdateBefore) {
+            LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable());
+            return;
+        }
+
+        try {
+            final Boolean ticketBlockBefore = this.world.chunkTaskScheduler.chunkHolderManager.blockTicketUpdates();
+            try {
+                entity.updatingSectionStatus = true;
+                try {
+                    if (created) {
+                        EntityLookup.this.worldCallback.onCreated(entity);
+                    }
+
+                    if (oldVisibility == newVisibility) {
+                        if (moved && newVisibility.isAccessible()) {
+                            EntityLookup.this.worldCallback.onSectionChange(entity);
+                        }
+                        return;
+                    }
+
+                    if (newVisibility.ordinal() > oldVisibility.ordinal()) {
+                        // status upgrade
+                        if (!oldVisibility.isAccessible() && newVisibility.isAccessible()) {
+                            this.accessibleEntities.add(entity);
+                            EntityLookup.this.worldCallback.onTrackingStart(entity);
+                        }
+
+                        if (!oldVisibility.isTicking() && newVisibility.isTicking()) {
+                            EntityLookup.this.worldCallback.onTickingStart(entity);
+                        }
+                    } else {
+                        // status downgrade
+                        if (oldVisibility.isTicking() && !newVisibility.isTicking()) {
+                            EntityLookup.this.worldCallback.onTickingEnd(entity);
+                        }
+
+                        if (oldVisibility.isAccessible() && !newVisibility.isAccessible()) {
+                            this.accessibleEntities.remove(entity);
+                            EntityLookup.this.worldCallback.onTrackingEnd(entity);
+                        }
+                    }
+
+                    if (moved && newVisibility.isAccessible()) {
+                        EntityLookup.this.worldCallback.onSectionChange(entity);
+                    }
+
+                    if (destroyed) {
+                        EntityLookup.this.worldCallback.onDestroyed(entity);
+                    }
+                } finally {
+                    entity.updatingSectionStatus = false;
+                }
+            } finally {
+                this.world.chunkTaskScheduler.chunkHolderManager.unblockTicketUpdates(ticketBlockBefore);
+            }
+        } finally {
+            if (slices != null) {
+                slices.stopPreventingStatusUpdates(false);
+            }
+        }
+    }
+
+    public void chunkStatusChange(final int x, final int z, final ChunkHolder.FullChunkStatus newStatus) {
+        this.getChunk(x, z).updateStatus(newStatus, this);
+    }
+
+    public void addLegacyChunkEntities(final List<Entity> entities) {
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            this.addEntity(entities.get(i), true);
+        }
+    }
+
+    public void addEntityChunkEntities(final List<Entity> entities) {
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            this.addEntity(entities.get(i), true);
+        }
+    }
+
+    public void addWorldGenChunkEntities(final List<Entity> entities) {
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            this.addEntity(entities.get(i), false);
+        }
+    }
+
+    public boolean addNewEntity(final Entity entity) {
+        return this.addEntity(entity, false);
+    }
+
+    public static Visibility getEntityStatus(final Entity entity) {
+        if (entity.isAlwaysTicking()) {
+            return Visibility.TICKING;
+        }
+        final ChunkHolder.FullChunkStatus entityStatus = entity.chunkStatus;
+        return Visibility.fromFullChunkStatus(entityStatus == null ? ChunkHolder.FullChunkStatus.INACCESSIBLE : entityStatus);
+    }
+
+    private boolean addEntity(final Entity entity, final boolean fromDisk) {
+        final BlockPos pos = entity.blockPosition();
+        final int sectionX = pos.getX() >> 4;
+        final int sectionY = Mth.clamp(pos.getY() >> 4, this.minSection, this.maxSection);
+        final int sectionZ = pos.getZ() >> 4;
+        TickThread.ensureTickThread(this.world, sectionX, sectionZ, "Cannot add entity off-main thread");
+
+        if (entity.isRemoved()) {
+            LOGGER.warn("Refusing to add removed entity: " + entity);
+            return false;
+        }
+
+        if (entity.updatingSectionStatus) {
+            LOGGER.warn("Entity " + entity + " is currently prevented from being added/removed to world since it is processing section status updates", new Throwable());
+            return false;
+        }
+
+        if (fromDisk) {
+            ChunkSystem.onEntityPreAdd(this.world, entity);
+            if (entity.isRemoved()) {
+                // removed from checkDupeUUID call
+                return false;
+            }
+        }
+
+        this.entityByLock.writeLock();
+        try {
+            if (this.entityById.containsKey(entity.getId())) {
+                LOGGER.warn("Entity id already exists: " + entity.getId() + ", mapped to " + this.entityById.get(entity.getId()) + ", can't add " + entity, new Throwable());
+                return false;
+            }
+            if (this.entityByUUID.containsKey(entity.getUUID())) {
+                LOGGER.warn("Entity uuid already exists: " + entity.getUUID() + ", mapped to " + this.entityByUUID.get(entity.getUUID()) + ", can't add " + entity, new Throwable());
+                return false;
+            }
+            this.entityById.put(entity.getId(), entity);
+            this.entityByUUID.put(entity.getUUID(), entity);
+        } finally {
+            this.entityByLock.tryUnlockWrite();
+        }
+
+        entity.sectionX = sectionX;
+        entity.sectionY = sectionY;
+        entity.sectionZ = sectionZ;
+        final ChunkEntitySlices slices = this.getOrCreateChunk(sectionX, sectionZ);
+        if (!slices.addEntity(entity, sectionY)) {
+            LOGGER.warn("Entity " + entity + " added to world '" + this.world.getWorld().getName() + "', but was already contained in entity chunk (" + sectionX + "," + sectionZ + ")");
+        }
+
+        entity.setLevelCallback(new EntityCallback(entity));
+
+        this.entityStatusChange(entity, slices, Visibility.HIDDEN, getEntityStatus(entity), false, !fromDisk, false);
+
+        return true;
+    }
+
+    private void removeEntity(final Entity entity) {
+        final int sectionX = entity.sectionX;
+        final int sectionY = entity.sectionY;
+        final int sectionZ = entity.sectionZ;
+        TickThread.ensureTickThread(this.world, sectionX, sectionZ, "Cannot remove entity off-main");
+        if (!entity.isRemoved()) {
+            throw new IllegalStateException("Only call Entity#setRemoved to remove an entity");
+        }
+        final ChunkEntitySlices slices = this.getChunk(sectionX, sectionZ);
+        // all entities should be in a chunk
+        if (slices == null) {
+            LOGGER.warn("Cannot remove entity " + entity + " from null entity slices (" + sectionX + "," + sectionZ + ")");
+        } else {
+            if (!slices.removeEntity(entity, sectionY)) {
+                LOGGER.warn("Failed to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ")");
+            }
+        }
+        entity.sectionX = entity.sectionY = entity.sectionZ = Integer.MIN_VALUE;
+
+        this.entityByLock.writeLock();
+        try {
+            if (!this.entityById.remove(entity.getId(), entity)) {
+                LOGGER.warn("Failed to remove entity " + entity + " by id, current entity mapped: " + this.entityById.get(entity.getId()));
+            }
+            if (!this.entityByUUID.remove(entity.getUUID(), entity)) {
+                LOGGER.warn("Failed to remove entity " + entity + " by uuid, current entity mapped: " + this.entityByUUID.get(entity.getUUID()));
+            }
+        } finally {
+            this.entityByLock.tryUnlockWrite();
+        }
+    }
+
+    private ChunkEntitySlices moveEntity(final Entity entity) {
+        // ensure we own the entity
+        TickThread.ensureTickThread(entity, "Cannot move entity off-main");
+
+        final BlockPos newPos = entity.blockPosition();
+        final int newSectionX = newPos.getX() >> 4;
+        final int newSectionY = Mth.clamp(newPos.getY() >> 4, this.minSection, this.maxSection);
+        final int newSectionZ = newPos.getZ() >> 4;
+
+        if (newSectionX == entity.sectionX && newSectionY == entity.sectionY && newSectionZ == entity.sectionZ) {
+            return null;
+        }
+
+        // ensure the new section is owned by this tick thread
+        TickThread.ensureTickThread(this.world, newSectionX, newSectionZ, "Cannot move entity off-main");
+
+        // ensure the old section is owned by this tick thread
+        TickThread.ensureTickThread(this.world, entity.sectionX, entity.sectionZ, "Cannot move entity off-main");
+
+        final ChunkEntitySlices old = this.getChunk(entity.sectionX, entity.sectionZ);
+        final ChunkEntitySlices slices = this.getOrCreateChunk(newSectionX, newSectionZ);
+
+        if (!old.removeEntity(entity, entity.sectionY)) {
+            LOGGER.warn("Could not remove entity " + entity + " from its old chunk section (" + entity.sectionX + "," + entity.sectionY + "," + entity.sectionZ + ") since it was not contained in the section");
+        }
+
+        if (!slices.addEntity(entity, newSectionY)) {
+            LOGGER.warn("Could not add entity " + entity + " to its new chunk section (" + newSectionX + "," + newSectionY + "," + newSectionZ + ") as it is already contained in the section");
+        }
+
+        entity.sectionX = newSectionX;
+        entity.sectionY = newSectionY;
+        entity.sectionZ = newSectionZ;
+
+        return slices;
+    }
+
+    public void getEntitiesWithoutDragonParts(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
+        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
+        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
+        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
+        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+
+        final int minRegionX = minChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
+        final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
+
+        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
+            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
+            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
+
+            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
+                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+
+                if (region == null) {
+                    continue;
+                }
+
+                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
+                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+
+                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+                        if (chunk == null || !chunk.status.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                            continue;
+                        }
+
+                        chunk.getEntitiesWithoutDragonParts(except, box, into, predicate);
+                    }
+                }
+            }
+        }
+    }
+
+    public void getEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
+        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
+        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
+        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
+        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+
+        final int minRegionX = minChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
+        final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
+
+        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
+            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
+            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
+
+            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
+                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+
+                if (region == null) {
+                    continue;
+                }
+
+                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
+                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+
+                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+                        if (chunk == null || !chunk.status.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                            continue;
+                        }
+
+                        chunk.getEntities(except, box, into, predicate);
+                    }
+                }
+            }
+        }
+    }
+
+    public void getHardCollidingEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
+        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
+        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
+        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
+        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+
+        final int minRegionX = minChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
+        final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
+
+        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
+            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
+            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
+
+            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
+                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+
+                if (region == null) {
+                    continue;
+                }
+
+                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
+                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+
+                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+                        if (chunk == null || !chunk.status.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                            continue;
+                        }
+
+                        chunk.getHardCollidingEntities(except, box, into, predicate);
+                    }
+                }
+            }
+        }
+    }
+
+    public <T extends Entity> void getEntities(final EntityType<?> type, final AABB box, final List<? super T> into,
+                                               final Predicate<? super T> predicate) {
+        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
+        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
+        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
+        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+
+        final int minRegionX = minChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
+        final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
+
+        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
+            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
+            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
+
+            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
+                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+
+                if (region == null) {
+                    continue;
+                }
+
+                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
+                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+
+                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+                        if (chunk == null || !chunk.status.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                            continue;
+                        }
+
+                        chunk.getEntities(type, box, (List)into, (Predicate)predicate);
+                    }
+                }
+            }
+        }
+    }
+
+    public <T extends Entity> void getEntities(final Class<? extends T> clazz, final Entity except, final AABB box, final List<? super T> into,
+                                               final Predicate<? super T> predicate) {
+        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
+        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
+        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
+        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+
+        final int minRegionX = minChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
+        final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
+
+        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
+            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
+            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
+
+            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
+                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+
+                if (region == null) {
+                    continue;
+                }
+
+                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
+                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+
+                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+                        if (chunk == null || !chunk.status.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                            continue;
+                        }
+
+                        chunk.getEntities(clazz, except, box, into, predicate);
+                    }
+                }
+            }
+        }
+    }
+
+    public void entitySectionLoad(final int chunkX, final int chunkZ, final ChunkEntitySlices slices) {
+        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot load in entity section off-main");
+        synchronized (this) {
+            final ChunkEntitySlices curr = this.getChunk(chunkX, chunkZ);
+            if (curr != null) {
+                this.removeChunk(chunkX, chunkZ);
+
+                curr.mergeInto(slices);
+
+                this.addChunk(chunkX, chunkZ, slices);
+            } else {
+                this.addChunk(chunkX, chunkZ, slices);
+            }
+        }
+    }
+
+    public void entitySectionUnload(final int chunkX, final int chunkZ) {
+        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot unload entity section off-main");
+        this.removeChunk(chunkX, chunkZ);
+    }
+
+    public ChunkEntitySlices getChunk(final int chunkX, final int chunkZ) {
+        final ChunkSlicesRegion region = this.getRegion(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT);
+        if (region == null) {
+            return null;
+        }
+
+        return region.get((chunkX & REGION_MASK) | ((chunkZ & REGION_MASK) << REGION_SHIFT));
+    }
+
+    public ChunkEntitySlices getOrCreateChunk(final int chunkX, final int chunkZ) {
+        final ChunkSlicesRegion region = this.getRegion(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT);
+        ChunkEntitySlices ret;
+        if (region == null || (ret = region.get((chunkX & REGION_MASK) | ((chunkZ & REGION_MASK) << REGION_SHIFT))) == null) {
+            // loadInEntityChunk will call addChunk for us
+            return this.world.chunkTaskScheduler.chunkHolderManager.getOrCreateEntityChunk(chunkX, chunkZ, true);
+        }
+
+        return ret;
+    }
+
+    public ChunkSlicesRegion getRegion(final int regionX, final int regionZ) {
+        final long key = CoordinateUtils.getChunkKey(regionX, regionZ);
+        final long attempt = this.stateLock.tryOptimisticRead();
+        if (attempt != 0L) {
+            try {
+                final ChunkSlicesRegion ret = this.regions.get(key);
+
+                if (this.stateLock.validate(attempt)) {
+                    return ret;
+                }
+            } catch (final Error error) {
+                throw error;
+            } catch (final Throwable thr) {
+                // ignore
+            }
+        }
+
+        this.stateLock.readLock();
+        try {
+            return this.regions.get(key);
+        } finally {
+            this.stateLock.tryUnlockRead();
+        }
+    }
+
+    private synchronized void removeChunk(final int chunkX, final int chunkZ) {
+        final long key = CoordinateUtils.getChunkKey(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT);
+        final int relIndex = (chunkX & REGION_MASK) | ((chunkZ & REGION_MASK) << REGION_SHIFT);
+
+        final ChunkSlicesRegion region = this.regions.get(key);
+        final int remaining = region.remove(relIndex);
+
+        if (remaining == 0) {
+            this.stateLock.writeLock();
+            try {
+                this.regions.remove(key);
+            } finally {
+                this.stateLock.tryUnlockWrite();
+            }
+        }
+    }
+
+    public synchronized void addChunk(final int chunkX, final int chunkZ, final ChunkEntitySlices slices) {
+        final long key = CoordinateUtils.getChunkKey(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT);
+        final int relIndex = (chunkX & REGION_MASK) | ((chunkZ & REGION_MASK) << REGION_SHIFT);
+
+        ChunkSlicesRegion region = this.regions.get(key);
+        if (region != null) {
+            region.add(relIndex, slices);
+        } else {
+            region = new ChunkSlicesRegion();
+            region.add(relIndex, slices);
+            this.stateLock.writeLock();
+            try {
+                this.regions.put(key, region);
+            } finally {
+                this.stateLock.tryUnlockWrite();
+            }
+        }
+    }
+
+    public static final class ChunkSlicesRegion {
+
+        protected final ChunkEntitySlices[] slices = new ChunkEntitySlices[REGION_SIZE * REGION_SIZE];
+        protected int sliceCount;
+
+        public ChunkEntitySlices get(final int index) {
+            return this.slices[index];
+        }
+
+        public int remove(final int index) {
+            final ChunkEntitySlices slices = this.slices[index];
+            if (slices == null) {
+                throw new IllegalStateException();
+            }
+
+            this.slices[index] = null;
+
+            return --this.sliceCount;
+        }
+
+        public void add(final int index, final ChunkEntitySlices slices) {
+            final ChunkEntitySlices curr = this.slices[index];
+            if (curr != null) {
+                throw new IllegalStateException();
+            }
+
+            this.slices[index] = slices;
+
+            ++this.sliceCount;
+        }
+    }
+
+    private final class EntityCallback implements EntityInLevelCallback {
+
+        public final Entity entity;
+
+        public EntityCallback(final Entity entity) {
+            this.entity = entity;
+        }
+
+        @Override
+        public void onMove() {
+            final Entity entity = this.entity;
+            final Visibility oldVisibility = getEntityStatus(entity);
+            final ChunkEntitySlices newSlices = EntityLookup.this.moveEntity(this.entity);
+            if (newSlices == null) {
+                // no new section, so didn't change sections
+                return;
+            }
+            final Visibility newVisibility = getEntityStatus(entity);
+
+            EntityLookup.this.entityStatusChange(entity, newSlices, oldVisibility, newVisibility, true, false, false);
+        }
+
+        @Override
+        public void onRemove(final Entity.RemovalReason reason) {
+            final Entity entity = this.entity;
+            TickThread.ensureTickThread(entity, "Cannot remove entity off-main"); // Paper - rewrite chunk system
+            final Visibility tickingState = EntityLookup.getEntityStatus(entity);
+
+            EntityLookup.this.removeEntity(entity);
+
+            EntityLookup.this.entityStatusChange(entity, null, tickingState, Visibility.HIDDEN, false, false, reason.shouldDestroy());
+
+            this.entity.setLevelCallback(NoOpCallback.INSTANCE);
+        }
+    }
+
+    private static final class NoOpCallback implements EntityInLevelCallback {
+
+        public static final NoOpCallback INSTANCE = new NoOpCallback();
+
+        @Override
+        public void onMove() {}
+
+        @Override
+        public void onRemove(final Entity.RemovalReason reason) {}
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..de137486f610e9042853512f630b9dcc74b29280
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
@@ -0,0 +1,1328 @@
+package io.papermc.paper.chunk.system.io;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import ca.spottedleaf.concurrentutil.executor.Cancellable;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedQueueExecutorThread;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadedTaskQueue;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import it.unimi.dsi.fastutil.HashCommon;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.storage.RegionFile;
+import net.minecraft.world.level.chunk.storage.RegionFileStorage;
+import org.slf4j.Logger;
+import java.io.IOException;
+import java.lang.invoke.VarHandle;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+/**
+ * Prioritised RegionFile I/O executor, responsible for all RegionFile access.
+ * <p>
+ *     All functions provided are MT-Safe, however certain ordering constraints are recommended:
+ *     <li>
+ *         Chunk saves may not occur for unloaded chunks.
+ *     </li>
+ *     <li>
+ *         Tasks must be scheduled on the chunk scheduler thread.
+ *     </li>
+ *     By following these constraints, no chunk data loss should occur with the exception of underlying I/O problems.
+ * </p>
+ */
+public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    /**
+     * The kinds of region files controlled by the region file thread. Add more when needed, and ensure
+     * getControllerFor is updated.
+     */
+    public static enum RegionFileType {
+        CHUNK_DATA,
+        POI_DATA,
+        ENTITY_DATA;
+    }
+
+    protected static final RegionFileType[] CACHED_REGIONFILE_TYPES = RegionFileType.values();
+
+    private ChunkDataController getControllerFor(final ServerLevel world, final RegionFileType type) {
+        switch (type) {
+            case CHUNK_DATA:
+                return world.chunkDataControllerNew;
+            case POI_DATA:
+                return world.poiDataControllerNew;
+            case ENTITY_DATA:
+                return world.entityDataControllerNew;
+            default:
+                throw new IllegalStateException("Unknown controller type " + type);
+        }
+    }
+
+    /**
+     * Collects regionfile data for a certain chunk.
+     */
+    public static final class RegionFileData {
+
+        private final boolean[] hasResult = new boolean[CACHED_REGIONFILE_TYPES.length];
+        private final CompoundTag[] data = new CompoundTag[CACHED_REGIONFILE_TYPES.length];
+        private final Throwable[] throwables = new Throwable[CACHED_REGIONFILE_TYPES.length];
+
+        /**
+         * Sets the result associated with the specified regionfile type. Note that
+         * results can only be set once per regionfile type.
+         *
+         * @param type The regionfile type.
+         * @param data The result to set.
+         */
+        public void setData(final RegionFileType type, final CompoundTag data) {
+            final int index = type.ordinal();
+
+            if (this.hasResult[index]) {
+                throw new IllegalArgumentException("Result already exists for type " + type);
+            }
+            this.hasResult[index] = true;
+            this.data[index] = data;
+        }
+
+        /**
+         * Sets the result associated with the specified regionfile type. Note that
+         * results can only be set once per regionfile type.
+         *
+         * @param type The regionfile type.
+         * @param throwable The result to set.
+         */
+        public void setThrowable(final RegionFileType type, final Throwable throwable) {
+            final int index = type.ordinal();
+
+            if (this.hasResult[index]) {
+                throw new IllegalArgumentException("Result already exists for type " + type);
+            }
+            this.hasResult[index] = true;
+            this.throwables[index] = throwable;
+        }
+
+        /**
+         * Returns whether there is a result for the specified regionfile type.
+         *
+         * @param type Specified regionfile type.
+         *
+         * @return Whether a result exists for {@code type}.
+         */
+        public boolean hasResult(final RegionFileType type) {
+            return this.hasResult[type.ordinal()];
+        }
+
+        /**
+         * Returns the data result for the regionfile type.
+         *
+         * @param type Specified regionfile type.
+         *
+         * @throws IllegalArgumentException If the result has not been set for {@code type}.
+         * @return The data result for the specified type. If the result is a {@code Throwable},
+         * then returns {@code null}.
+         */
+        public CompoundTag getData(final RegionFileType type) {
+            final int index = type.ordinal();
+
+            if (!this.hasResult[index]) {
+                throw new IllegalArgumentException("Result does not exist for type " + type);
+            }
+
+            return this.data[index];
+        }
+
+        /**
+         * Returns the throwable result for the regionfile type.
+         *
+         * @param type Specified regionfile type.
+         *
+         * @throws IllegalArgumentException If the result has not been set for {@code type}.
+         * @return The throwable result for the specified type. If the result is an {@code CompoundTag},
+         * then returns {@code null}.
+         */
+        public Throwable getThrowable(final RegionFileType type) {
+            final int index = type.ordinal();
+
+            if (!this.hasResult[index]) {
+                throw new IllegalArgumentException("Result does not exist for type " + type);
+            }
+
+            return this.throwables[index];
+        }
+    }
+
+    private static final Object INIT_LOCK = new Object();
+
+    static RegionFileIOThread[] threads;
+
+    /* needs to be consistent given a set of parameters */
+    static RegionFileIOThread selectThread(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type) {
+        if (threads == null) {
+            throw new IllegalStateException("Threads not initialised");
+        }
+
+        final int regionX = chunkX >> 5;
+        final int regionZ = chunkZ >> 5;
+        final int typeOffset = type.ordinal();
+
+        return threads[(System.identityHashCode(world) + regionX + regionZ + typeOffset) % threads.length];
+    }
+
+    /**
+     * Shuts down the I/O executor(s). Watis for all tasks to complete if specified.
+     * Tasks queued during this call might not be accepted, and tasks queued after will not be accepted.
+     *
+     * @param wait Whether to wait until all tasks have completed.
+     */
+    public static void close(final boolean wait) {
+        for (int i = 0, len = threads.length; i < len; ++i) {
+            threads[i].close(false, true);
+        }
+        if (wait) {
+            RegionFileIOThread.flush();
+        }
+    }
+
+    public static long[] getExecutedTasks() {
+        final long[] ret = new long[threads.length];
+        for (int i = 0, len = threads.length; i < len; ++i) {
+            ret[i] = threads[i].getTotalTasksExecuted();
+        }
+
+        return ret;
+    }
+
+    public static long[] getTasksScheduled() {
+        final long[] ret = new long[threads.length];
+        for (int i = 0, len = threads.length; i < len; ++i) {
+            ret[i] = threads[i].getTotalTasksScheduled();
+        }
+        return ret;
+    }
+
+    public static void flush() {
+        for (int i = 0, len = threads.length; i < len; ++i) {
+            threads[i].waitUntilAllExecuted();
+        }
+    }
+
+    public static void partialFlush(final int totalTasksRemaining) {
+        long failures = 1L; // start out at 0.25ms
+
+        for (;;) {
+            final long[] executed = getExecutedTasks();
+            final long[] scheduled = getTasksScheduled();
+
+            long sum = 0;
+            for (int i = 0; i < executed.length; ++i) {
+                sum += scheduled[i] - executed[i];
+            }
+
+            if (sum <= totalTasksRemaining) {
+                break;
+            }
+
+            failures = ConcurrentUtil.linearLongBackoff(failures, 250_000L, 5_000_000L); // 500us, 5ms
+        }
+    }
+
+    /**
+     * Inits the executor with the specified number of threads.
+     *
+     * @param threads Specified number of threads.
+     */
+    public static void init(final int threads) {
+        synchronized (INIT_LOCK) {
+            if (RegionFileIOThread.threads != null) {
+                throw new IllegalStateException("Already initialised threads");
+            }
+
+            RegionFileIOThread.threads = new RegionFileIOThread[threads];
+
+            for (int i = 0; i < threads; ++i) {
+                RegionFileIOThread.threads[i] = new RegionFileIOThread(i);
+                RegionFileIOThread.threads[i].start();
+            }
+        }
+    }
+
+    private RegionFileIOThread(final int threadNumber) {
+        super(new PrioritisedThreadedTaskQueue(), (int)(1.0e6)); // 1.0ms spinwait time
+        this.setName("RegionFile I/O Thread #" + threadNumber);
+        this.setPriority(Thread.NORM_PRIORITY - 2); // we keep priority close to normal because threads can wait on us
+        this.setUncaughtExceptionHandler((final Thread thread, final Throwable thr) -> {
+            LOGGER.error("Uncaught exception thrown from I/O thread, report this! Thread: " + thread.getName(), thr);
+        });
+    }
+
+    /**
+     * Returns whether the current thread is a regionfile I/O executor.
+     * @return Whether the current thread is a regionfile I/O executor.
+     */
+    public static boolean isRegionFileThread() {
+        return Thread.currentThread() instanceof RegionFileIOThread;
+    }
+
+    /**
+     * Returns the priority associated with blocking I/O based on the current thread. The goal is to avoid
+     * dumb plugins from taking away priority from threads we consider crucial.
+     * @return The priroity to use with blocking I/O on the current thread.
+     */
+    public static PrioritisedExecutor.Priority getIOBlockingPriorityForCurrentThread() {
+        if (TickThread.isTickThread()) {
+            return PrioritisedExecutor.Priority.BLOCKING;
+        }
+        return PrioritisedExecutor.Priority.HIGHEST;
+    }
+
+    /**
+     * Returns the current {@code CompoundTag} pending for write for the specified chunk & regionfile type.
+     * Note that this does not copy the result, so do not modify the result returned.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param type Specified regionfile type.
+     *
+     * @return The compound tag associated for the specified chunk. {@code null} if no write was pending, or if {@code null} is the write pending.
+     */
+    public static CompoundTag getPendingWrite(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        return thread.getPendingWriteInternal(world, chunkX, chunkZ, type);
+    }
+
+    CompoundTag getPendingWriteInternal(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+        final ChunkDataTask task = taskController.tasks.get(Long.valueOf(CoordinateUtils.getChunkKey(chunkX, chunkZ)));
+
+        if (task == null) {
+            return null;
+        }
+
+        final CompoundTag ret = task.inProgressWrite;
+
+        return ret == ChunkDataTask.NOTHING_TO_WRITE ? null : ret;
+    }
+
+    /**
+     * Returns the priority for the specified regionfile type for the specified chunk.
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param type Specified regionfile type.
+     * @return The priority for the chunk
+     */
+    public static PrioritisedExecutor.Priority getPriority(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        return thread.getPriorityInternal(world, chunkX, chunkZ, type);
+    }
+
+    PrioritisedExecutor.Priority getPriorityInternal(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+        final ChunkDataTask task = taskController.tasks.get(Long.valueOf(CoordinateUtils.getChunkKey(chunkX, chunkZ)));
+
+        if (task == null) {
+            return PrioritisedExecutor.Priority.COMPLETING;
+        }
+
+        return task.prioritisedTask.getPriority();
+    }
+
+    /**
+     * Sets the priority for all regionfile types for the specified chunk. Note that great care should
+     * be taken using this method, as there can be multiple tasks tied to the same chunk that want different
+     * priorities.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param priority New priority.
+     *
+     * @see #raisePriority(ServerLevel, int, int, Priority)
+     * @see #raisePriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void setPriority(final ServerLevel world, final int chunkX, final int chunkZ,
+                                   final PrioritisedExecutor.Priority priority) {
+        for (final RegionFileType type : CACHED_REGIONFILE_TYPES) {
+            RegionFileIOThread.setPriority(world, chunkX, chunkZ, type, priority);
+        }
+    }
+
+    /**
+     * Sets the priority for the specified regionfile type for the specified chunk. Note that great care should
+     * be taken using this method, as there can be multiple tasks tied to the same chunk that want different
+     * priorities.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param type Specified regionfile type.
+     * @param priority New priority.
+     *
+     * @see #raisePriority(ServerLevel, int, int, Priority)
+     * @see #raisePriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void setPriority(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                                   final PrioritisedExecutor.Priority priority) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        thread.setPriorityInternal(world, chunkX, chunkZ, type, priority);
+    }
+
+    void setPriorityInternal(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                             final PrioritisedExecutor.Priority priority) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+        final ChunkDataTask task = taskController.tasks.get(Long.valueOf(CoordinateUtils.getChunkKey(chunkX, chunkZ)));
+
+        if (task != null) {
+            task.prioritisedTask.setPriority(priority);
+        }
+    }
+
+    /**
+     * Raises the priority for all regionfile types for the specified chunk.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param priority New priority.
+     *
+     * @see #setPriority(ServerLevel, int, int, Priority)
+     * @see #setPriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void raisePriority(final ServerLevel world, final int chunkX, final int chunkZ,
+                                     final PrioritisedExecutor.Priority priority) {
+        for (final RegionFileType type : CACHED_REGIONFILE_TYPES) {
+            RegionFileIOThread.raisePriority(world, chunkX, chunkZ, type, priority);
+        }
+    }
+
+    /**
+     * Raises the priority for the specified regionfile type for the specified chunk.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param type Specified regionfile type.
+     * @param priority New priority.
+     *
+     * @see #setPriority(ServerLevel, int, int, Priority)
+     * @see #setPriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void raisePriority(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                                     final PrioritisedExecutor.Priority priority) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        thread.raisePriorityInternal(world, chunkX, chunkZ, type, priority);
+    }
+
+    void raisePriorityInternal(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                               final PrioritisedExecutor.Priority priority) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+        final ChunkDataTask task = taskController.tasks.get(Long.valueOf(CoordinateUtils.getChunkKey(chunkX, chunkZ)));
+
+        if (task != null) {
+            task.prioritisedTask.raisePriority(priority);
+        }
+    }
+
+    /**
+     * Lowers the priority for all regionfile types for the specified chunk.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param priority New priority.
+     *
+     * @see #raisePriority(ServerLevel, int, int, Priority)
+     * @see #raisePriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #setPriority(ServerLevel, int, int, Priority)
+     * @see #setPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void lowerPriority(final ServerLevel world, final int chunkX, final int chunkZ,
+                                     final PrioritisedExecutor.Priority priority) {
+        for (final RegionFileType type : CACHED_REGIONFILE_TYPES) {
+            RegionFileIOThread.lowerPriority(world, chunkX, chunkZ, type, priority);
+        }
+    }
+
+    /**
+     * Lowers the priority for the specified regionfile type for the specified chunk.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param type Specified regionfile type.
+     * @param priority New priority.
+     *
+     * @see #raisePriority(ServerLevel, int, int, Priority)
+     * @see #raisePriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #setPriority(ServerLevel, int, int, Priority)
+     * @see #setPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void lowerPriority(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                                     final PrioritisedExecutor.Priority priority) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        thread.lowerPriorityInternal(world, chunkX, chunkZ, type, priority);
+    }
+
+    void lowerPriorityInternal(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                               final PrioritisedExecutor.Priority priority) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+        final ChunkDataTask task = taskController.tasks.get(Long.valueOf(CoordinateUtils.getChunkKey(chunkX, chunkZ)));
+
+        if (task != null) {
+            task.prioritisedTask.lowerPriority(priority);
+        }
+    }
+
+    /**
+     * Schedules the chunk data to be written asynchronously.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     This function presumes a chunk load for the coordinates is not called during this function (anytime after is OK). This means
+     *     saves must be scheduled before a chunk is unloaded.
+     * </li>
+     * <li>
+     *     Writes may be called concurrently, although only the "later" write will go through.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param data Chunk's data
+     * @param type The regionfile type to write to.
+     *
+     * @throws IllegalStateException If the file io thread has shutdown.
+     */
+    public static void scheduleSave(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data,
+                                    final RegionFileType type) {
+        RegionFileIOThread.scheduleSave(world, chunkX, chunkZ, data, type, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    /**
+     * Schedules the chunk data to be written asynchronously.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     This function presumes a chunk load for the coordinates is not called during this function (anytime after is OK). This means
+     *     saves must be scheduled before a chunk is unloaded.
+     * </li>
+     * <li>
+     *     Writes may be called concurrently, although only the "later" write will go through.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param data Chunk's data
+     * @param type The regionfile type to write to.
+     * @param priority The minimum priority to schedule at.
+     *
+     * @throws IllegalStateException If the file io thread has shutdown.
+     */
+    public static void scheduleSave(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data,
+                                    final RegionFileType type, final PrioritisedExecutor.Priority priority) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        thread.scheduleSaveInternal(world, chunkX, chunkZ, data, type, priority);
+    }
+
+    void scheduleSaveInternal(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data,
+                              final RegionFileType type, final PrioritisedExecutor.Priority priority) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+
+        final boolean[] created = new boolean[1];
+        final ChunkCoordinate key = new ChunkCoordinate(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        final ChunkDataTask task = taskController.tasks.compute(key, (final ChunkCoordinate keyInMap, final ChunkDataTask taskRunning) -> {
+            if (taskRunning == null || taskRunning.failedWrite) {
+                // no task is scheduled or the previous write failed - meaning we need to overwrite it
+
+                // create task
+                final ChunkDataTask newTask = new ChunkDataTask(world, chunkX, chunkZ, taskController, RegionFileIOThread.this, priority);
+                newTask.inProgressWrite = data;
+                created[0] = true;
+
+                return newTask;
+            }
+
+            taskRunning.inProgressWrite = data;
+
+            return taskRunning;
+        });
+
+        if (created[0]) {
+            task.prioritisedTask.queue();
+        } else {
+            task.prioritisedTask.raisePriority(priority);
+        }
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load all regionfile types, and then call
+     * {@code onComplete}. This is a bulk load operation, see {@link #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)}
+     * for single load.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, RegionFileType...)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, Priority, RegionFileType...)
+     */
+    public static Cancellable loadAllChunkData(final ServerLevel world, final int chunkX, final int chunkZ,
+                                               final Consumer<RegionFileData> onComplete, final boolean intendingToBlock) {
+        return RegionFileIOThread.loadAllChunkData(world, chunkX, chunkZ, onComplete, intendingToBlock, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load all regionfile types, and then call
+     * {@code onComplete}. This is a bulk load operation, see {@link #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)}
+     * for single load.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     * @param priority The minimum priority to load the data at.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, RegionFileType...)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, Priority, RegionFileType...)
+     */
+    public static Cancellable loadAllChunkData(final ServerLevel world, final int chunkX, final int chunkZ,
+                                               final Consumer<RegionFileData> onComplete, final boolean intendingToBlock,
+                                               final PrioritisedExecutor.Priority priority) {
+        return RegionFileIOThread.loadChunkData(world, chunkX, chunkZ, onComplete, intendingToBlock, priority, CACHED_REGIONFILE_TYPES);
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load data for the specified regionfile type(s), and
+     * then call {@code onComplete}. This is a bulk load operation, see {@link #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)}
+     * for single load.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     * @param types The regionfile type(s) to load.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean, Priority)
+     */
+    public static Cancellable loadChunkData(final ServerLevel world, final int chunkX, final int chunkZ,
+                                            final Consumer<RegionFileData> onComplete, final boolean intendingToBlock,
+                                            final RegionFileType... types) {
+        return RegionFileIOThread.loadChunkData(world, chunkX, chunkZ, onComplete, intendingToBlock, PrioritisedExecutor.Priority.NORMAL, types);
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load data for the specified regionfile type(s), and
+     * then call {@code onComplete}. This is a bulk load operation, see {@link #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)}
+     * for single load.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     * @param types The regionfile type(s) to load.
+     * @param priority The minimum priority to load the data at.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean, Priority)
+     */
+    public static Cancellable loadChunkData(final ServerLevel world, final int chunkX, final int chunkZ,
+                                            final Consumer<RegionFileData> onComplete, final boolean intendingToBlock,
+                                            final PrioritisedExecutor.Priority priority, final RegionFileType... types) {
+        if (types == null) {
+            throw new NullPointerException("Types cannot be null");
+        }
+        if (types.length == 0) {
+            throw new IllegalArgumentException("Types cannot be empty");
+        }
+
+        final RegionFileData ret = new RegionFileData();
+
+        final Cancellable[] reads = new CancellableRead[types.length];
+        final AtomicInteger completions = new AtomicInteger();
+        final int expectedCompletions = types.length;
+
+        for (int i = 0; i < expectedCompletions; ++i) {
+            final RegionFileType type = types[i];
+            reads[i] = RegionFileIOThread.loadDataAsync(world, chunkX, chunkZ, type,
+                (final CompoundTag data, final Throwable throwable) -> {
+                    if (throwable != null) {
+                        ret.setThrowable(type, throwable);
+                    } else {
+                        ret.setData(type, data);
+                    }
+
+                    if (completions.incrementAndGet() == expectedCompletions) {
+                        onComplete.accept(ret);
+                    }
+                }, intendingToBlock, priority);
+        }
+
+        return new CancellableReads(reads);
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load the specified regionfile type, and then call
+     * {@code onComplete}.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, RegionFileType...)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, Priority, RegionFileType...)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean, Priority)
+     */
+    public static Cancellable loadDataAsync(final ServerLevel world, final int chunkX, final int chunkZ,
+                                            final RegionFileType type, final BiConsumer<CompoundTag, Throwable> onComplete,
+                                            final boolean intendingToBlock) {
+        return RegionFileIOThread.loadDataAsync(world, chunkX, chunkZ, type, onComplete, intendingToBlock, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load the specified regionfile type, and then call
+     * {@code onComplete}.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     * @param priority Minimum priority to load the data at.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, RegionFileType...)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, Priority, RegionFileType...)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean, Priority)
+     */
+    public static Cancellable loadDataAsync(final ServerLevel world, final int chunkX, final int chunkZ,
+                                            final RegionFileType type, final BiConsumer<CompoundTag, Throwable> onComplete,
+                                            final boolean intendingToBlock, final PrioritisedExecutor.Priority priority) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        return thread.loadDataAsyncInternal(world, chunkX, chunkZ, type, onComplete, intendingToBlock, priority);
+    }
+
+    private static Boolean doesRegionFileExist(final int chunkX, final int chunkZ, final boolean intendingToBlock,
+                                               final ChunkDataController taskController) {
+        final ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
+        if (intendingToBlock) {
+            return taskController.computeForRegionFile(chunkX, chunkZ, true, (final RegionFile file) -> {
+                if (file == null) { // null if no regionfile exists
+                    return Boolean.FALSE;
+                }
+
+                return file.hasChunk(chunkPos) ? Boolean.TRUE : Boolean.FALSE;
+            });
+        } else {
+            return taskController.computeForRegionFileIfLoaded(chunkX, chunkZ, (final RegionFile file) -> {
+                if (file == null) { // null if not loaded
+                    return Boolean.TRUE;
+                }
+
+                return file.hasChunk(chunkPos) ? Boolean.TRUE : Boolean.FALSE;
+            });
+        }
+    }
+
+    Cancellable loadDataAsyncInternal(final ServerLevel world, final int chunkX, final int chunkZ,
+                                      final RegionFileType type, final BiConsumer<CompoundTag, Throwable> onComplete,
+                                      final boolean intendingToBlock, final PrioritisedExecutor.Priority priority) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+
+        final ImmediateCallbackCompletion callbackInfo = new ImmediateCallbackCompletion();
+
+        final ChunkCoordinate key = new ChunkCoordinate(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        final BiFunction<ChunkCoordinate, ChunkDataTask, ChunkDataTask> compute = (final ChunkCoordinate keyInMap, final ChunkDataTask running) -> {
+            if (running == null) {
+                // not scheduled
+
+                if (callbackInfo.regionFileCalculation == null) {
+                    // caller will compute this outside of compute(), to avoid holding the bin lock
+                    callbackInfo.needsRegionFileTest = true;
+                    return null;
+                }
+
+                if (callbackInfo.regionFileCalculation == Boolean.FALSE) {
+                    // not on disk
+                    callbackInfo.data = null;
+                    callbackInfo.throwable = null;
+                    callbackInfo.completeNow = true;
+                    return null;
+                }
+
+                // set up task
+                final ChunkDataTask newTask = new ChunkDataTask(
+                    world, chunkX, chunkZ, taskController, RegionFileIOThread.this, priority
+                );
+                newTask.inProgressRead = new RegionFileIOThread.InProgressRead();
+                newTask.inProgressRead.waiters.add(onComplete);
+
+                callbackInfo.tasksNeedsScheduling = true;
+                return newTask;
+            }
+
+            final CompoundTag pendingWrite = running.inProgressWrite;
+
+            if (pendingWrite == ChunkDataTask.NOTHING_TO_WRITE) {
+                // need to add to waiters here, because the regionfile thread will use compute() to lock and check for cancellations
+                if (!running.inProgressRead.addToWaiters(onComplete)) {
+                    callbackInfo.data = running.inProgressRead.value;
+                    callbackInfo.throwable = running.inProgressRead.throwable;
+                    callbackInfo.completeNow = true;
+                }
+                return running;
+            }
+            // using the result sync here - don't bump priority
+
+            // at this stage we have to use the in progress write's data to avoid an order issue
+            callbackInfo.data = pendingWrite;
+            callbackInfo.throwable = null;
+            callbackInfo.completeNow = true;
+            return running;
+        };
+
+        ChunkDataTask curr = taskController.tasks.get(key);
+        if (curr == null) {
+            callbackInfo.regionFileCalculation = doesRegionFileExist(chunkX, chunkZ, intendingToBlock, taskController);
+        }
+        ChunkDataTask ret = taskController.tasks.compute(key, compute);
+        if (callbackInfo.needsRegionFileTest) {
+            // curr isn't null but when we went into compute() it was
+            callbackInfo.regionFileCalculation = doesRegionFileExist(chunkX, chunkZ, intendingToBlock, taskController);
+            // now it should be fine
+            ret = taskController.tasks.compute(key, compute);
+        }
+
+        // needs to be scheduled
+        if (callbackInfo.tasksNeedsScheduling) {
+            ret.prioritisedTask.queue();
+        } else if (callbackInfo.completeNow) {
+            try {
+                onComplete.accept(callbackInfo.data, callbackInfo.throwable);
+            } catch (final ThreadDeath thr) {
+                throw thr;
+            } catch (final Throwable thr) {
+                LOGGER.error("Callback " + ConcurrentUtil.genericToString(onComplete) + " synchronously failed to handle chunk data for task " + ret.toString(), thr);
+            }
+        } else {
+            // we're waiting on a task we didn't schedule, so raise its priority to what we want
+            ret.prioritisedTask.raisePriority(priority);
+        }
+
+        return new CancellableRead(onComplete, ret);
+    }
+
+    /**
+     * Schedules a load task to be executed asynchronously, and blocks on that task.
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param type Regionfile type
+     * @param priority Minimum priority to load the data at.
+     *
+     * @return The chunk data for the chunk. Note that a {@code null} result means the chunk or regionfile does not exist on disk.
+     *
+     * @throws IOException If the load fails for any reason
+     */
+    public static CompoundTag loadData(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                                       final PrioritisedExecutor.Priority priority) throws IOException {
+        final CompletableFuture<CompoundTag> ret = new CompletableFuture<>();
+
+        RegionFileIOThread.loadDataAsync(world, chunkX, chunkZ, type, (final CompoundTag compound, final Throwable thr) -> {
+            if (thr != null) {
+                ret.completeExceptionally(thr);
+            } else {
+                ret.complete(compound);
+            }
+        }, true, priority);
+
+        try {
+            return ret.join();
+        } catch (final CompletionException ex) {
+            throw new IOException(ex);
+        }
+    }
+
+    private static final class ImmediateCallbackCompletion {
+
+        public CompoundTag data;
+        public Throwable throwable;
+        public boolean completeNow;
+        public boolean tasksNeedsScheduling;
+        public boolean needsRegionFileTest;
+        public Boolean regionFileCalculation;
+
+    }
+
+    static final class CancellableRead implements Cancellable {
+
+        private BiConsumer<CompoundTag, Throwable> callback;
+        private RegionFileIOThread.ChunkDataTask task;
+
+        CancellableRead(final BiConsumer<CompoundTag, Throwable> callback, final RegionFileIOThread.ChunkDataTask task) {
+            this.callback = callback;
+            this.task = task;
+        }
+
+        @Override
+        public boolean cancel() {
+            final BiConsumer<CompoundTag, Throwable> callback = this.callback;
+            final RegionFileIOThread.ChunkDataTask task = this.task;
+
+            if (callback == null || task == null) {
+                return false;
+            }
+
+            this.callback = null;
+            this.task = null;
+
+            final RegionFileIOThread.InProgressRead read = task.inProgressRead;
+
+            // read can be null if no read was scheduled (i.e no regionfile existed or chunk in regionfile didn't)
+            return (read != null && read.waiters.remove(callback));
+        }
+    }
+
+    static final class CancellableReads implements Cancellable {
+
+        private Cancellable[] reads;
+
+        protected static final VarHandle READS_HANDLE = ConcurrentUtil.getVarHandle(CancellableReads.class, "reads", Cancellable[].class);
+
+        CancellableReads(final Cancellable[] reads) {
+            this.reads = reads;
+        }
+
+        @Override
+        public boolean cancel() {
+            final Cancellable[] reads = (Cancellable[])READS_HANDLE.getAndSet((CancellableReads)this, (Cancellable[])null);
+
+            if (reads == null) {
+                return false;
+            }
+
+            boolean ret = false;
+
+            for (final Cancellable read : reads) {
+                ret |= read.cancel();
+            }
+
+            return ret;
+        }
+    }
+
+    static final class InProgressRead {
+
+        private static final Logger LOGGER = LogUtils.getLogger();
+
+        CompoundTag value;
+        Throwable throwable;
+        final MultiThreadedQueue<BiConsumer<CompoundTag, Throwable>> waiters = new MultiThreadedQueue<>();
+
+        // rets false if already completed (callback not invoked), true if callback was added
+        boolean addToWaiters(final BiConsumer<CompoundTag, Throwable> callback) {
+            return this.waiters.add(callback);
+        }
+
+        void complete(final RegionFileIOThread.ChunkDataTask task, final CompoundTag value, final Throwable throwable) {
+            this.value = value;
+            this.throwable = throwable;
+
+            BiConsumer<CompoundTag, Throwable> consumer;
+            while ((consumer = this.waiters.pollOrBlockAdds()) != null) {
+                try {
+                    consumer.accept(value, throwable);
+                } catch (final ThreadDeath thr) {
+                    throw thr;
+                } catch (final Throwable thr) {
+                    LOGGER.error("Callback " + ConcurrentUtil.genericToString(consumer) + " failed to handle chunk data for task " + task.toString(), thr);
+                }
+            }
+        }
+    }
+
+    /**
+     * Class exists to replace {@link Long} usages as keys inside non-fastutil hashtables. The hash for some Long {@code x}
+     * is defined as {@code (x >>> 32) ^ x}. Chunk keys as long values are defined as {@code ((chunkX & 0xFFFFFFFFL) | (chunkZ << 32))},
+     * which means the hashcode as a Long value will be {@code chunkX ^ chunkZ}. Given that most chunks are created within a radius arounds players,
+     * this will lead to many hash collisions. So, this class uses a better hashing algorithm so that usage of
+     * non-fastutil collections is not degraded.
+     */
+    public static final class ChunkCoordinate implements Comparable<ChunkCoordinate> {
+
+        public final long key;
+
+        public ChunkCoordinate(final long key) {
+            this.key = key;
+        }
+
+        @Override
+        public int hashCode() {
+            return (int)HashCommon.mix(this.key);
+        }
+
+        @Override
+        public boolean equals(final Object obj) {
+            if (this == obj) {
+                return true;
+            }
+
+            if (!(obj instanceof ChunkCoordinate)) {
+                return false;
+            }
+
+            final ChunkCoordinate other = (ChunkCoordinate)obj;
+
+            return this.key == other.key;
+        }
+
+        // This class is intended for HashMap/ConcurrentHashMap usage, which do treeify bin nodes if the chain
+        // is too large. So we should implement compareTo to help.
+        @Override
+        public int compareTo(final RegionFileIOThread.ChunkCoordinate other) {
+            return Long.compare(this.key, other.key);
+        }
+
+        @Override
+        public String toString() {
+            return new ChunkPos(this.key).toString();
+        }
+    }
+
+    public static abstract class ChunkDataController {
+
+        // ConcurrentHashMap synchronizes per chain, so reduce the chance of task's hashes colliding.
+        protected final ConcurrentHashMap<ChunkCoordinate, ChunkDataTask> tasks = new ConcurrentHashMap<>(8192, 0.10f);
+
+        public final RegionFileType type;
+
+        public ChunkDataController(final RegionFileType type) {
+            this.type = type;
+        }
+
+        public abstract RegionFileStorage getCache();
+
+        public abstract void writeData(final int chunkX, final int chunkZ, final CompoundTag compound) throws IOException;
+
+        public abstract CompoundTag readData(final int chunkX, final int chunkZ) throws IOException;
+
+        public boolean hasTasks() {
+            return !this.tasks.isEmpty();
+        }
+
+        public <T> T computeForRegionFile(final int chunkX, final int chunkZ, final boolean existingOnly, final Function<RegionFile, T> function) {
+            final RegionFileStorage cache = this.getCache();
+            final RegionFile regionFile;
+            synchronized (cache) {
+                try {
+                    regionFile = cache.getRegionFile(new ChunkPos(chunkX, chunkZ), existingOnly, true);
+                } catch (final IOException ex) {
+                    throw new RuntimeException(ex);
+                }
+            }
+
+            try {
+                return function.apply(regionFile);
+            } finally {
+                if (regionFile != null) {
+                    regionFile.fileLock.unlock();
+                }
+            }
+        }
+
+        public <T> T computeForRegionFileIfLoaded(final int chunkX, final int chunkZ, final Function<RegionFile, T> function) {
+            final RegionFileStorage cache = this.getCache();
+            final RegionFile regionFile;
+
+            synchronized (cache) {
+                regionFile = cache.getRegionFileIfLoaded(new ChunkPos(chunkX, chunkZ));
+                if (regionFile != null) {
+                    regionFile.fileLock.lock();
+                }
+            }
+
+            try {
+                return function.apply(regionFile);
+            } finally {
+                if (regionFile != null) {
+                    regionFile.fileLock.unlock();
+                }
+            }
+        }
+    }
+
+    static final class ChunkDataTask implements Runnable {
+
+        protected static final CompoundTag NOTHING_TO_WRITE = new CompoundTag();
+
+        private static final Logger LOGGER = LogUtils.getLogger();
+
+        RegionFileIOThread.InProgressRead inProgressRead;
+        volatile CompoundTag inProgressWrite = NOTHING_TO_WRITE; // only needs to be acquire/release
+
+        boolean failedWrite;
+
+        final ServerLevel world;
+        final int chunkX;
+        final int chunkZ;
+        final RegionFileIOThread.ChunkDataController taskController;
+
+        final PrioritisedExecutor.PrioritisedTask prioritisedTask;
+
+        /*
+         * IO thread will perform reads before writes for a given chunk x and z
+         *
+         * How reads/writes are scheduled:
+         *
+         * If read is scheduled while scheduling write, take no special action and just schedule write
+         * If read is scheduled while scheduling read and no write is scheduled, chain the read task
+         *
+         *
+         * If write is scheduled while scheduling read, use the pending write data and ret immediately (so no read is scheduled)
+         * If write is scheduled while scheduling write (ignore read in progress), overwrite the write in progress data
+         *
+         * This allows the reads and writes to act as if they occur synchronously to the thread scheduling them, however
+         * it fails to properly propagate write failures thanks to writes overwriting each other
+         */
+
+        public ChunkDataTask(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileIOThread.ChunkDataController taskController,
+                             final PrioritisedExecutor executor, final PrioritisedExecutor.Priority priority) {
+            this.world = world;
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+            this.taskController = taskController;
+            this.prioritisedTask = executor.createTask(this, priority);
+        }
+
+        @Override
+        public String toString() {
+            return "Task for world: '" + this.world.getWorld().getName() + "' at (" + this.chunkX + "," + this.chunkZ +
+                    ") type: " + this.taskController.type.name() + ", hash: " + this.hashCode();
+        }
+
+        @Override
+        public void run() {
+            final RegionFileIOThread.InProgressRead read = this.inProgressRead;
+            final ChunkCoordinate chunkKey = new ChunkCoordinate(CoordinateUtils.getChunkKey(this.chunkX, this.chunkZ));
+
+            if (read != null) {
+                final boolean[] canRead = new boolean[] { true };
+
+                if (read.waiters.isEmpty()) {
+                    // cancelled read? go to task controller to confirm
+                    final ChunkDataTask inMap = this.taskController.tasks.compute(chunkKey, (final ChunkCoordinate keyInMap, final ChunkDataTask valueInMap) -> {
+                        if (valueInMap == null) {
+                            throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this.toString() + ", report this!");
+                        }
+                        if (valueInMap != ChunkDataTask.this) {
+                            throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this.toString() + ", got: " + valueInMap.toString() + ", report this!");
+                        }
+
+                        if (!read.waiters.isEmpty()) { // as per usual IntelliJ is unable to figure out that there are concurrent accesses.
+                            return valueInMap;
+                        } else {
+                            canRead[0] = false;
+                        }
+
+                        return valueInMap.inProgressWrite == NOTHING_TO_WRITE ? null : valueInMap;
+                    });
+
+                    if (inMap == null) {
+                        // read is cancelled - and no write pending, so we're done
+                        return;
+                    }
+                    // if there is a write in progress, we don't actually have to worry about waiters gaining new entries -
+                    // the readers will just use the in progress write, so the value in canRead is good to use without
+                    // further synchronisation.
+                }
+
+                if (canRead[0]) {
+                    CompoundTag compound = null;
+                    Throwable throwable = null;
+
+                    try {
+                        compound = this.taskController.readData(this.chunkX, this.chunkZ);
+                    } catch (final ThreadDeath thr) {
+                        throw thr;
+                    } catch (final Throwable thr) {
+                        throwable = thr;
+                        LOGGER.error("Failed to read chunk data for task: " + this.toString(), thr);
+                    }
+                    read.complete(this, compound, throwable);
+                }
+            }
+
+            CompoundTag write = this.inProgressWrite;
+
+            if (write == NOTHING_TO_WRITE) {
+                final ChunkDataTask inMap = this.taskController.tasks.compute(chunkKey, (final ChunkCoordinate keyInMap, final ChunkDataTask valueInMap) -> {
+                    if (valueInMap == null) {
+                        throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this.toString() + ", report this!");
+                    }
+                    if (valueInMap != ChunkDataTask.this) {
+                        throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this.toString() + ", got: " + valueInMap.toString() + ", report this!");
+                    }
+                    return valueInMap.inProgressWrite == NOTHING_TO_WRITE ? null : valueInMap;
+                });
+
+                if (inMap == null) {
+                    return; // set the task value to null, indicating we're done
+                } // else: inProgressWrite changed, so now we have something to write
+            }
+
+            for (;;) {
+                write = this.inProgressWrite;
+                final CompoundTag dataWritten = write;
+
+                boolean failedWrite = false;
+
+                try {
+                    this.taskController.writeData(this.chunkX, this.chunkZ, write);
+                } catch (final ThreadDeath thr) {
+                    throw thr;
+                } catch (final Throwable thr) {
+                    if (thr instanceof RegionFileStorage.RegionFileSizeException) {
+                        final int maxSize = RegionFile.MAX_CHUNK_SIZE / (1024 * 1024);
+                        LOGGER.error("Chunk at (" + this.chunkX + "," + this.chunkZ + ") in '" + this.world.getWorld().getName() + "' exceeds max size of " + maxSize + "MiB, it has been deleted from disk.");
+                    } else {
+                        failedWrite = thr instanceof IOException;
+                        LOGGER.error("Failed to write chunk data for task: " + this.toString(), thr);
+                    }
+                }
+
+                final boolean finalFailWrite = failedWrite;
+                final boolean[] done = new boolean[] { false };
+
+                this.taskController.tasks.compute(chunkKey, (final ChunkCoordinate keyInMap, final ChunkDataTask valueInMap) -> {
+                    if (valueInMap == null) {
+                        throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this.toString() + ", report this!");
+                    }
+                    if (valueInMap != ChunkDataTask.this) {
+                        throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this.toString() + ", got: " + valueInMap.toString() + ", report this!");
+                    }
+                    if (valueInMap.inProgressWrite == dataWritten) {
+                        valueInMap.failedWrite = finalFailWrite;
+                        done[0] = true;
+                        // keep the data in map if we failed the write so we can try to prevent data loss
+                        return finalFailWrite ? valueInMap : null;
+                    }
+                    // different data than expected, means we need to retry write
+                    return valueInMap;
+                });
+
+                if (done[0]) {
+                    return;
+                }
+
+                // fetch & write new data
+                continue;
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java b/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b7a2b0ead4f3bc07bfd9a38c2b7cf024bd140c6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java
@@ -0,0 +1,280 @@
+package io.papermc.paper.chunk.system.light;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.starlight.common.light.BlockStarLightEngine;
+import ca.spottedleaf.starlight.common.light.SkyStarLightEngine;
+import ca.spottedleaf.starlight.common.light.StarLightInterface;
+import io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler;
+import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.shorts.ShortCollection;
+import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.BooleanSupplier;
+
+public final class LightQueue {
+
+    protected final Long2ObjectOpenHashMap<ChunkTasks> chunkTasks = new Long2ObjectOpenHashMap<>();
+    protected final StarLightInterface manager;
+    protected final ServerLevel world;
+
+    public LightQueue(final StarLightInterface manager) {
+        this.manager = manager;
+        this.world = ((ServerLevel)manager.getWorld());
+    }
+
+    public void lowerPriority(final int chunkX, final int chunkZ, final PrioritisedExecutor.Priority priority) {
+        final ChunkTasks task;
+        synchronized (this) {
+            task = this.chunkTasks.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        }
+        if (task != null) {
+            task.lowerPriority(priority);
+        }
+    }
+
+    public void setPriority(final int chunkX, final int chunkZ, final PrioritisedExecutor.Priority priority) {
+        final ChunkTasks task;
+        synchronized (this) {
+            task = this.chunkTasks.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        }
+        if (task != null) {
+            task.setPriority(priority);
+        }
+    }
+
+    public void raisePriority(final int chunkX, final int chunkZ, final PrioritisedExecutor.Priority priority) {
+        final ChunkTasks task;
+        synchronized (this) {
+            task = this.chunkTasks.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        }
+        if (task != null) {
+            task.raisePriority(priority);
+        }
+    }
+
+    public PrioritisedExecutor.Priority getPriority(final int chunkX, final int chunkZ) {
+        final ChunkTasks task;
+        synchronized (this) {
+            task = this.chunkTasks.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        }
+        if (task != null) {
+            return task.getPriority();
+        }
+
+        return PrioritisedExecutor.Priority.COMPLETING;
+    }
+
+    public boolean isEmpty() {
+        synchronized (this) {
+            return this.chunkTasks.isEmpty();
+        }
+    }
+
+    public CompletableFuture<Void> queueBlockChange(final BlockPos pos) {
+        final ChunkTasks tasks;
+        synchronized (this) {
+            tasks = this.chunkTasks.computeIfAbsent(CoordinateUtils.getChunkKey(pos), (final long keyInMap) -> {
+                return new ChunkTasks(keyInMap, LightQueue.this.manager, LightQueue.this);
+            });
+            tasks.changedPositions.add(pos.immutable());
+        }
+
+        tasks.schedule();
+
+        return tasks.onComplete;
+    }
+
+    public CompletableFuture<Void> queueSectionChange(final SectionPos pos, final boolean newEmptyValue) {
+        final ChunkTasks tasks;
+        synchronized (this) {
+            tasks = this.chunkTasks.computeIfAbsent(CoordinateUtils.getChunkKey(pos), (final long keyInMap) -> {
+                return new ChunkTasks(keyInMap, LightQueue.this.manager, LightQueue.this);
+            });
+
+            if (tasks.changedSectionSet == null) {
+                tasks.changedSectionSet = new Boolean[this.manager.maxSection - this.manager.minSection + 1];
+            }
+            tasks.changedSectionSet[pos.getY() - this.manager.minSection] = Boolean.valueOf(newEmptyValue);
+        }
+
+        tasks.schedule();
+
+        return tasks.onComplete;
+    }
+
+    public CompletableFuture<Void> queueChunkLightTask(final ChunkPos pos, final BooleanSupplier lightTask, final PrioritisedExecutor.Priority priority) {
+        final ChunkTasks tasks;
+        synchronized (this) {
+            tasks = this.chunkTasks.computeIfAbsent(CoordinateUtils.getChunkKey(pos), (final long keyInMap) -> {
+                return new ChunkTasks(keyInMap, LightQueue.this.manager, LightQueue.this, priority);
+            });
+            if (tasks.lightTasks == null) {
+                tasks.lightTasks = new ArrayList<>();
+            }
+            tasks.lightTasks.add(lightTask);
+        }
+
+        tasks.schedule();
+
+        return tasks.onComplete;
+    }
+
+    public CompletableFuture<Void> queueChunkSkylightEdgeCheck(final SectionPos pos, final ShortCollection sections) {
+        final ChunkTasks tasks;
+        synchronized (this) {
+            tasks = this.chunkTasks.computeIfAbsent(CoordinateUtils.getChunkKey(pos), (final long keyInMap) -> {
+                return new ChunkTasks(keyInMap, LightQueue.this.manager, LightQueue.this);
+            });
+
+            ShortOpenHashSet queuedEdges = tasks.queuedEdgeChecksSky;
+            if (queuedEdges == null) {
+                queuedEdges = tasks.queuedEdgeChecksSky = new ShortOpenHashSet();
+            }
+            queuedEdges.addAll(sections);
+        }
+
+        tasks.schedule();
+
+        return tasks.onComplete;
+    }
+
+    public CompletableFuture<Void> queueChunkBlocklightEdgeCheck(final SectionPos pos, final ShortCollection sections) {
+        final ChunkTasks tasks;
+
+        synchronized (this) {
+            tasks = this.chunkTasks.computeIfAbsent(CoordinateUtils.getChunkKey(pos), (final long keyInMap) -> {
+                return new ChunkTasks(keyInMap, LightQueue.this.manager, LightQueue.this);
+            });
+
+            ShortOpenHashSet queuedEdges = tasks.queuedEdgeChecksBlock;
+            if (queuedEdges == null) {
+                queuedEdges = tasks.queuedEdgeChecksBlock = new ShortOpenHashSet();
+            }
+            queuedEdges.addAll(sections);
+        }
+
+        tasks.schedule();
+
+        return tasks.onComplete;
+    }
+
+    public void removeChunk(final ChunkPos pos) {
+        final ChunkTasks tasks;
+        synchronized (this) {
+            tasks = this.chunkTasks.remove(CoordinateUtils.getChunkKey(pos));
+        }
+        if (tasks != null && tasks.cancel()) {
+            tasks.onComplete.complete(null);
+        }
+    }
+
+    protected static final class ChunkTasks implements Runnable {
+
+        final Set<BlockPos> changedPositions = new HashSet<>();
+        Boolean[] changedSectionSet;
+        ShortOpenHashSet queuedEdgeChecksSky;
+        ShortOpenHashSet queuedEdgeChecksBlock;
+        List<BooleanSupplier> lightTasks;
+
+        final CompletableFuture<Void> onComplete = new CompletableFuture<>();
+
+        public final long chunkCoordinate;
+        private final StarLightInterface lightEngine;
+        private final LightQueue queue;
+        private final PrioritisedExecutor.PrioritisedTask task;
+
+        public ChunkTasks(final long chunkCoordinate, final StarLightInterface lightEngine, final LightQueue queue) {
+            this(chunkCoordinate, lightEngine, queue, PrioritisedExecutor.Priority.NORMAL);
+        }
+
+        public ChunkTasks(final long chunkCoordinate, final StarLightInterface lightEngine, final LightQueue queue,
+                          final PrioritisedExecutor.Priority priority) {
+            this.chunkCoordinate = chunkCoordinate;
+            this.lightEngine = lightEngine;
+            this.queue = queue;
+            this.task = queue.world.chunkTaskScheduler.lightExecutor.createTask(this, priority);
+        }
+
+        public void schedule() {
+            this.task.queue();
+        }
+
+        public boolean cancel() {
+            return this.task.cancel();
+        }
+
+        public PrioritisedExecutor.Priority getPriority() {
+            return this.task.getPriority();
+        }
+
+        public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+            this.task.lowerPriority(priority);
+        }
+
+        public void setPriority(final PrioritisedExecutor.Priority priority) {
+            this.task.setPriority(priority);
+        }
+
+        public void raisePriority(final PrioritisedExecutor.Priority priority) {
+            this.task.raisePriority(priority);
+        }
+
+        @Override
+        public void run() {
+            final SkyStarLightEngine skyEngine = this.lightEngine.getSkyLightEngine();
+            final BlockStarLightEngine blockEngine = this.lightEngine.getBlockLightEngine();
+            try {
+                synchronized (this.queue) {
+                    this.queue.chunkTasks.remove(this.chunkCoordinate);
+                }
+
+                boolean litChunk = false;
+                if (this.lightTasks != null) {
+                    for (final BooleanSupplier run : this.lightTasks) {
+                        if (run.getAsBoolean()) {
+                            litChunk = true;
+                            break;
+                        }
+                    }
+                }
+
+                final long coordinate = this.chunkCoordinate;
+                final int chunkX = CoordinateUtils.getChunkX(coordinate);
+                final int chunkZ = CoordinateUtils.getChunkZ(coordinate);
+
+                final Set<BlockPos> positions = this.changedPositions;
+                final Boolean[] sectionChanges = this.changedSectionSet;
+
+                if (!litChunk) {
+                    if (skyEngine != null && (!positions.isEmpty() || sectionChanges != null)) {
+                        skyEngine.blocksChangedInChunk(this.lightEngine.getLightAccess(), chunkX, chunkZ, positions, sectionChanges);
+                    }
+                    if (blockEngine != null && (!positions.isEmpty() || sectionChanges != null)) {
+                        blockEngine.blocksChangedInChunk(this.lightEngine.getLightAccess(), chunkX, chunkZ, positions, sectionChanges);
+                    }
+
+                    if (skyEngine != null && this.queuedEdgeChecksSky != null) {
+                        skyEngine.checkChunkEdges(this.lightEngine.getLightAccess(), chunkX, chunkZ, this.queuedEdgeChecksSky);
+                    }
+                    if (blockEngine != null && this.queuedEdgeChecksBlock != null) {
+                        blockEngine.checkChunkEdges(this.lightEngine.getLightAccess(), chunkX, chunkZ, this.queuedEdgeChecksBlock);
+                    }
+                }
+
+                this.onComplete.complete(null);
+            } finally {
+                this.lightEngine.releaseSkyLightEngine(skyEngine);
+                this.lightEngine.releaseBlockLightEngine(blockEngine);
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java b/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..b1bdd79044c00635c836dbed327526136ca4bd4e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
@@ -0,0 +1,211 @@
+package io.papermc.paper.chunk.system.poi;
+
+import com.mojang.logging.LogUtils;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import io.papermc.paper.util.WorldUtil;
+import net.minecraft.SharedConstants;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.Tag;
+import net.minecraft.resources.RegistryOps;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.ai.village.poi.PoiManager;
+import net.minecraft.world.entity.ai.village.poi.PoiSection;
+import org.slf4j.Logger;
+
+import java.util.Optional;
+
+public final class PoiChunk {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    public final ServerLevel world;
+    public final int chunkX;
+    public final int chunkZ;
+    public final int minSection;
+    public final int maxSection;
+
+    protected final PoiSection[] sections;
+
+    private boolean isDirty;
+    private boolean loaded;
+
+    public PoiChunk(final ServerLevel world, final int chunkX, final int chunkZ, final int minSection, final int maxSection) {
+        this(world, chunkX, chunkZ, minSection, maxSection, new PoiSection[maxSection - minSection + 1]);
+    }
+
+    public PoiChunk(final ServerLevel world, final int chunkX, final int chunkZ, final int minSection, final int maxSection, final PoiSection[] sections) {
+        this.world = world;
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+        this.minSection = minSection;
+        this.maxSection = maxSection;
+        this.sections = sections;
+        if (this.sections.length != (maxSection - minSection + 1)) {
+            throw new IllegalStateException("Incorrect length used, expected " + (maxSection - minSection + 1) + ", got " + this.sections.length);
+        }
+    }
+
+    public void load() {
+        TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Loading in poi chunk off-main");
+        if (this.loaded) {
+            return;
+        }
+        this.loaded = true;
+        this.world.chunkSource.getPoiManager().loadInPoiChunk(this);
+    }
+
+    public boolean isLoaded() {
+        return this.loaded;
+    }
+
+    public boolean isEmpty() {
+        for (final PoiSection section : this.sections) {
+            if (section != null && !section.isEmpty()) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public PoiSection getOrCreateSection(final int chunkY) {
+        if (chunkY >= this.minSection && chunkY <= this.maxSection) {
+            final int idx = chunkY - this.minSection;
+            final PoiSection ret = this.sections[idx];
+            if (ret != null) {
+                return ret;
+            }
+
+            final PoiManager poiManager = this.world.getPoiManager();
+            final long key = CoordinateUtils.getChunkSectionKey(this.chunkX, chunkY, this.chunkZ);
+
+            return this.sections[idx] = new PoiSection(() -> {
+                poiManager.setDirty(key);
+            });
+        }
+        throw new IllegalArgumentException("chunkY is out of bounds, chunkY: " + chunkY + " outside [" + this.minSection + "," + this.maxSection + "]");
+    }
+
+    public PoiSection getSection(final int chunkY) {
+        if (chunkY >= this.minSection && chunkY <= this.maxSection) {
+            return this.sections[chunkY - this.minSection];
+        }
+        return null;
+    }
+
+    public Optional<PoiSection> getSectionForVanilla(final int chunkY) {
+        if (chunkY >= this.minSection && chunkY <= this.maxSection) {
+            final PoiSection ret = this.sections[chunkY - this.minSection];
+            return ret == null ? Optional.empty() : ret.noAllocateOptional;
+        }
+        return Optional.empty();
+    }
+
+    public boolean isDirty() {
+        return this.isDirty;
+    }
+
+    public void setDirty(final boolean dirty) {
+        this.isDirty = dirty;
+    }
+
+    // returns null if empty
+    public CompoundTag save() {
+        final RegistryOps<Tag> registryOps = RegistryOps.create(NbtOps.INSTANCE, world.getPoiManager().registryAccess);
+
+        final CompoundTag ret = new CompoundTag();
+        final CompoundTag sections = new CompoundTag();
+        ret.put("Sections", sections);
+
+        ret.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
+
+        final ServerLevel world = this.world;
+        final PoiManager poiManager = world.getPoiManager();
+        final int chunkX = this.chunkX;
+        final int chunkZ = this.chunkZ;
+
+        for (int sectionY = this.minSection; sectionY <= this.maxSection; ++sectionY) {
+            final PoiSection chunk = this.sections[sectionY - this.minSection];
+            if (chunk == null || chunk.isEmpty()) {
+                continue;
+            }
+
+            final long key = CoordinateUtils.getChunkSectionKey(chunkX, sectionY, chunkZ);
+            // codecs are honestly such a fucking disaster. What the fuck is this trash?
+            final Codec<PoiSection> codec = PoiSection.codec(() -> {
+                poiManager.setDirty(key);
+            });
+
+            final DataResult<Tag> serializedResult = codec.encodeStart(registryOps, chunk);
+            final int finalSectionY = sectionY;
+            final Tag serialized = serializedResult.resultOrPartial((final String description) -> {
+                LOGGER.error("Failed to serialize poi chunk for world: " + world.getWorld().getName() + ", chunk: (" + chunkX + "," + finalSectionY + "," + chunkZ + "); description: " + description);
+            }).orElse(null);
+            if (serialized == null) {
+                // failed, should be logged from the resultOrPartial
+                continue;
+            }
+
+            sections.put(Integer.toString(sectionY), serialized);
+        }
+
+        return sections.isEmpty() ? null : ret;
+    }
+
+    public static PoiChunk empty(final ServerLevel world, final int chunkX, final int chunkZ) {
+        final PoiChunk ret = new PoiChunk(world, chunkX, chunkZ, WorldUtil.getMinSection(world), WorldUtil.getMaxSection(world));
+        ret.loaded = true;
+        return ret;
+    }
+
+    public static PoiChunk parse(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data) {
+        final PoiChunk ret = empty(world, chunkX, chunkZ);
+
+        final RegistryOps<Tag> registryOps = RegistryOps.create(NbtOps.INSTANCE, world.getPoiManager().registryAccess);
+
+        final CompoundTag sections = data.getCompound("Sections");
+
+        if (sections.isEmpty()) {
+            // nothing to parse
+            return ret;
+        }
+
+        final PoiManager poiManager = world.getPoiManager();
+
+        boolean readAnything = false;
+
+        for (int sectionY = ret.minSection; sectionY <= ret.maxSection; ++sectionY) {
+            final String key = Integer.toString(sectionY);
+            if (!sections.contains(key)) {
+                continue;
+            }
+
+            final long coordinateKey = CoordinateUtils.getChunkSectionKey(chunkX, sectionY, chunkZ);
+            // codecs are honestly such a fucking disaster. What the fuck is this trash?
+            final Codec<PoiSection> codec = PoiSection.codec(() -> {
+                poiManager.setDirty(coordinateKey);
+            });
+
+            final CompoundTag section = sections.getCompound(key);
+            final DataResult<PoiSection> deserializeResult = codec.parse(registryOps, section);
+            final int finalSectionY = sectionY;
+            final PoiSection deserialized = deserializeResult.resultOrPartial((final String description) -> {
+                LOGGER.error("Failed to deserialize poi chunk for world: " + world.getWorld().getName() + ", chunk: (" + chunkX + "," + finalSectionY + "," + chunkZ + "); description: " + description);
+            }).orElse(null);
+
+            if (deserialized == null || deserialized.isEmpty()) {
+                // completely empty, no point in storing this
+                continue;
+            }
+
+            readAnything = true;
+            ret.sections[sectionY - ret.minSection] = deserialized;
+        }
+
+        return ret;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkFullTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkFullTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..b02619d7111c52d1b4e3b50267e54da31d6161e3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkFullTask.java
@@ -0,0 +1,125 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.logging.LogUtils;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+
+public final class ChunkFullTask extends ChunkProgressionTask implements Runnable {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    protected final NewChunkHolder chunkHolder;
+    protected final ChunkAccess fromChunk;
+    protected final PrioritisedExecutor.PrioritisedTask convertToFullTask;
+
+    public ChunkFullTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX, final int chunkZ,
+                         final NewChunkHolder chunkHolder, final ChunkAccess fromChunk, final PrioritisedExecutor.Priority priority) {
+        super(scheduler, world, chunkX, chunkZ);
+        this.chunkHolder = chunkHolder;
+        this.fromChunk = fromChunk;
+        this.convertToFullTask = scheduler.createChunkTask(chunkX, chunkZ, this, priority);
+    }
+
+    @Override
+    public ChunkStatus getTargetStatus() {
+        return ChunkStatus.FULL;
+    }
+
+    @Override
+    public void run() {
+        // See Vanilla protoChunkToFullChunk for what this function should be doing
+        final LevelChunk chunk;
+        try {
+            if (this.fromChunk instanceof ImposterProtoChunk wrappedFull) {
+                chunk = wrappedFull.getWrapped();
+            } else {
+                final ServerLevel world = this.world;
+                final ProtoChunk protoChunk = (ProtoChunk)this.fromChunk;
+                chunk = new LevelChunk(this.world, protoChunk, (final LevelChunk unused) -> {
+                    ChunkMap.postLoadProtoChunk(world, protoChunk.getEntities());
+                });
+            }
+
+            chunk.setChunkHolder(this.scheduler.chunkHolderManager.getChunkHolder(this.chunkX, this.chunkZ)); // replaces setFullStatus
+            chunk.runPostLoad();
+            // Unlike Vanilla, we load the entity chunk here, as we load the NBT in empty status (unlike Vanilla)
+            // This brings entity addition back in line with older versions of the game
+            // Since we load the NBT in the empty status, this will never block for I/O
+            this.world.chunkTaskScheduler.chunkHolderManager.getOrCreateEntityChunk(this.chunkX, this.chunkZ, false);
+
+            // we don't need the entitiesInLevel trash, this system doesn't double run callbacks
+            chunk.setLoaded(true);
+            chunk.registerAllBlockEntitiesAfterLevelLoad();
+            chunk.registerTickContainerInLevel(this.world);
+        } catch (final Throwable throwable) {
+            this.complete(null, throwable);
+
+            if (throwable instanceof ThreadDeath) {
+                throw (ThreadDeath)throwable;
+            }
+            return;
+        }
+        this.complete(chunk, null);
+    }
+
+    protected volatile boolean scheduled;
+    protected static final VarHandle SCHEDULED_HANDLE = ConcurrentUtil.getVarHandle(ChunkFullTask.class, "scheduled", boolean.class);
+
+    @Override
+    public boolean isScheduled() {
+        return this.scheduled;
+    }
+
+    @Override
+    public void schedule() {
+        if ((boolean)SCHEDULED_HANDLE.getAndSet((ChunkFullTask)this, true)) {
+            throw new IllegalStateException("Cannot double call schedule()");
+        }
+        this.convertToFullTask.queue();
+    }
+
+    @Override
+    public void cancel() {
+        if (this.convertToFullTask.cancel()) {
+            this.complete(null, null);
+        }
+    }
+
+    @Override
+    public PrioritisedExecutor.Priority getPriority() {
+        return this.convertToFullTask.getPriority();
+    }
+
+    @Override
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.convertToFullTask.lowerPriority(priority);
+    }
+
+    @Override
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.convertToFullTask.setPriority(priority);
+    }
+
+    @Override
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.convertToFullTask.raisePriority(priority);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..06b700de0bd53c4c02a13be76c0ddca58d1532c2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -0,0 +1,1189 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.map.SWMRLong2ObjectHashTable;
+import com.google.common.collect.ImmutableList;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.io.RegionFileIOThread;
+import io.papermc.paper.chunk.system.poi.PoiChunk;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import io.papermc.paper.util.misc.Delayed8WayDistancePropagator2D;
+import io.papermc.paper.world.ChunkEntitySlices;
+import it.unimi.dsi.fastutil.longs.Long2IntLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet;
+import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.ChunkSystem;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.Ticket;
+import net.minecraft.server.level.TicketType;
+import net.minecraft.util.SortedArraySet;
+import net.minecraft.util.Unit;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import org.bukkit.plugin.Plugin;
+import org.slf4j.Logger;
+import java.io.IOException;
+import java.text.DecimalFormat;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.locks.LockSupport;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Predicate;
+
+public final class ChunkHolderManager {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    public static final int FULL_LOADED_TICKET_LEVEL    = 33;
+    public static final int BLOCK_TICKING_TICKET_LEVEL  = 32;
+    public static final int ENTITY_TICKING_TICKET_LEVEL = 31;
+    public static final int MAX_TICKET_LEVEL = ChunkMap.MAX_CHUNK_DISTANCE; // inclusive
+
+    private static final long NO_TIMEOUT_MARKER = -1L;
+
+    final ReentrantLock ticketLock = new ReentrantLock();
+
+    private final SWMRLong2ObjectHashTable<NewChunkHolder> chunkHolders = new SWMRLong2ObjectHashTable<>(16384, 0.25f);
+    private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap<>(8192, 0.25f);
+    // what a disaster of a name
+    // this is a map of removal tick to a map of chunks and the number of tickets a chunk has that are to expire that tick
+    private final Long2ObjectOpenHashMap<Long2IntOpenHashMap> removeTickToChunkExpireTicketCount = new Long2ObjectOpenHashMap<>();
+    private final ServerLevel world;
+    private final ChunkTaskScheduler taskScheduler;
+    private long currentTick;
+
+    private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
+    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
+        if (c1 == c2) {
+            return 0;
+        }
+
+        final int saveTickCompare = Long.compare(c1.lastAutoSave, c2.lastAutoSave);
+
+        if (saveTickCompare != 0) {
+            return saveTickCompare;
+        }
+
+        final long coord1 = CoordinateUtils.getChunkKey(c1.chunkX, c1.chunkZ);
+        final long coord2 = CoordinateUtils.getChunkKey(c2.chunkX, c2.chunkZ);
+
+        if (coord1 == coord2) {
+            throw new IllegalStateException("Duplicate chunkholder in auto save queue");
+        }
+
+        return Long.compare(coord1, coord2);
+    });
+
+    public ChunkHolderManager(final ServerLevel world, final ChunkTaskScheduler taskScheduler) {
+        this.world = world;
+        this.taskScheduler = taskScheduler;
+    }
+
+    private long statusUpgradeId;
+
+    long getNextStatusUpgradeId() {
+        return ++this.statusUpgradeId;
+    }
+
+    public List<ChunkHolder> getOldChunkHolders() {
+        final List<NewChunkHolder> holders = this.getChunkHolders();
+        final List<ChunkHolder> ret = new ArrayList<>(holders.size());
+        for (final NewChunkHolder holder : holders) {
+            ret.add(holder.vanillaChunkHolder);
+        }
+        return ret;
+    }
+
+    public List<NewChunkHolder> getChunkHolders() {
+        final List<NewChunkHolder> ret = new ArrayList<>(this.chunkHolders.size());
+        this.chunkHolders.forEachValue(ret::add);
+        return ret;
+    }
+
+    public int size() {
+        return this.chunkHolders.size();
+    }
+
+    public void close(final boolean save, final boolean halt) {
+        TickThread.ensureTickThread("Closing world off-main");
+        if (halt) {
+            LOGGER.info("Waiting 60s for chunk system to halt for world '" + this.world.getWorld().getName() + "'");
+            if (!this.taskScheduler.halt(true, TimeUnit.SECONDS.toNanos(60L))) {
+                LOGGER.warn("Failed to halt world generation/loading tasks for world '" + this.world.getWorld().getName() + "'");
+            } else {
+                LOGGER.info("Halted chunk system for world '" + this.world.getWorld().getName() + "'");
+            }
+        }
+
+        if (save) {
+            this.saveAllChunks(true, true, true);
+        }
+
+        if (this.world.chunkDataControllerNew.hasTasks() || this.world.entityDataControllerNew.hasTasks() || this.world.poiDataControllerNew.hasTasks()) {
+            RegionFileIOThread.flush();
+        }
+
+        // kill regionfile cache
+        try {
+            this.world.chunkDataControllerNew.getCache().close();
+        } catch (final IOException ex) {
+            LOGGER.error("Failed to close chunk regionfile cache for world '" + this.world.getWorld().getName() + "'", ex);
+        }
+        try {
+            this.world.entityDataControllerNew.getCache().close();
+        } catch (final IOException ex) {
+            LOGGER.error("Failed to close entity regionfile cache for world '" + this.world.getWorld().getName() + "'", ex);
+        }
+        try {
+            this.world.poiDataControllerNew.getCache().close();
+        } catch (final IOException ex) {
+            LOGGER.error("Failed to close poi regionfile cache for world '" + this.world.getWorld().getName() + "'", ex);
+        }
+    }
+
+    void ensureInAutosave(final NewChunkHolder holder) {
+        if (!this.autoSaveQueue.contains(holder)) {
+            holder.lastAutoSave = MinecraftServer.currentTick;
+            this.autoSaveQueue.add(holder);
+        }
+    }
+
+    public void autoSave() {
+        final List<NewChunkHolder> reschedule = new ArrayList<>();
+        final long currentTick = MinecraftServer.currentTickLong;
+        final long maxSaveTime = currentTick - this.world.paperConfig().chunks.autoSaveInterval.value();
+        for (int autoSaved = 0; autoSaved < this.world.paperConfig().chunks.maxAutoSaveChunksPerTick && !this.autoSaveQueue.isEmpty();) {
+            final NewChunkHolder holder = this.autoSaveQueue.first();
+
+            if (holder.lastAutoSave > maxSaveTime) {
+                break;
+            }
+
+            this.autoSaveQueue.remove(holder);
+
+            holder.lastAutoSave = currentTick;
+            if (holder.save(false, false)) {
+                ++autoSaved;
+            }
+
+            if (holder.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                reschedule.add(holder);
+            }
+        }
+
+        for (final NewChunkHolder holder : reschedule) {
+            if (holder.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                this.autoSaveQueue.add(holder);
+            }
+        }
+    }
+
+    public void saveAllChunks(final boolean flush, final boolean shutdown, final boolean logProgress) {
+        final List<NewChunkHolder> holders = this.getChunkHolders();
+
+        if (logProgress) {
+            LOGGER.info("Saving all chunkholders for world '" + this.world.getWorld().getName() + "'");
+        }
+
+        final DecimalFormat format = new DecimalFormat("#0.00");
+
+        int saved = 0;
+
+        long start = System.nanoTime();
+        long lastLog = start;
+        boolean needsFlush = false;
+        final int flushInterval = 50;
+
+        for (int i = 0, len = holders.size(); i < len; ++i) {
+            final NewChunkHolder holder = holders.get(i);
+            try {
+                if (holder.save(shutdown, false)) {
+                    ++saved;
+                    needsFlush = flush;
+                }
+            } catch (final ThreadDeath thr) {
+                throw thr;
+            } catch (final Throwable thr) {
+                LOGGER.error("Failed to save chunk (" + holder.chunkX + "," + holder.chunkZ + ") in world '" + this.world.getWorld().getName() + "'", thr);
+            }
+            if (needsFlush && (saved % flushInterval) == 0) {
+                needsFlush = false;
+                RegionFileIOThread.partialFlush(flushInterval / 2);
+            }
+            if (logProgress) {
+                final long currTime = System.nanoTime();
+                if ((currTime - lastLog) > TimeUnit.SECONDS.toNanos(10L)) {
+                    lastLog = currTime;
+                    LOGGER.info("Saved " + saved + " chunks (" + format.format((double)(i+1)/(double)len * 100.0) + "%) in world '" + this.world.getWorld().getName() + "'");
+                }
+            }
+        }
+        if (flush) {
+            RegionFileIOThread.flush();
+        }
+        if (logProgress) {
+            LOGGER.info("Saved " + saved + " chunks in world '" + this.world.getWorld().getName() + "' in " + TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - start) + "s");
+        }
+    }
+
+    protected final Long2IntLinkedOpenHashMap ticketLevelUpdates = new Long2IntLinkedOpenHashMap() {
+        @Override
+        protected void rehash(final int newN) {
+            // no downsizing allowed
+            if (newN < this.n) {
+                return;
+            }
+            super.rehash(newN);
+        }
+    };
+
+    protected final Delayed8WayDistancePropagator2D ticketLevelPropagator = new Delayed8WayDistancePropagator2D(
+            (final long coordinate, final byte oldLevel, final byte newLevel) -> {
+                ChunkHolderManager.this.ticketLevelUpdates.putAndMoveToLast(coordinate, convertBetweenTicketLevels(newLevel));
+            }
+    );
+    // function for converting between ticket levels and propagator levels and vice versa
+    // the problem is the ticket level propagator will propagate from a set source down to zero, whereas mojang expects
+    // levels to propagate from a set value up to a maximum value. so we need to convert the levels we put into the propagator
+    // and the levels we get out of the propagator
+
+    public static int convertBetweenTicketLevels(final int level) {
+        return ChunkMap.MAX_CHUNK_DISTANCE - level + 1;
+    }
+
+    public boolean hasTickets() {
+        this.ticketLock.lock();
+        try {
+            return !this.tickets.isEmpty();
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public String getTicketDebugString(final long coordinate) {
+        this.ticketLock.lock();
+        try {
+            final SortedArraySet<Ticket<?>> tickets = this.tickets.get(coordinate);
+
+            return tickets != null ? tickets.first().toString() : "no_ticket";
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> getTicketsCopy() {
+        this.ticketLock.lock();
+        try {
+            return this.tickets.clone();
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public Collection<Plugin> getPluginChunkTickets(int x, int z) {
+        ImmutableList.Builder<Plugin> ret;
+        this.ticketLock.lock();
+        try {
+            SortedArraySet<Ticket<?>> tickets = this.tickets.get(ChunkPos.asLong(x, z));
+
+            if (tickets == null) {
+                return Collections.emptyList();
+            }
+
+            ret = ImmutableList.builder();
+            for (Ticket<?> ticket : tickets) {
+                if (ticket.getType() == TicketType.PLUGIN_TICKET) {
+                    ret.add((Plugin)ticket.key);
+                }
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        return ret.build();
+    }
+
+    protected final int getPropagatedTicketLevel(final long coordinate) {
+        return convertBetweenTicketLevels(this.ticketLevelPropagator.getLevel(coordinate));
+    }
+
+    protected final void updateTicketLevel(final long coordinate, final int ticketLevel) {
+        if (ticketLevel > ChunkMap.MAX_CHUNK_DISTANCE) {
+            this.ticketLevelPropagator.removeSource(coordinate);
+        } else {
+            this.ticketLevelPropagator.setSource(coordinate, convertBetweenTicketLevels(ticketLevel));
+        }
+    }
+
+    private static int getTicketLevelAt(SortedArraySet<Ticket<?>> tickets) {
+        return !tickets.isEmpty() ? tickets.first().getTicketLevel() : MAX_TICKET_LEVEL + 1;
+    }
+
+    public <T> boolean addTicketAtLevel(final TicketType<T> type, final ChunkPos chunkPos, final int level,
+                                        final T identifier) {
+        return this.addTicketAtLevel(type, CoordinateUtils.getChunkKey(chunkPos), level, identifier);
+    }
+
+    public <T> boolean addTicketAtLevel(final TicketType<T> type, final int chunkX, final int chunkZ, final int level,
+                                        final T identifier) {
+        return this.addTicketAtLevel(type, CoordinateUtils.getChunkKey(chunkX, chunkZ), level, identifier);
+    }
+
+    // supposed to return true if the ticket was added and did not replace another
+    // but, we always return false if the ticket cannot be added
+    public <T> boolean addTicketAtLevel(final TicketType<T> type, final long chunk, final int level, final T identifier) {
+        final long removeDelay = Math.max(0, type.timeout);
+        if (level > MAX_TICKET_LEVEL) {
+            return false;
+        }
+
+        this.ticketLock.lock();
+        try {
+            final long removeTick = removeDelay == 0 ? NO_TIMEOUT_MARKER : this.currentTick + removeDelay;
+            final Ticket<T> ticket = new Ticket<>(type, level, identifier, removeTick);
+
+            final SortedArraySet<Ticket<?>> ticketsAtChunk = this.tickets.computeIfAbsent(chunk, (final long keyInMap) -> {
+                return SortedArraySet.create(4);
+            });
+
+            final int levelBefore = getTicketLevelAt(ticketsAtChunk);
+            final Ticket<T> current = (Ticket<T>)ticketsAtChunk.replace(ticket);
+            final int levelAfter = getTicketLevelAt(ticketsAtChunk);
+
+            if (current != ticket) {
+                final long oldRemovalTick = current.removalTick;
+                if (removeTick != oldRemovalTick) {
+                    if (oldRemovalTick != NO_TIMEOUT_MARKER) {
+                        final Long2IntOpenHashMap removeCounts = this.removeTickToChunkExpireTicketCount.get(oldRemovalTick);
+                        final int prevCount = removeCounts.addTo(chunk, -1);
+
+                        if (prevCount == 1) {
+                            removeCounts.remove(chunk);
+                            if (removeCounts.isEmpty()) {
+                                this.removeTickToChunkExpireTicketCount.remove(oldRemovalTick);
+                            }
+                        }
+                    }
+                    if (removeTick != NO_TIMEOUT_MARKER) {
+                        this.removeTickToChunkExpireTicketCount.computeIfAbsent(removeTick, (final long keyInMap) -> {
+                            return new Long2IntOpenHashMap();
+                        }).addTo(chunk, 1);
+                    }
+                }
+            } else {
+                if (removeTick != NO_TIMEOUT_MARKER) {
+                    this.removeTickToChunkExpireTicketCount.computeIfAbsent(removeTick, (final long keyInMap) -> {
+                        return new Long2IntOpenHashMap();
+                    }).addTo(chunk, 1);
+                }
+            }
+
+            if (levelBefore != levelAfter) {
+                this.updateTicketLevel(chunk, levelAfter);
+            }
+
+            return current == ticket;
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public <T> boolean removeTicketAtLevel(final TicketType<T> type, final ChunkPos chunkPos, final int level, final T identifier) {
+        return this.removeTicketAtLevel(type, CoordinateUtils.getChunkKey(chunkPos), level, identifier);
+    }
+
+    public <T> boolean removeTicketAtLevel(final TicketType<T> type, final int chunkX, final int chunkZ, final int level, final T identifier) {
+        return this.removeTicketAtLevel(type, CoordinateUtils.getChunkKey(chunkX, chunkZ), level, identifier);
+    }
+
+    public <T> boolean removeTicketAtLevel(final TicketType<T> type, final long chunk, final int level, final T identifier) {
+        if (level > MAX_TICKET_LEVEL) {
+            return false;
+        }
+
+        this.ticketLock.lock();
+        try {
+            final SortedArraySet<Ticket<?>> ticketsAtChunk = this.tickets.get(chunk);
+            if (ticketsAtChunk == null) {
+                return false;
+            }
+
+            final int oldLevel = getTicketLevelAt(ticketsAtChunk);
+            final Ticket<T> ticket = (Ticket<T>)ticketsAtChunk.removeAndGet(new Ticket<>(type, level, identifier, -2L));
+
+            if (ticket == null) {
+                return false;
+            }
+
+            if (ticketsAtChunk.isEmpty()) {
+                this.tickets.remove(chunk);
+            }
+
+            final int newLevel = getTicketLevelAt(ticketsAtChunk);
+
+            final long removeTick = ticket.removalTick;
+            if (removeTick != NO_TIMEOUT_MARKER) {
+                final Long2IntOpenHashMap removeCounts = this.removeTickToChunkExpireTicketCount.get(removeTick);
+                final int currCount = removeCounts.addTo(chunk, -1);
+
+                if (currCount == 1) {
+                    removeCounts.remove(chunk);
+                    if (removeCounts.isEmpty()) {
+                        this.removeTickToChunkExpireTicketCount.remove(removeTick);
+                    }
+                }
+            }
+
+            if (oldLevel != newLevel) {
+                this.updateTicketLevel(chunk, newLevel);
+            }
+
+            return true;
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    // atomic with respect to all add/remove/addandremove ticket calls for the given chunk
+    public <T, V> void addAndRemoveTickets(final long chunk, final TicketType<T> addType, final int addLevel, final T addIdentifier,
+                                           final TicketType<V> removeType, final int removeLevel, final V removeIdentifier) {
+        this.ticketLock.lock();
+        try {
+            this.addTicketAtLevel(addType, chunk, addLevel, addIdentifier);
+            this.removeTicketAtLevel(removeType, chunk, removeLevel, removeIdentifier);
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public <T> void removeAllTicketsFor(final TicketType<T> ticketType, final int ticketLevel, final T ticketIdentifier) {
+        if (ticketLevel > MAX_TICKET_LEVEL) {
+            return;
+        }
+
+        this.ticketLock.lock();
+        try {
+            for (final LongIterator iterator = new LongArrayList(this.tickets.keySet()).longIterator(); iterator.hasNext();) {
+                final long chunk = iterator.nextLong();
+
+                this.removeTicketAtLevel(ticketType, chunk, ticketLevel, ticketIdentifier);
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public void tick() {
+        TickThread.ensureTickThread("Cannot tick ticket manager off-main");
+
+        this.ticketLock.lock();
+        try {
+            final long tick = ++this.currentTick;
+
+            final Long2IntOpenHashMap toRemove = this.removeTickToChunkExpireTicketCount.remove(tick);
+
+            if (toRemove == null) {
+                return;
+            }
+
+            final Predicate<Ticket<?>> expireNow = (final Ticket<?> ticket) -> {
+                return ticket.removalTick == tick;
+            };
+
+            for (final LongIterator iterator = toRemove.keySet().longIterator(); iterator.hasNext();) {
+                final long chunk = iterator.nextLong();
+
+                final SortedArraySet<Ticket<?>> tickets = this.tickets.get(chunk);
+                tickets.removeIf(expireNow);
+                if (tickets.isEmpty()) {
+                    this.tickets.remove(chunk);
+                    this.ticketLevelPropagator.removeSource(chunk);
+                } else {
+                    this.ticketLevelPropagator.setSource(chunk, convertBetweenTicketLevels(tickets.first().getTicketLevel()));
+                }
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        this.processTicketUpdates();
+    }
+
+    public NewChunkHolder getChunkHolder(final int chunkX, final int chunkZ) {
+        return this.chunkHolders.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+    }
+
+    public NewChunkHolder getChunkHolder(final long position) {
+        return this.chunkHolders.get(position);
+    }
+
+    public void raisePriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        final NewChunkHolder chunkHolder = this.getChunkHolder(x, z);
+        if (chunkHolder != null) {
+            chunkHolder.raisePriority(priority);
+        }
+    }
+
+    public void setPriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        final NewChunkHolder chunkHolder = this.getChunkHolder(x, z);
+        if (chunkHolder != null) {
+            chunkHolder.setPriority(priority);
+        }
+    }
+
+    public void lowerPriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        final NewChunkHolder chunkHolder = this.getChunkHolder(x, z);
+        if (chunkHolder != null) {
+            chunkHolder.lowerPriority(priority);
+        }
+    }
+
+    private NewChunkHolder createChunkHolder(final long position) {
+        final NewChunkHolder ret = new NewChunkHolder(this.world, CoordinateUtils.getChunkX(position), CoordinateUtils.getChunkZ(position), this.taskScheduler);
+
+        ChunkSystem.onChunkHolderCreate(this.world, ret.vanillaChunkHolder);
+        ret.vanillaChunkHolder.onChunkAdd();
+
+        return ret;
+    }
+
+    // because this function creates the chunk holder without a ticket, it is the caller's responsibility to ensure
+    // the chunk holder eventually unloads. this should only be used to avoid using processTicketUpdates to create chunkholders,
+    // as processTicketUpdates may call plugin logic; in every other case a ticket is appropriate
+    private NewChunkHolder getOrCreateChunkHolder(final int chunkX, final int chunkZ) {
+        return this.getOrCreateChunkHolder(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+    }
+
+    private NewChunkHolder getOrCreateChunkHolder(final long position) {
+        if (!this.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Must hold ticket level update lock!");
+        }
+        if (!this.taskScheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Must hold scheduler lock!!");
+        }
+
+        // we could just acquire these locks, but...
+        // must own the locks because the caller needs to ensure that no unload can occur AFTER this function returns
+
+        NewChunkHolder current = this.chunkHolders.get(position);
+        if (current != null) {
+            return current;
+        }
+
+        current = this.createChunkHolder(position);
+        this.chunkHolders.put(position, current);
+
+        return current;
+    }
+
+    private long entityLoadCounter;
+
+    public ChunkEntitySlices getOrCreateEntityChunk(final int chunkX, final int chunkZ, final boolean transientChunk) {
+        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot create entity chunk off-main");
+        ChunkEntitySlices ret;
+
+        NewChunkHolder current = this.getChunkHolder(chunkX, chunkZ);
+        if (current != null && (ret = current.getEntityChunk()) != null && (transientChunk || !ret.isTransient())) {
+            return ret;
+        }
+
+        final AtomicBoolean isCompleted = new AtomicBoolean();
+        final Thread waiter = Thread.currentThread();
+        final Long entityLoadId;
+        NewChunkHolder.GenericDataLoadTaskCallback loadTask = null;
+        this.ticketLock.lock();
+        try {
+            entityLoadId = Long.valueOf(this.entityLoadCounter++);
+            this.addTicketAtLevel(TicketType.ENTITY_LOAD, chunkX, chunkZ, MAX_TICKET_LEVEL, entityLoadId);
+            this.taskScheduler.schedulingLock.lock();
+            try {
+                current = this.getOrCreateChunkHolder(chunkX, chunkZ);
+                if ((ret = current.getEntityChunk()) != null && (transientChunk || !ret.isTransient())) {
+                    this.removeTicketAtLevel(TicketType.ENTITY_LOAD, chunkX, chunkZ, MAX_TICKET_LEVEL, entityLoadId);
+                    return ret;
+                }
+
+                if (current.isEntityChunkNBTLoaded()) {
+                    isCompleted.setPlain(true);
+                } else {
+                    loadTask = current.getOrLoadEntityData((final GenericDataLoadTask.TaskResult<CompoundTag, Throwable> result) -> {
+                        if (!transientChunk) {
+                            isCompleted.set(true);
+                            LockSupport.unpark(waiter);
+                        }
+                    });
+                    final ChunkLoadTask.EntityDataLoadTask entityLoad = current.getEntityDataLoadTask();
+
+                    if (entityLoad != null && !transientChunk) {
+                        entityLoad.raisePriority(PrioritisedExecutor.Priority.BLOCKING);
+                    }
+                }
+            } finally {
+                this.taskScheduler.schedulingLock.unlock();
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        if (loadTask != null) {
+            loadTask.schedule();
+        }
+
+        if (!transientChunk) {
+            // Note: no need to busy wait on the chunk queue, entity load will complete off-main
+            boolean interrupted = false;
+            while (!isCompleted.get()) {
+                interrupted |= Thread.interrupted();
+                LockSupport.park();
+            }
+
+            if (interrupted) {
+                Thread.currentThread().interrupt();
+            }
+        }
+
+        // now that the entity data is loaded, we can load it into the world
+
+        ret = current.loadInEntityChunk(transientChunk);
+
+        final long chunkKey = CoordinateUtils.getChunkKey(chunkX, chunkZ);
+        this.addAndRemoveTickets(chunkKey,
+            TicketType.UNKNOWN, MAX_TICKET_LEVEL, new ChunkPos(chunkX, chunkZ),
+            TicketType.ENTITY_LOAD, MAX_TICKET_LEVEL, entityLoadId
+        );
+
+        return ret;
+    }
+
+    public PoiChunk getPoiChunkIfLoaded(final int chunkX, final int chunkZ, final boolean checkLoadInCallback) {
+        final NewChunkHolder holder = this.getChunkHolder(chunkX, chunkZ);
+        if (holder != null) {
+            final PoiChunk ret = holder.getPoiChunk();
+            return ret == null || (checkLoadInCallback && !ret.isLoaded()) ? null : ret;
+        }
+        return null;
+    }
+
+    private long poiLoadCounter;
+
+    public PoiChunk loadPoiChunk(final int chunkX, final int chunkZ) {
+        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot create poi chunk off-main");
+        PoiChunk ret;
+
+        NewChunkHolder current = this.getChunkHolder(chunkX, chunkZ);
+        if (current != null && (ret = current.getPoiChunk()) != null) {
+            if (!ret.isLoaded()) {
+                ret.load();
+            }
+            return ret;
+        }
+
+        final AtomicReference<PoiChunk> completed = new AtomicReference<>();
+        final AtomicBoolean isCompleted = new AtomicBoolean();
+        final Thread waiter = Thread.currentThread();
+        final Long poiLoadId;
+        NewChunkHolder.GenericDataLoadTaskCallback loadTask = null;
+        this.ticketLock.lock();
+        try {
+            poiLoadId = Long.valueOf(this.poiLoadCounter++);
+            this.addTicketAtLevel(TicketType.POI_LOAD, chunkX, chunkZ, MAX_TICKET_LEVEL, poiLoadId);
+            this.taskScheduler.schedulingLock.lock();
+            try {
+                current = this.getOrCreateChunkHolder(chunkX, chunkZ);
+                if (current.isPoiChunkLoaded()) {
+                    this.removeTicketAtLevel(TicketType.POI_LOAD, chunkX, chunkZ, MAX_TICKET_LEVEL, poiLoadId);
+                    return current.getPoiChunk();
+                }
+
+                loadTask = current.getOrLoadPoiData((final GenericDataLoadTask.TaskResult<PoiChunk, Throwable> result) -> {
+                    completed.setPlain(result.left());
+                    isCompleted.set(true);
+                    LockSupport.unpark(waiter);
+                });
+                final ChunkLoadTask.PoiDataLoadTask poiLoad = current.getPoiDataLoadTask();
+
+                if (poiLoad != null) {
+                    poiLoad.raisePriority(PrioritisedExecutor.Priority.BLOCKING);
+                }
+            } finally {
+                this.taskScheduler.schedulingLock.unlock();
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        if (loadTask != null) {
+            loadTask.schedule();
+        }
+
+        // Note: no need to busy wait on the chunk queue, poi load will complete off-main
+
+        boolean interrupted = false;
+        while (!isCompleted.get()) {
+            interrupted |= Thread.interrupted();
+            LockSupport.park();
+        }
+
+        if (interrupted) {
+            Thread.currentThread().interrupt();
+        }
+
+        ret = completed.getPlain();
+
+        ret.load();
+
+        final long chunkKey = CoordinateUtils.getChunkKey(chunkX, chunkZ);
+        this.addAndRemoveTickets(chunkKey,
+            TicketType.UNKNOWN, MAX_TICKET_LEVEL, new ChunkPos(chunkX, chunkZ),
+            TicketType.POI_LOAD, MAX_TICKET_LEVEL, poiLoadId
+        );
+
+        return ret;
+    }
+
+    void addChangedStatuses(final List<NewChunkHolder> changedFullStatus) {
+        if (changedFullStatus.isEmpty()) {
+            return;
+        }
+        if (!TickThread.isTickThread()) {
+            this.taskScheduler.scheduleChunkTask(() -> {
+                final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
+                for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
+                    pendingFullLoadUpdate.add(changedFullStatus.get(i));
+                }
+
+                ChunkHolderManager.this.processPendingFullUpdate();
+            }, PrioritisedExecutor.Priority.HIGHEST);
+        } else {
+            final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+            for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
+                pendingFullLoadUpdate.add(changedFullStatus.get(i));
+            }
+        }
+    }
+
+    final ReferenceLinkedOpenHashSet<NewChunkHolder> unloadQueue = new ReferenceLinkedOpenHashSet<>();
+
+    private void removeChunkHolder(final NewChunkHolder holder) {
+        holder.killed = true;
+        holder.vanillaChunkHolder.onChunkRemove();
+        this.autoSaveQueue.remove(holder);
+        ChunkSystem.onChunkHolderDelete(this.world, holder.vanillaChunkHolder);
+        this.chunkHolders.remove(CoordinateUtils.getChunkKey(holder.chunkX, holder.chunkZ));
+    }
+
+    // note: never call while inside the chunk system, this will absolutely break everything
+    public void processUnloads() {
+        TickThread.ensureTickThread("Cannot unload chunks off-main");
+
+        if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
+            throw new IllegalStateException("Cannot unload chunks recursively");
+        }
+        if (this.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot hold ticket update lock while calling processUnloads");
+        }
+        if (this.taskScheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot hold scheduling lock while calling processUnloads");
+        }
+
+        final List<NewChunkHolder.UnloadState> unloadQueue;
+        final List<ChunkProgressionTask> scheduleList = new ArrayList<>();
+        this.ticketLock.lock();
+        try {
+            this.taskScheduler.schedulingLock.lock();
+            try {
+                if (this.unloadQueue.isEmpty()) {
+                    return;
+                }
+                // in order to ensure all chunks in the unload queue do not have a pending ticket level update,
+                // process them now
+                this.processTicketUpdates(false, false, scheduleList);
+                unloadQueue = new ArrayList<>((int)(this.unloadQueue.size() * 0.05) + 1);
+
+                final int unloadCount = Math.max(50, (int)(this.unloadQueue.size() * 0.05));
+                for (int i = 0; i < unloadCount && !this.unloadQueue.isEmpty(); ++i) {
+                    final NewChunkHolder chunkHolder = this.unloadQueue.removeFirst();
+                    if (chunkHolder.isSafeToUnload() != null) {
+                        LOGGER.error("Chunkholder " + chunkHolder + " is not safe to unload but is inside the unload queue?");
+                        continue;
+                    }
+                    final NewChunkHolder.UnloadState state = chunkHolder.unloadStage1();
+                    if (state == null) {
+                        // can unload immediately
+                        this.removeChunkHolder(chunkHolder);
+                        continue;
+                    }
+                    unloadQueue.add(state);
+                }
+            } finally {
+                this.taskScheduler.schedulingLock.unlock();
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+        // schedule tasks, we can't let processTicketUpdates do this because we call it holding the schedule lock
+        for (int i = 0, len = scheduleList.size(); i < len; ++i) {
+            scheduleList.get(i).schedule();
+        }
+
+        final List<NewChunkHolder> toRemove = new ArrayList<>(unloadQueue.size());
+
+        final Boolean before = this.blockTicketUpdates();
+        try {
+            for (int i = 0, len = unloadQueue.size(); i < len; ++i) {
+                final NewChunkHolder.UnloadState state = unloadQueue.get(i);
+                final NewChunkHolder holder = state.holder();
+
+                holder.unloadStage2(state);
+                toRemove.add(holder);
+            }
+        } finally {
+            this.unblockTicketUpdates(before);
+        }
+
+        this.ticketLock.lock();
+        try {
+            this.taskScheduler.schedulingLock.lock();
+            try {
+                for (int i = 0, len = toRemove.size(); i < len; ++i) {
+                    final NewChunkHolder holder = toRemove.get(i);
+
+                    if (holder.unloadStage3()) {
+                        this.removeChunkHolder(holder);
+                    } else {
+                        // add cooldown so the next unload check is not immediately next tick
+                        this.addTicketAtLevel(TicketType.UNLOAD_COOLDOWN, holder.chunkX, holder.chunkZ, MAX_TICKET_LEVEL, Unit.INSTANCE);
+                    }
+                }
+            } finally {
+                this.taskScheduler.schedulingLock.unlock();
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    private final ThreadLocal<Boolean> BLOCK_TICKET_UPDATES = ThreadLocal.withInitial(() -> {
+        return Boolean.FALSE;
+    });
+
+    public Boolean blockTicketUpdates() {
+        final Boolean ret = BLOCK_TICKET_UPDATES.get();
+        BLOCK_TICKET_UPDATES.set(Boolean.TRUE);
+        return ret;
+    }
+
+    public void unblockTicketUpdates(final Boolean before) {
+        BLOCK_TICKET_UPDATES.set(before);
+    }
+
+    public boolean processTicketUpdates() {
+        return this.processTicketUpdates(true, true, null);
+    }
+
+    private static final ThreadLocal<List<ChunkProgressionTask>> CURRENT_TICKET_UPDATE_SCHEDULING = new ThreadLocal<>();
+
+    static List<ChunkProgressionTask> getCurrentTicketUpdateScheduling() {
+        return CURRENT_TICKET_UPDATE_SCHEDULING.get();
+    }
+
+    private boolean processTicketUpdates(final boolean checkLocks, final boolean processFullUpdates, List<ChunkProgressionTask> scheduledTasks) {
+        TickThread.ensureTickThread("Cannot process ticket levels off-main");
+        if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
+            throw new IllegalStateException("Cannot update ticket level while unloading chunks or updating entity manager");
+        }
+        if (checkLocks && this.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Illegal recursive processTicketUpdates!");
+        }
+        if (checkLocks && this.taskScheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot update ticket levels from a scheduler context!");
+        }
+
+        List<NewChunkHolder> changedFullStatus = null;
+
+        final boolean isTickThread = TickThread.isTickThread();
+
+        boolean ret = false;
+        final boolean canProcessFullUpdates = processFullUpdates & isTickThread;
+        final boolean canProcessScheduling = scheduledTasks == null;
+
+        this.ticketLock.lock();
+        try {
+            final boolean levelsUpdated = this.ticketLevelPropagator.propagateUpdates();
+            if (levelsUpdated) {
+                // Unlike CB, ticket level updates cannot happen recursively. Thank god.
+                if (!this.ticketLevelUpdates.isEmpty()) {
+                    ret = true;
+
+                    // first the necessary chunkholders must be created, so just update the ticket levels
+                    for (final Iterator<Long2IntMap.Entry> iterator = this.ticketLevelUpdates.long2IntEntrySet().fastIterator(); iterator.hasNext();) {
+                        final Long2IntMap.Entry entry = iterator.next();
+                        final long key = entry.getLongKey();
+                        final int newLevel = entry.getIntValue();
+
+                        NewChunkHolder current = this.chunkHolders.get(key);
+                        if (current == null && newLevel > MAX_TICKET_LEVEL) {
+                            // not loaded and it shouldn't be loaded!
+                            iterator.remove();
+                            continue;
+                        }
+
+                        final int currentLevel = current == null ? MAX_TICKET_LEVEL + 1 : current.getCurrentTicketLevel();
+                        if (currentLevel == newLevel) {
+                            // nothing to do
+                            iterator.remove();
+                            continue;
+                        }
+
+                        if (current == null) {
+                            // must create
+                            current = this.createChunkHolder(key);
+                            this.chunkHolders.put(key, current);
+                            current.updateTicketLevel(newLevel);
+                        } else {
+                            current.updateTicketLevel(newLevel);
+                        }
+                    }
+
+                    if (scheduledTasks == null) {
+                        scheduledTasks = new ArrayList<>();
+                    }
+                    changedFullStatus = new ArrayList<>();
+
+                    // allow the chunkholders to process ticket level updates without needing to acquire the schedule lock every time
+                    final List<ChunkProgressionTask> prev = CURRENT_TICKET_UPDATE_SCHEDULING.get();
+                    CURRENT_TICKET_UPDATE_SCHEDULING.set(scheduledTasks);
+                    try {
+                        this.taskScheduler.schedulingLock.lock();
+                        try {
+                            for (final Iterator<Long2IntMap.Entry> iterator = this.ticketLevelUpdates.long2IntEntrySet().fastIterator(); iterator.hasNext(); ) {
+                                final Long2IntMap.Entry entry = iterator.next();
+                                final long key = entry.getLongKey();
+                                final NewChunkHolder current = this.chunkHolders.get(key);
+
+                                if (current == null) {
+                                    throw new IllegalStateException("Expected chunk holder to be created");
+                                }
+
+                                current.processTicketLevelUpdate(scheduledTasks, changedFullStatus);
+                            }
+                        } finally {
+                            this.taskScheduler.schedulingLock.unlock();
+                        }
+                    } finally {
+                        CURRENT_TICKET_UPDATE_SCHEDULING.set(prev);
+                    }
+
+                    this.ticketLevelUpdates.clear();
+                }
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        if (changedFullStatus != null) {
+            this.addChangedStatuses(changedFullStatus);
+        }
+
+        if (canProcessScheduling && scheduledTasks != null) {
+            for (int i = 0, len = scheduledTasks.size(); i < len; ++i) {
+                scheduledTasks.get(i).schedule();
+            }
+        }
+
+        if (canProcessFullUpdates) {
+            ret |= this.processPendingFullUpdate();
+        }
+
+        return ret;
+    }
+
+    // only call on tick thread
+    protected final boolean processPendingFullUpdate() {
+        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+
+        boolean ret = false;
+
+        List<NewChunkHolder> changedFullStatus = new ArrayList<>();
+
+        NewChunkHolder holder;
+        while ((holder = pendingFullLoadUpdate.poll()) != null) {
+            ret |= holder.handleFullStatusChange(changedFullStatus);
+
+            if (!changedFullStatus.isEmpty()) {
+                for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
+                    pendingFullLoadUpdate.add(changedFullStatus.get(i));
+                }
+                changedFullStatus.clear();
+            }
+        }
+
+        return ret;
+    }
+
+    public JsonObject getDebugJsonForWatchdog() {
+        // try and detect any potential deadlock that would require us to read unlocked
+        try {
+            if (this.ticketLock.tryLock(10, TimeUnit.SECONDS)) {
+                try {
+                    if (this.taskScheduler.schedulingLock.tryLock(10, TimeUnit.SECONDS)) {
+                        try {
+                            return this.getDebugJsonNoLock();
+                        } finally {
+                            this.taskScheduler.schedulingLock.unlock();
+                        }
+                    }
+                } finally {
+                    this.ticketLock.unlock();
+                }
+            }
+        } catch (final InterruptedException ignore) {}
+
+        LOGGER.error("Failed to acquire ticket and scheduling lock before timeout for world " + this.world.getWorld().getName());
+
+        // because we read without locks, it may throw exceptions for fastutil maps
+        // so just try until it works...
+        Throwable lastException = null;
+        for (int count = 0;count < 1000;++count) {
+            try {
+                return this.getDebugJsonNoLock();
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr) {
+                lastException = thr;
+                Thread.yield();
+                LockSupport.parkNanos(10_000L);
+            }
+        }
+
+        // failed, return
+        LOGGER.error("Failed to retrieve debug json for watchdog thread without locking", lastException);
+        return null;
+    }
+
+    private JsonObject getDebugJsonNoLock() {
+        final JsonObject ret = new JsonObject();
+        ret.addProperty("current_tick", Long.valueOf(this.currentTick));
+
+        final JsonArray unloadQueue = new JsonArray();
+        ret.add("unload_queue", unloadQueue);
+        for (final NewChunkHolder holder : this.unloadQueue) {
+            final JsonObject coordinate = new JsonObject();
+            unloadQueue.add(coordinate);
+
+            coordinate.addProperty("chunkX", Integer.valueOf(holder.chunkX));
+            coordinate.addProperty("chunkZ", Integer.valueOf(holder.chunkZ));
+        }
+
+        final JsonArray holders = new JsonArray();
+        ret.add("chunkholders", holders);
+
+        for (final NewChunkHolder holder : this.getChunkHolders()) {
+            holders.add(holder.getDebugJson());
+        }
+
+        final JsonArray removeTickToChunkExpireTicketCount = new JsonArray();
+        ret.add("remove_tick_to_chunk_expire_ticket_count", removeTickToChunkExpireTicketCount);
+
+        for (final Long2ObjectMap.Entry<Long2IntOpenHashMap> tickEntry : this.removeTickToChunkExpireTicketCount.long2ObjectEntrySet()) {
+            final long tick = tickEntry.getLongKey();
+            final Long2IntOpenHashMap coordinateToCount = tickEntry.getValue();
+
+            final JsonObject tickJson = new JsonObject();
+            removeTickToChunkExpireTicketCount.add(tickJson);
+
+            tickJson.addProperty("tick", Long.valueOf(tick));
+
+            final JsonArray tickEntries = new JsonArray();
+            tickJson.add("entries", tickEntries);
+
+            for (final Long2IntMap.Entry entry : coordinateToCount.long2IntEntrySet()) {
+                final long coordinate = entry.getLongKey();
+                final int count = entry.getIntValue();
+
+                final JsonObject entryJson = new JsonObject();
+                tickEntries.add(entryJson);
+
+                entryJson.addProperty("chunkX", Long.valueOf(CoordinateUtils.getChunkX(coordinate)));
+                entryJson.addProperty("chunkZ", Long.valueOf(CoordinateUtils.getChunkZ(coordinate)));
+                entryJson.addProperty("count", Integer.valueOf(count));
+            }
+        }
+
+        final JsonArray allTicketsJson = new JsonArray();
+        ret.add("tickets", allTicketsJson);
+
+        for (final Long2ObjectMap.Entry<SortedArraySet<Ticket<?>>> coordinateTickets : this.tickets.long2ObjectEntrySet()) {
+            final long coordinate = coordinateTickets.getLongKey();
+            final SortedArraySet<Ticket<?>> tickets = coordinateTickets.getValue();
+
+            final JsonObject coordinateJson = new JsonObject();
+            allTicketsJson.add(coordinateJson);
+
+            coordinateJson.addProperty("chunkX", Long.valueOf(CoordinateUtils.getChunkX(coordinate)));
+            coordinateJson.addProperty("chunkZ", Long.valueOf(CoordinateUtils.getChunkZ(coordinate)));
+
+            final JsonArray ticketsSerialized = new JsonArray();
+            coordinateJson.add("tickets", ticketsSerialized);
+
+            for (final Ticket<?> ticket : tickets) {
+                final JsonObject ticketSerialized = new JsonObject();
+                ticketsSerialized.add(ticketSerialized);
+
+                ticketSerialized.addProperty("type", ticket.getType().toString());
+                ticketSerialized.addProperty("level", Integer.valueOf(ticket.getTicketLevel()));
+                ticketSerialized.addProperty("identifier", Objects.toString(ticket.key));
+                ticketSerialized.addProperty("remove_tick", Long.valueOf(ticket.removalTick));
+            }
+        }
+
+        return ret;
+    }
+
+    public JsonObject getDebugJson() {
+        final List<ChunkProgressionTask> scheduleList = new ArrayList<>();
+        try {
+            final JsonObject ret;
+            this.ticketLock.lock();
+            try {
+                this.taskScheduler.schedulingLock.lock();
+                try {
+                    this.processTicketUpdates(false, false, scheduleList);
+                    ret = this.getDebugJsonNoLock();
+                } finally {
+                    this.taskScheduler.schedulingLock.unlock();
+                }
+            } finally {
+                this.ticketLock.unlock();
+            }
+            return ret;
+        } finally {
+            // schedule tasks, we can't let processTicketUpdates do this because we call it holding the schedule lock
+            for (int i = 0, len = scheduleList.size(); i < len; ++i) {
+                scheduleList.get(i).schedule();
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..53ddd7e9ac05e6a9eb809f329796e6d4f6bb2ab1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java
@@ -0,0 +1,181 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.starlight.common.light.StarLightEngine;
+import ca.spottedleaf.starlight.common.light.StarLightInterface;
+import io.papermc.paper.chunk.system.light.LightQueue;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import java.util.function.BooleanSupplier;
+
+public final class ChunkLightTask extends ChunkProgressionTask {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    protected final ChunkAccess fromChunk;
+
+    private final LightTaskPriorityHolder priorityHolder;
+
+    public ChunkLightTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX, final int chunkZ,
+                          final ChunkAccess chunk, final PrioritisedExecutor.Priority priority) {
+        super(scheduler, world, chunkX, chunkZ);
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.priorityHolder = new LightTaskPriorityHolder(priority, this);
+        this.fromChunk = chunk;
+    }
+
+    @Override
+    public boolean isScheduled() {
+        return this.priorityHolder.isScheduled();
+    }
+
+    @Override
+    public ChunkStatus getTargetStatus() {
+        return ChunkStatus.LIGHT;
+    }
+
+    @Override
+    public void schedule() {
+        this.priorityHolder.schedule();
+    }
+
+    @Override
+    public void cancel() {
+        this.priorityHolder.cancel();
+    }
+
+    @Override
+    public PrioritisedExecutor.Priority getPriority() {
+        return this.priorityHolder.getPriority();
+    }
+
+    @Override
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        this.priorityHolder.raisePriority(priority);
+    }
+
+    @Override
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        this.priorityHolder.setPriority(priority);
+    }
+
+    @Override
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        this.priorityHolder.raisePriority(priority);
+    }
+
+    private static final class LightTaskPriorityHolder extends PriorityHolder {
+
+        protected final ChunkLightTask task;
+
+        protected LightTaskPriorityHolder(final PrioritisedExecutor.Priority priority, final ChunkLightTask task) {
+            super(priority);
+            this.task = task;
+        }
+
+        @Override
+        protected void cancelScheduled() {
+            final ChunkLightTask task = this.task;
+            task.complete(null, null);
+        }
+
+        @Override
+        protected PrioritisedExecutor.Priority getScheduledPriority() {
+            final ChunkLightTask task = this.task;
+            return task.world.getChunkSource().getLightEngine().theLightEngine.lightQueue.getPriority(task.chunkX, task.chunkZ);
+        }
+
+        @Override
+        protected void scheduleTask(final PrioritisedExecutor.Priority priority) {
+            final ChunkLightTask task = this.task;
+            final StarLightInterface starLightInterface = task.world.getChunkSource().getLightEngine().theLightEngine;
+            final LightQueue lightQueue = starLightInterface.lightQueue;
+            lightQueue.queueChunkLightTask(new ChunkPos(task.chunkX, task.chunkZ), new LightTask(starLightInterface, task), priority);
+            lightQueue.setPriority(task.chunkX, task.chunkZ, priority);
+        }
+
+        @Override
+        protected void lowerPriorityScheduled(final PrioritisedExecutor.Priority priority) {
+            final ChunkLightTask task = this.task;
+            final StarLightInterface starLightInterface = task.world.getChunkSource().getLightEngine().theLightEngine;
+            final LightQueue lightQueue = starLightInterface.lightQueue;
+            lightQueue.lowerPriority(task.chunkX, task.chunkZ, priority);
+        }
+
+        @Override
+        protected void setPriorityScheduled(final PrioritisedExecutor.Priority priority) {
+            final ChunkLightTask task = this.task;
+            final StarLightInterface starLightInterface = task.world.getChunkSource().getLightEngine().theLightEngine;
+            final LightQueue lightQueue = starLightInterface.lightQueue;
+            lightQueue.setPriority(task.chunkX, task.chunkZ, priority);
+        }
+
+        @Override
+        protected void raisePriorityScheduled(final PrioritisedExecutor.Priority priority) {
+            final ChunkLightTask task = this.task;
+            final StarLightInterface starLightInterface = task.world.getChunkSource().getLightEngine().theLightEngine;
+            final LightQueue lightQueue = starLightInterface.lightQueue;
+            lightQueue.raisePriority(task.chunkX, task.chunkZ, priority);
+        }
+    }
+
+    private static final class LightTask implements BooleanSupplier {
+
+        protected final StarLightInterface lightEngine;
+        protected final ChunkLightTask task;
+
+        public LightTask(final StarLightInterface lightEngine, final ChunkLightTask task) {
+            this.lightEngine = lightEngine;
+            this.task = task;
+        }
+
+        @Override
+        public boolean getAsBoolean() {
+            final ChunkLightTask task = this.task;
+            // executed on light thread
+            if (!task.priorityHolder.markExecuting()) {
+                // cancelled
+                return false;
+            }
+
+            try {
+                final Boolean[] emptySections = StarLightEngine.getEmptySectionsForChunk(task.fromChunk);
+
+                if (task.fromChunk.isLightCorrect() && task.fromChunk.getStatus().isOrAfter(ChunkStatus.LIGHT)) {
+                    this.lightEngine.forceLoadInChunk(task.fromChunk, emptySections);
+                    this.lightEngine.checkChunkEdges(task.chunkX, task.chunkZ);
+                } else {
+                    task.fromChunk.setLightCorrect(false);
+                    this.lightEngine.lightChunk(task.fromChunk, emptySections);
+                    task.fromChunk.setLightCorrect(true);
+                }
+                // we need to advance status
+                if (task.fromChunk instanceof ProtoChunk chunk && chunk.getStatus() == ChunkStatus.LIGHT.getParent()) {
+                    chunk.setStatus(ChunkStatus.LIGHT);
+                }
+            } catch (final Throwable thr) {
+                if (!(thr instanceof ThreadDeath)) {
+                    LOGGER.fatal("Failed to light chunk " + task.fromChunk.getPos().toString() + " in world '" + this.lightEngine.getWorld().getWorld().getName() + "'", thr);
+                }
+
+                task.complete(null, thr);
+
+                if (thr instanceof ThreadDeath) {
+                    throw (ThreadDeath)thr;
+                }
+
+                return true;
+            }
+
+            task.complete(task.fromChunk, null);
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLoadTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLoadTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..1e2b8e457aabba2a5d1fabfba22be2faa1d3f45d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLoadTask.java
@@ -0,0 +1,499 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import ca.spottedleaf.dataconverter.minecraft.MCDataConverter;
+import ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.io.RegionFileIOThread;
+import io.papermc.paper.chunk.system.poi.PoiChunk;
+import net.minecraft.SharedConstants;
+import net.minecraft.core.Registry;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.level.chunk.UpgradeData;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import net.minecraft.world.level.chunk.storage.EntityStorage;
+import net.minecraft.world.level.levelgen.blending.BlendingData;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+
+public final class ChunkLoadTask extends ChunkProgressionTask {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    private final NewChunkHolder chunkHolder;
+    private final ChunkDataLoadTask loadTask;
+
+    private boolean cancelled;
+    private NewChunkHolder.GenericDataLoadTaskCallback entityLoadTask;
+    private NewChunkHolder.GenericDataLoadTaskCallback poiLoadTask;
+
+    protected ChunkLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX, final int chunkZ,
+                            final NewChunkHolder chunkHolder, final PrioritisedExecutor.Priority priority) {
+        super(scheduler, world, chunkX, chunkZ);
+        this.chunkHolder = chunkHolder;
+        this.loadTask = new ChunkDataLoadTask(scheduler, world, chunkX, chunkZ, priority);
+        this.loadTask.addCallback((final GenericDataLoadTask.TaskResult<ChunkAccess, Throwable> result) -> {
+            ChunkLoadTask.this.complete(result == null ? null : result.left(), result == null ? null : result.right());
+        });
+    }
+
+    @Override
+    public ChunkStatus getTargetStatus() {
+        return ChunkStatus.EMPTY;
+    }
+
+    private boolean scheduled;
+
+    @Override
+    public boolean isScheduled() {
+        return this.scheduled;
+    }
+
+    @Override
+    public void schedule() {
+        final NewChunkHolder.GenericDataLoadTaskCallback entityLoadTask;
+        final NewChunkHolder.GenericDataLoadTaskCallback poiLoadTask;
+
+        final AtomicInteger count = new AtomicInteger();
+        final Consumer<GenericDataLoadTask.TaskResult<?, ?>> scheduleLoadTask = (final GenericDataLoadTask.TaskResult<?, ?> result) -> {
+            if (count.decrementAndGet() == 0) {
+                ChunkLoadTask.this.loadTask.schedule(false);
+            }
+        };
+
+        // NOTE: it is IMPOSSIBLE for getOrLoadEntityData/getOrLoadPoiData to complete synchronously, because
+        // they must schedule a task to off main or to on main to complete
+        this.scheduler.schedulingLock.lock();
+        try {
+            if (this.scheduled) {
+                throw new IllegalStateException("schedule() called twice");
+            }
+            this.scheduled = true;
+            if (this.cancelled) {
+                return;
+            }
+            if (!this.chunkHolder.isEntityChunkNBTLoaded()) {
+                entityLoadTask = this.chunkHolder.getOrLoadEntityData((Consumer)scheduleLoadTask);
+                count.setPlain(count.getPlain() + 1);
+            } else {
+                entityLoadTask = null;
+            }
+
+            if (!this.chunkHolder.isPoiChunkLoaded()) {
+                poiLoadTask = this.chunkHolder.getOrLoadPoiData((Consumer)scheduleLoadTask);
+                count.setPlain(count.getPlain() + 1);
+            } else {
+                poiLoadTask = null;
+            }
+
+            this.entityLoadTask = entityLoadTask;
+            this.poiLoadTask = poiLoadTask;
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+
+        if (entityLoadTask != null) {
+            entityLoadTask.schedule();
+        }
+
+        if (poiLoadTask !=  null) {
+            poiLoadTask.schedule();
+        }
+
+        if (entityLoadTask == null && poiLoadTask == null) {
+            // no need to wait on those, we can schedule now
+            this.loadTask.schedule(false);
+        }
+    }
+
+    @Override
+    public void cancel() {
+        // must be before load task access, so we can synchronise with the writes to the fields
+        this.scheduler.schedulingLock.lock();
+        try {
+            this.cancelled = true;
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+
+        /*
+        Note: The entityLoadTask/poiLoadTask do not complete when cancelled,
+        but this is fine because if they are successfully cancelled then
+        we will successfully cancel the load task, which will complete when cancelled
+        */
+
+        if (this.entityLoadTask != null) {
+            this.entityLoadTask.cancel();
+        }
+        if (this.poiLoadTask != null) {
+            this.poiLoadTask.cancel();
+        }
+        this.loadTask.cancel();
+    }
+
+    @Override
+    public PrioritisedExecutor.Priority getPriority() {
+        return this.loadTask.getPriority();
+    }
+
+    @Override
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        final EntityDataLoadTask entityLoad = this.chunkHolder.getEntityDataLoadTask();
+        if (entityLoad != null) {
+            entityLoad.lowerPriority(priority);
+        }
+
+        final PoiDataLoadTask poiLoad = this.chunkHolder.getPoiDataLoadTask();
+
+        if (poiLoad != null) {
+            poiLoad.lowerPriority(priority);
+        }
+
+        this.loadTask.lowerPriority(priority);
+    }
+
+    @Override
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        final EntityDataLoadTask entityLoad = this.chunkHolder.getEntityDataLoadTask();
+        if (entityLoad != null) {
+            entityLoad.setPriority(priority);
+        }
+
+        final PoiDataLoadTask poiLoad = this.chunkHolder.getPoiDataLoadTask();
+
+        if (poiLoad != null) {
+            poiLoad.setPriority(priority);
+        }
+
+        this.loadTask.setPriority(priority);
+    }
+
+    @Override
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        final EntityDataLoadTask entityLoad = this.chunkHolder.getEntityDataLoadTask();
+        if (entityLoad != null) {
+            entityLoad.raisePriority(priority);
+        }
+
+        final PoiDataLoadTask poiLoad = this.chunkHolder.getPoiDataLoadTask();
+
+        if (poiLoad != null) {
+            poiLoad.raisePriority(priority);
+        }
+
+        this.loadTask.raisePriority(priority);
+    }
+
+    protected static abstract class CallbackDataLoadTask<OnMain,FinalCompletion> extends GenericDataLoadTask<OnMain,FinalCompletion> {
+
+        private TaskResult<FinalCompletion, Throwable> result;
+        private final MultiThreadedQueue<Consumer<TaskResult<FinalCompletion, Throwable>>> waiters = new MultiThreadedQueue<>();
+
+        protected volatile boolean completed;
+        protected static final VarHandle COMPLETED_HANDLE = ConcurrentUtil.getVarHandle(CallbackDataLoadTask.class, "completed", boolean.class);
+
+        protected CallbackDataLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                                       final int chunkZ, final RegionFileIOThread.RegionFileType type,
+                                       final PrioritisedExecutor.Priority priority) {
+            super(scheduler, world, chunkX, chunkZ, type, priority);
+        }
+
+        public void addCallback(final Consumer<TaskResult<FinalCompletion, Throwable>> consumer) {
+            if (!this.waiters.add(consumer)) {
+                try {
+                    consumer.accept(this.result);
+                } catch (final Throwable throwable) {
+                    this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                        "Consumer", ChunkTaskScheduler.stringIfNull(consumer),
+                        "Completed throwable", ChunkTaskScheduler.stringIfNull(this.result.right())
+                    ), throwable);
+                    if (throwable instanceof ThreadDeath) {
+                        throw (ThreadDeath)throwable;
+                    }
+                }
+            }
+        }
+
+        @Override
+        protected void onComplete(final TaskResult<FinalCompletion, Throwable> result) {
+            if ((boolean)COMPLETED_HANDLE.getAndSet((CallbackDataLoadTask)this, (boolean)true)) {
+                throw new IllegalStateException("Already completed");
+            }
+            this.result = result;
+            Consumer<TaskResult<FinalCompletion, Throwable>> consumer;
+            while ((consumer = this.waiters.pollOrBlockAdds()) != null) {
+                try {
+                    consumer.accept(result);
+                } catch (final Throwable throwable) {
+                    this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                        "Consumer", ChunkTaskScheduler.stringIfNull(consumer),
+                        "Completed throwable", ChunkTaskScheduler.stringIfNull(result.right())
+                    ), throwable);
+                    if (throwable instanceof ThreadDeath) {
+                        throw (ThreadDeath)throwable;
+                    }
+                    return;
+                }
+            }
+        }
+    }
+
+    public final class ChunkDataLoadTask extends CallbackDataLoadTask<ChunkSerializer.InProgressChunkHolder, ChunkAccess> {
+        protected ChunkDataLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                                    final int chunkZ, final PrioritisedExecutor.Priority priority) {
+            super(scheduler, world, chunkX, chunkZ, RegionFileIOThread.RegionFileType.CHUNK_DATA, priority);
+        }
+
+        @Override
+        protected boolean hasOffMain() {
+            return true;
+        }
+
+        @Override
+        protected boolean hasOnMain() {
+            return true;
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOffMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            return this.scheduler.loadExecutor.createTask(run, priority);
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOnMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            return this.scheduler.createChunkTask(this.chunkX, this.chunkZ, run, priority);
+        }
+
+        @Override
+        protected TaskResult<ChunkAccess, Throwable> completeOnMainOffMain(final ChunkSerializer.InProgressChunkHolder data, final Throwable throwable) {
+            if (data != null) {
+                return null;
+            }
+
+            final PoiChunk poiChunk = ChunkLoadTask.this.chunkHolder.getPoiChunk();
+            if (poiChunk == null) {
+                LOGGER.error("Expected poi chunk to be loaded with chunk for task " + this.toString());
+            } else if (!poiChunk.isLoaded()) {
+                // need to call poiChunk.load() on main
+                return null;
+            }
+
+            return new TaskResult<>(this.getEmptyChunk(), null);
+        }
+
+        @Override
+        protected TaskResult<ChunkSerializer.InProgressChunkHolder, Throwable> runOffMain(final CompoundTag data, final Throwable throwable) {
+            if (throwable != null) {
+                LOGGER.error("Failed to load chunk data for task: " + this.toString() + ", chunk data will be lost", throwable);
+                return new TaskResult<>(null, null);
+            }
+
+            if (data == null) {
+                return new TaskResult<>(null, null);
+            }
+
+            // need to convert data, and then deserialize it
+
+            try {
+                final ChunkPos chunkPos = new ChunkPos(this.chunkX, this.chunkZ);
+                final ChunkMap chunkMap = this.world.getChunkSource().chunkMap;
+                // run converters
+                // note: upgradeChunkTag copies the data already
+                final CompoundTag converted = chunkMap.upgradeChunkTag(
+                    this.world.getTypeKey(), chunkMap.overworldDataStorage, data, chunkMap.generator.getTypeNameForDataFixer(),
+                    chunkPos, this.world
+                );
+                // deserialize
+                final ChunkSerializer.InProgressChunkHolder chunkHolder = ChunkSerializer.loadChunk(
+                    this.world, chunkMap.getPoiManager(), chunkPos, converted, true
+                );
+
+                return new TaskResult<>(chunkHolder, null);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr2) {
+                LOGGER.error("Failed to parse chunk data for task: " + this.toString() + ", chunk data will be lost", thr2);
+                return new TaskResult<>(null, thr2);
+            }
+        }
+
+        private ProtoChunk getEmptyChunk() {
+            return new ProtoChunk(
+                new ChunkPos(this.chunkX, this.chunkZ), UpgradeData.EMPTY, this.world,
+                this.world.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY), (BlendingData)null
+            );
+        }
+
+        @Override
+        protected TaskResult<ChunkAccess, Throwable> runOnMain(final ChunkSerializer.InProgressChunkHolder data, final Throwable throwable) {
+            final PoiChunk poiChunk = ChunkLoadTask.this.chunkHolder.getPoiChunk();
+            if (poiChunk == null) {
+                LOGGER.error("Expected poi chunk to be loaded with chunk for task " + this.toString());
+            } else {
+                poiChunk.load();
+            }
+
+            if (data == null || data.protoChunk == null) {
+                // throwable could be non-null, but the off-main task will print its exceptions - so we don't need to care,
+                // it's handled already
+
+                return new TaskResult<>(this.getEmptyChunk(), null);
+            }
+
+            // have tasks to run (at this point, it's just the POI consistency checking)
+            try {
+                if (data.tasks != null) {
+                    for (int i = 0, len = data.tasks.size(); i < len; ++i) {
+                        data.tasks.poll().run();
+                    }
+                }
+
+                return new TaskResult<>(data.protoChunk, null);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr2) {
+                LOGGER.error("Failed to parse main tasks for task " + this.toString() + ", chunk data will be lost", thr2);
+                return new TaskResult<>(this.getEmptyChunk(), null);
+            }
+        }
+    }
+
+    public static final class PoiDataLoadTask extends CallbackDataLoadTask<PoiChunk, PoiChunk> {
+        public PoiDataLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                               final int chunkZ, final PrioritisedExecutor.Priority priority) {
+            super(scheduler, world, chunkX, chunkZ, RegionFileIOThread.RegionFileType.POI_DATA, priority);
+        }
+
+        @Override
+        protected boolean hasOffMain() {
+            return true;
+        }
+
+        @Override
+        protected boolean hasOnMain() {
+            return false;
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOffMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            return this.scheduler.loadExecutor.createTask(run, priority);
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOnMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<PoiChunk, Throwable> completeOnMainOffMain(final PoiChunk data, final Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<PoiChunk, Throwable> runOffMain(CompoundTag data, final Throwable throwable) {
+            if (throwable != null) {
+                LOGGER.error("Failed to load poi data for task: " + this.toString() + ", poi data will be lost", throwable);
+                return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
+            }
+
+            if (data == null || data.isEmpty()) {
+                // nothing to do
+                return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
+            }
+
+            try {
+                data = data.copy(); // coming from the I/O thread, so we need to copy
+                // run converters
+                final int dataVersion = !data.contains(SharedConstants.DATA_VERSION_TAG, 99) ? 1945 : data.getInt(SharedConstants.DATA_VERSION_TAG);
+                final CompoundTag converted = MCDataConverter.convertTag(
+                    MCTypeRegistry.POI_CHUNK, data, dataVersion, SharedConstants.getCurrentVersion().getWorldVersion()
+                );
+
+                // now we need to parse it
+                return new TaskResult<>(PoiChunk.parse(this.world, this.chunkX, this.chunkZ, converted), null);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr2) {
+                LOGGER.error("Failed to run parse poi data for task: " + this.toString() + ", poi data will be lost", thr2);
+                return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
+            }
+        }
+
+        @Override
+        protected TaskResult<PoiChunk, Throwable> runOnMain(final PoiChunk data, final Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    public static final class EntityDataLoadTask extends CallbackDataLoadTask<CompoundTag, CompoundTag> {
+
+        public EntityDataLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                                  final int chunkZ, final PrioritisedExecutor.Priority priority) {
+            super(scheduler, world, chunkX, chunkZ, RegionFileIOThread.RegionFileType.ENTITY_DATA, priority);
+        }
+
+        @Override
+        protected boolean hasOffMain() {
+            return true;
+        }
+
+        @Override
+        protected boolean hasOnMain() {
+            return false;
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOffMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            return this.scheduler.loadExecutor.createTask(run, priority);
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOnMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<CompoundTag, Throwable> completeOnMainOffMain(final CompoundTag data, final Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<CompoundTag, Throwable> runOffMain(final CompoundTag data, final Throwable throwable) {
+            if (throwable != null) {
+                LOGGER.error("Failed to load entity data for task: " + this.toString() + ", entity data will be lost", throwable);
+                return new TaskResult<>(null, null);
+            }
+
+            if (data == null || data.isEmpty()) {
+                // nothing to do
+                return new TaskResult<>(null, null);
+            }
+
+            try {
+                // note: data comes from the I/O thread, so we need to copy it
+                return new TaskResult<>(EntityStorage.upgradeChunkTag(data.copy()), null);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr2) {
+                LOGGER.error("Failed to run converters for entity data for task: " + this.toString() + ", entity data will be lost", thr2);
+                return new TaskResult<>(null, thr2);
+            }
+        }
+
+        @Override
+        protected TaskResult<CompoundTag, Throwable> runOnMain(final CompoundTag data, final Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkProgressionTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkProgressionTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..322675a470eacbf0e5452f4009c643f2d0b4ce24
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkProgressionTask.java
@@ -0,0 +1,105 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import java.lang.invoke.VarHandle;
+import java.util.Map;
+import java.util.function.BiConsumer;
+
+public abstract class ChunkProgressionTask {
+
+    private final MultiThreadedQueue<BiConsumer<ChunkAccess, Throwable>> waiters = new MultiThreadedQueue<>();
+    private ChunkAccess completedChunk;
+    private Throwable completedThrowable;
+
+    protected final ChunkTaskScheduler scheduler;
+    protected final ServerLevel world;
+    protected final int chunkX;
+    protected final int chunkZ;
+
+    protected volatile boolean completed;
+    protected static final VarHandle COMPLETED_HANDLE = ConcurrentUtil.getVarHandle(ChunkProgressionTask.class, "completed", boolean.class);
+
+    protected ChunkProgressionTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX, final int chunkZ) {
+        this.scheduler = scheduler;
+        this.world = world;
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+    }
+
+    // Used only for debug json
+    public abstract boolean isScheduled();
+
+    // Note: It is the responsibility of the task to set the chunk's status once it has completed
+    public abstract ChunkStatus getTargetStatus();
+
+    /* Only executed once */
+    /* Implementations must be prepared to handle cases where cancel() is called before schedule() */
+    public abstract void schedule();
+
+    /* May be called multiple times */
+    public abstract void cancel();
+
+    public abstract PrioritisedExecutor.Priority getPriority();
+
+    /* Schedule lock is always held for the priority update calls */
+
+    public abstract void lowerPriority(final PrioritisedExecutor.Priority priority);
+
+    public abstract void setPriority(final PrioritisedExecutor.Priority priority);
+
+    public abstract void raisePriority(final PrioritisedExecutor.Priority priority);
+
+    public final void onComplete(final BiConsumer<ChunkAccess, Throwable> onComplete) {
+        if (!this.waiters.add(onComplete)) {
+            try {
+                onComplete.accept(this.completedChunk, this.completedThrowable);
+            } catch (final Throwable throwable) {
+                this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                    "Consumer", ChunkTaskScheduler.stringIfNull(onComplete),
+                    "Completed throwable", ChunkTaskScheduler.stringIfNull(this.completedThrowable)
+                ), throwable);
+                if (throwable instanceof ThreadDeath) {
+                    throw (ThreadDeath)throwable;
+                }
+            }
+        }
+    }
+
+    protected final void complete(final ChunkAccess chunk, final Throwable throwable) {
+        try {
+            this.complete0(chunk, throwable);
+        } catch (final Throwable thr2) {
+            this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                "Completed throwable", ChunkTaskScheduler.stringIfNull(throwable)
+            ), thr2);
+            if (thr2 instanceof ThreadDeath) {
+                throw (ThreadDeath)thr2;
+            }
+        }
+    }
+
+    private void complete0(final ChunkAccess chunk, final Throwable throwable) {
+        if ((boolean)COMPLETED_HANDLE.getAndSet((ChunkProgressionTask)this, (boolean)true)) {
+            throw new IllegalStateException("Already completed");
+        }
+        this.completedChunk = chunk;
+        this.completedThrowable = throwable;
+
+        BiConsumer<ChunkAccess, Throwable> consumer;
+        while ((consumer = this.waiters.pollOrBlockAdds()) != null) {
+            consumer.accept(chunk, throwable);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "ChunkProgressionTask{class: " + this.getClass().getName() + ", for world: " + this.world.getWorld().getName() +
+            ", chunk: (" + this.chunkX + "," + this.chunkZ + "), hashcode: " + System.identityHashCode(this) + ", priority: " + this.getPriority() +
+            ", status: " + this.getTargetStatus().toString() + ", scheduled: " + this.isScheduled() + "}";
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b4e3f31d7c31aa5a4a5a18ba9e1d8b3f232fd16
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
@@ -0,0 +1,780 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadPool;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadedTaskQueue;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import net.minecraft.CrashReport;
+import net.minecraft.CrashReportCategory;
+import net.minecraft.ReportedException;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.TicketType;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.Bukkit;
+import org.slf4j.Logger;
+import java.io.File;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
+
+public final class ChunkTaskScheduler {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    static int newChunkSystemIOThreads;
+    static int newChunkSystemWorkerThreads;
+    static int newChunkSystemGenParallelism;
+    static int newChunkSystemLoadParallelism;
+
+    public static ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadPool workerThreads;
+
+    private static boolean initialised = false;
+
+    public static void init(final GlobalConfiguration.ChunkSystem config) {
+        if (initialised) {
+            return;
+        }
+        initialised = true;
+        newChunkSystemIOThreads = config.ioThreads;
+        newChunkSystemWorkerThreads = config.workerThreads;
+        if (newChunkSystemIOThreads < 0) {
+            newChunkSystemIOThreads = 1;
+        } else {
+            newChunkSystemIOThreads = Math.max(1, newChunkSystemIOThreads);
+        }
+        int defaultWorkerThreads = Runtime.getRuntime().availableProcessors() / 2;
+        if (defaultWorkerThreads <= 4) {
+            defaultWorkerThreads = defaultWorkerThreads <= 3 ? 1 : 2;
+        } else {
+            defaultWorkerThreads = defaultWorkerThreads / 2;
+        }
+        defaultWorkerThreads = Integer.getInteger("Paper.WorkerThreadCount", Integer.valueOf(defaultWorkerThreads));
+
+        if (newChunkSystemWorkerThreads < 0) {
+            newChunkSystemWorkerThreads = defaultWorkerThreads;
+        } else {
+            newChunkSystemWorkerThreads = Math.max(1, newChunkSystemWorkerThreads);
+        }
+
+        String newChunkSystemGenParallelism = config.genParallelism;
+        if (newChunkSystemGenParallelism.equalsIgnoreCase("default")) {
+            newChunkSystemGenParallelism = "true";
+        }
+        boolean useParallelGen;
+        if (newChunkSystemGenParallelism.equalsIgnoreCase("on") || newChunkSystemGenParallelism.equalsIgnoreCase("enabled")
+            || newChunkSystemGenParallelism.equalsIgnoreCase("true")) {
+            useParallelGen = true;
+        } else if (newChunkSystemGenParallelism.equalsIgnoreCase("off") || newChunkSystemGenParallelism.equalsIgnoreCase("disabled")
+            || newChunkSystemGenParallelism.equalsIgnoreCase("false")) {
+            useParallelGen = false;
+        } else {
+            throw new IllegalStateException("Invalid option for gen-parallelism: must be one of [on, off, enabled, disabled, true, false, default]");
+        }
+
+        ChunkTaskScheduler.newChunkSystemGenParallelism = useParallelGen ? newChunkSystemWorkerThreads : 1;
+        ChunkTaskScheduler.newChunkSystemLoadParallelism = newChunkSystemWorkerThreads;
+
+        io.papermc.paper.chunk.system.io.RegionFileIOThread.init(newChunkSystemIOThreads);
+        workerThreads = new ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadPool(
+            "Paper Chunk System Worker Pool", newChunkSystemWorkerThreads,
+            (final Thread thread, final Integer id) -> {
+                thread.setPriority(Thread.NORM_PRIORITY - 2);
+                thread.setName("Tuinity Chunk System Worker #" + id.intValue());
+                thread.setUncaughtExceptionHandler(io.papermc.paper.chunk.system.scheduling.NewChunkHolder.CHUNKSYSTEM_UNCAUGHT_EXCEPTION_HANDLER);
+            }, (long)(20.0e6)); // 20ms
+
+        LOGGER.info("Chunk system is using " + newChunkSystemIOThreads + " I/O threads, " + newChunkSystemWorkerThreads + " worker threads, and gen parallelism of " + ChunkTaskScheduler.newChunkSystemGenParallelism + " threads");
+    }
+
+    public final ServerLevel world;
+    public final PrioritisedThreadPool workers;
+    public final PrioritisedThreadPool.PrioritisedPoolExecutor lightExecutor;
+    public final PrioritisedThreadPool.PrioritisedPoolExecutor genExecutor;
+    public final PrioritisedThreadPool.PrioritisedPoolExecutor parallelGenExecutor;
+    public final PrioritisedThreadPool.PrioritisedPoolExecutor loadExecutor;
+
+    private final PrioritisedThreadedTaskQueue mainThreadExecutor = new PrioritisedThreadedTaskQueue();
+
+    final ReentrantLock schedulingLock = new ReentrantLock();
+    public final ChunkHolderManager chunkHolderManager;
+
+    static {
+        ChunkStatus.EMPTY.writeRadius = 0;
+        ChunkStatus.STRUCTURE_STARTS.writeRadius = 0;
+        ChunkStatus.STRUCTURE_REFERENCES.writeRadius = 0;
+        ChunkStatus.BIOMES.writeRadius = 0;
+        ChunkStatus.NOISE.writeRadius = 0;
+        ChunkStatus.SURFACE.writeRadius = 0;
+        ChunkStatus.CARVERS.writeRadius = 0;
+        ChunkStatus.LIQUID_CARVERS.writeRadius = 0;
+        ChunkStatus.FEATURES.writeRadius = 1;
+        ChunkStatus.LIGHT.writeRadius = 1;
+        ChunkStatus.SPAWN.writeRadius = 0;
+        ChunkStatus.HEIGHTMAPS.writeRadius = 0;
+        ChunkStatus.FULL.writeRadius = 0;
+
+        /*
+          It's important that the neighbour read radius is taken into account. If _any_ later status is using some chunk as
+          a neighbour, it must be also safe if that neighbour is being generated. i.e for any status later than FEATURES,
+          for a status to be parallel safe it must not read the block data from its neighbours.
+         */
+        final List<ChunkStatus> parallelCapableStatus = Arrays.asList(
+                // No-op executor.
+                ChunkStatus.EMPTY,
+
+                // This is parallel capable, as CB has fixed the concurrency issue with stronghold generations.
+                // Does not touch neighbour chunks.
+                // TODO On another note, what the fuck is StructureFeatureManager.StructureCheck and why is it used? it's leaking
+                ChunkStatus.STRUCTURE_STARTS,
+
+                // Surprisingly this is parallel capable. It is simply reading the already-created structure starts
+                // into the structure references for the chunk. So while it reads from it neighbours, its neighbours
+                // will not change, even if executed in parallel.
+                ChunkStatus.STRUCTURE_REFERENCES,
+
+                // Safe. Mojang runs it in parallel as well.
+                ChunkStatus.BIOMES,
+
+                // Safe. Mojang runs it in parallel as well.
+                ChunkStatus.NOISE,
+
+                // Parallel safe. Only touches the target chunk. Biome retrieval is now noise based, which is
+                // completely thread-safe.
+                ChunkStatus.SURFACE,
+
+                // No global state is modified in the carvers. It only touches the specified chunk. So it is parallel safe.
+                ChunkStatus.CARVERS,
+
+                // No-op executor. Was replaced in 1.18 with carvers, I think.
+                ChunkStatus.LIQUID_CARVERS,
+
+                // FEATURES is not parallel safe. It writes to neighbours.
+
+                // LIGHT is not parallel safe. It also doesn't run on the generation executor, so no point.
+
+                // Only writes to the specified chunk. State is not read by later statuses. Parallel safe.
+                // Note: it may look unsafe because it writes to a worldgenregion, but the region size is always 0 -
+                // see the task margin.
+                // However, if the neighbouring FEATURES chunk is unloaded, but then fails to load in again (for whatever
+                // reason), then it would write to this chunk - and since this status reads blocks from itself, it's not
+                // safe to execute this in parallel.
+                // SPAWN
+
+                // No-op executor.
+                ChunkStatus.HEIGHTMAPS
+
+                // FULL is executed on main.
+        );
+
+        for (final ChunkStatus status : parallelCapableStatus) {
+            status.isParallelCapable = true;
+        }
+    }
+
+    public ChunkTaskScheduler(final ServerLevel world, final PrioritisedThreadPool workers) {
+        this.world = world;
+        this.workers = workers;
+
+        final String worldName = world.getWorld().getName();
+        this.genExecutor = workers.createExecutor("Chunk single-threaded generation executor for world '" + worldName + "'", 1);
+        // same as genExecutor, as there are race conditions between updating blocks in FEATURE status while lighting chunks
+        this.lightExecutor = this.genExecutor;
+        this.parallelGenExecutor = newChunkSystemGenParallelism <= 1 ? this.genExecutor
+                : workers.createExecutor("Chunk parallel generation executor for world '" + worldName + "'", newChunkSystemGenParallelism);
+        this.loadExecutor = workers.createExecutor("Chunk load executor for world '" + worldName + "'", newChunkSystemLoadParallelism);
+        this.chunkHolderManager = new ChunkHolderManager(world, this);
+    }
+
+    private final AtomicBoolean failedChunkSystem = new AtomicBoolean();
+
+    public static Object stringIfNull(final Object obj) {
+        return obj == null ? "null" : obj;
+    }
+
+    public void unrecoverableChunkSystemFailure(final int chunkX, final int chunkZ, final Map<String, Object> objectsOfInterest, final Throwable thr) {
+        final NewChunkHolder holder = this.chunkHolderManager.getChunkHolder(chunkX, chunkZ);
+        LOGGER.error("Chunk system error at chunk (" + chunkX + "," + chunkZ + "), holder: " + holder + ", exception:", new Throwable(thr));
+
+        if (this.failedChunkSystem.getAndSet(true)) {
+            return;
+        }
+
+        final ReportedException reportedException = thr instanceof ReportedException ? (ReportedException)thr : new ReportedException(new CrashReport("Chunk system error", thr));
+
+        CrashReportCategory crashReportCategory = reportedException.getReport().addCategory("Chunk system details");
+        crashReportCategory.setDetail("Chunk coordinate", new ChunkPos(chunkX, chunkZ).toString());
+        crashReportCategory.setDetail("ChunkHolder", Objects.toString(holder));
+        crashReportCategory.setDetail("unrecoverableChunkSystemFailure caller thread", Thread.currentThread().getName());
+
+        crashReportCategory = reportedException.getReport().addCategory("Chunk System Objects of Interest");
+        for (final Map.Entry<String, Object> entry : objectsOfInterest.entrySet()) {
+            if (entry.getValue() instanceof Throwable thrObject) {
+                crashReportCategory.setDetailError(Objects.toString(entry.getKey()), thrObject);
+            } else {
+                crashReportCategory.setDetail(Objects.toString(entry.getKey()), Objects.toString(entry.getValue()));
+            }
+        }
+
+        final Runnable crash = () -> {
+            throw new RuntimeException("Chunk system crash propagated from unrecoverableChunkSystemFailure", reportedException);
+        };
+
+        // this may not be good enough, specifically thanks to stupid ass plugins swallowing exceptions
+        this.scheduleChunkTask(chunkX, chunkZ, crash, PrioritisedExecutor.Priority.BLOCKING);
+        // so, make the main thread pick it up
+        MinecraftServer.chunkSystemCrash = new RuntimeException("Chunk system crash propagated from unrecoverableChunkSystemFailure", reportedException);
+    }
+
+    public boolean executeMainThreadTask() {
+        TickThread.ensureTickThread("Cannot execute main thread task off-main");
+        return this.mainThreadExecutor.executeTask();
+    }
+
+    public void raisePriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        this.chunkHolderManager.raisePriority(x, z, priority);
+    }
+
+    public void setPriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        this.chunkHolderManager.setPriority(x, z, priority);
+    }
+
+    public void lowerPriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        this.chunkHolderManager.lowerPriority(x, z, priority);
+    }
+
+    private final AtomicLong chunkLoadCounter = new AtomicLong();
+
+    public void scheduleTickingState(final int chunkX, final int chunkZ, final ChunkHolder.FullChunkStatus toStatus,
+                                     final boolean addTicket, final PrioritisedExecutor.Priority priority,
+                                     final Consumer<LevelChunk> onComplete) {
+        if (!TickThread.isTickThread()) {
+            this.scheduleChunkTask(chunkX, chunkZ, () -> {
+                ChunkTaskScheduler.this.scheduleTickingState(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
+            }, priority);
+            return;
+        }
+        if (this.chunkHolderManager.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot schedule chunk load during ticket level update");
+        }
+        if (this.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot schedule chunk loading recursively");
+        }
+
+        if (toStatus == ChunkHolder.FullChunkStatus.INACCESSIBLE) {
+            throw new IllegalArgumentException("Cannot wait for INACCESSIBLE status");
+        }
+
+        final int minLevel = 33 - (toStatus.ordinal() - 1);
+        final Long chunkReference = addTicket ? Long.valueOf(this.chunkLoadCounter.getAndIncrement()) : null;
+        final long chunkKey = CoordinateUtils.getChunkKey(chunkX, chunkZ);
+
+        if (addTicket) {
+            this.chunkHolderManager.addTicketAtLevel(TicketType.CHUNK_LOAD, chunkKey, minLevel, chunkReference);
+            this.chunkHolderManager.processTicketUpdates();
+        }
+
+        final Consumer<LevelChunk> loadCallback = (final LevelChunk chunk) -> {
+            try {
+                if (onComplete != null) {
+                    onComplete.accept(chunk);
+                }
+            } finally {
+                if (addTicket) {
+                    ChunkTaskScheduler.this.chunkHolderManager.addAndRemoveTickets(chunkKey,
+                        TicketType.UNKNOWN, minLevel, new ChunkPos(chunkKey),
+                        TicketType.CHUNK_LOAD, minLevel, chunkReference
+                    );
+                }
+            }
+        };
+
+        final boolean scheduled;
+        final LevelChunk chunk;
+        this.chunkHolderManager.ticketLock.lock();
+        try {
+            this.schedulingLock.lock();
+            try {
+                final NewChunkHolder chunkHolder = this.chunkHolderManager.getChunkHolder(chunkKey);
+                if (chunkHolder == null || chunkHolder.getTicketLevel() > minLevel) {
+                    scheduled = false;
+                    chunk = null;
+                } else {
+                    final ChunkHolder.FullChunkStatus currStatus = chunkHolder.getChunkStatus();
+                    if (currStatus.isOrAfter(toStatus)) {
+                        scheduled = false;
+                        chunk = (LevelChunk)chunkHolder.getCurrentChunk();
+                    } else {
+                        scheduled = true;
+                        chunk = null;
+
+                        final int radius = toStatus.ordinal() - 1; // 0 -> BORDER, 1 -> TICKING, 2 -> ENTITY_TICKING
+                        for (int dz = -radius; dz <= radius; ++dz) {
+                            for (int dx = -radius; dx <= radius; ++dx) {
+                                final NewChunkHolder neighbour =
+                                    (dx | dz) == 0 ? chunkHolder : this.chunkHolderManager.getChunkHolder(dx + chunkX, dz + chunkZ);
+                                if (neighbour != null) {
+                                    neighbour.raisePriority(priority);
+                                }
+                            }
+                        }
+
+                        // ticket level should schedule for us
+                        chunkHolder.addFullStatusConsumer(toStatus, loadCallback);
+                    }
+                }
+            } finally {
+                this.schedulingLock.unlock();
+            }
+        } finally {
+            this.chunkHolderManager.ticketLock.unlock();
+        }
+
+        if (!scheduled) {
+            // couldn't schedule
+            try {
+                loadCallback.accept(chunk);
+            } catch (final ThreadDeath thr) {
+                throw thr;
+            } catch (final Throwable thr) {
+                LOGGER.error("Failed to process chunk full status callback", thr);
+            }
+        }
+    }
+
+    public void scheduleChunkLoad(final int chunkX, final int chunkZ, final boolean gen, final ChunkStatus toStatus, final boolean addTicket,
+                                  final PrioritisedExecutor.Priority priority, final Consumer<ChunkAccess> onComplete) {
+        if (gen) {
+            this.scheduleChunkLoad(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
+            return;
+        }
+        this.scheduleChunkLoad(chunkX, chunkZ, ChunkStatus.EMPTY, addTicket, priority, (final ChunkAccess chunk) -> {
+            if (chunk == null) {
+                onComplete.accept(null);
+            } else {
+                if (chunk.getStatus().isOrAfter(toStatus)) {
+                    this.scheduleChunkLoad(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
+                } else {
+                    onComplete.accept(null);
+                }
+            }
+        });
+    }
+
+    public void scheduleChunkLoad(final int chunkX, final int chunkZ, final ChunkStatus toStatus, final boolean addTicket,
+                                  final PrioritisedExecutor.Priority priority, final Consumer<ChunkAccess> onComplete) {
+        if (!TickThread.isTickThread()) {
+            this.scheduleChunkTask(chunkX, chunkZ, () -> {
+                ChunkTaskScheduler.this.scheduleChunkLoad(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
+            }, priority);
+            return;
+        }
+        if (this.chunkHolderManager.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot schedule chunk load during ticket level update");
+        }
+        if (this.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot schedule chunk loading recursively");
+        }
+
+        if (toStatus == ChunkStatus.FULL) {
+            this.scheduleTickingState(chunkX, chunkZ, ChunkHolder.FullChunkStatus.BORDER, addTicket, priority, (Consumer)onComplete);
+            return;
+        }
+
+        final int minLevel = 33 + ChunkStatus.getDistance(toStatus);
+        final Long chunkReference = addTicket ? Long.valueOf(this.chunkLoadCounter.getAndIncrement()) : null;
+        final long chunkKey = CoordinateUtils.getChunkKey(chunkX, chunkZ);
+
+        if (addTicket) {
+            this.chunkHolderManager.addTicketAtLevel(TicketType.CHUNK_LOAD, chunkKey, minLevel, chunkReference);
+            this.chunkHolderManager.processTicketUpdates();
+        }
+
+        final Consumer<ChunkAccess> loadCallback = (final ChunkAccess chunk) -> {
+            try {
+                if (onComplete != null) {
+                    onComplete.accept(chunk);
+                }
+            } finally {
+                if (addTicket) {
+                    ChunkTaskScheduler.this.chunkHolderManager.addAndRemoveTickets(chunkKey,
+                        TicketType.UNKNOWN, minLevel, new ChunkPos(chunkKey),
+                        TicketType.CHUNK_LOAD, minLevel, chunkReference
+                    );
+                }
+            }
+        };
+
+        final List<ChunkProgressionTask> tasks = new ArrayList<>();
+
+        final boolean scheduled;
+        final ChunkAccess chunk;
+        this.chunkHolderManager.ticketLock.lock();
+        try {
+            this.schedulingLock.lock();
+            try {
+                final NewChunkHolder chunkHolder = this.chunkHolderManager.getChunkHolder(chunkKey);
+                if (chunkHolder == null || chunkHolder.getTicketLevel() > minLevel) {
+                    scheduled = false;
+                    chunk = null;
+                } else {
+                    final ChunkStatus genStatus = chunkHolder.getCurrentGenStatus();
+                    if (genStatus != null && genStatus.isOrAfter(toStatus)) {
+                        scheduled = false;
+                        chunk = chunkHolder.getCurrentChunk();
+                    } else {
+                        scheduled = true;
+                        chunk = null;
+                        chunkHolder.raisePriority(priority);
+
+                        if (!chunkHolder.upgradeGenTarget(toStatus)) {
+                            this.schedule(chunkX, chunkZ, toStatus, chunkHolder, tasks);
+                        }
+                        chunkHolder.addStatusConsumer(toStatus, loadCallback);
+                    }
+                }
+            } finally {
+                this.schedulingLock.unlock();
+            }
+        } finally {
+            this.chunkHolderManager.ticketLock.unlock();
+        }
+
+        for (int i = 0, len = tasks.size(); i < len; ++i) {
+            tasks.get(i).schedule();
+        }
+
+        if (!scheduled) {
+            // couldn't schedule
+            try {
+                loadCallback.accept(chunk);
+            } catch (final ThreadDeath thr) {
+                throw thr;
+            } catch (final Throwable thr) {
+                LOGGER.error("Failed to process chunk status callback", thr);
+            }
+        }
+    }
+
+    private ChunkProgressionTask createTask(final int chunkX, final int chunkZ, final ChunkAccess chunk,
+                                            final NewChunkHolder chunkHolder, final List<ChunkAccess> neighbours,
+                                            final ChunkStatus toStatus, final PrioritisedExecutor.Priority initialPriority) {
+        if (toStatus == ChunkStatus.EMPTY) {
+            return new ChunkLoadTask(this, this.world, chunkX, chunkZ, chunkHolder, initialPriority);
+        }
+        if (toStatus == ChunkStatus.LIGHT) {
+            return new ChunkLightTask(this, this.world, chunkX, chunkZ, chunk, initialPriority);
+        }
+        if (toStatus == ChunkStatus.FULL) {
+            return new ChunkFullTask(this, this.world, chunkX, chunkZ, chunkHolder, chunk, initialPriority);
+        }
+
+        return new ChunkUpgradeGenericStatusTask(this, this.world, chunkX, chunkZ, chunk, neighbours, toStatus, initialPriority);
+    }
+
+    ChunkProgressionTask schedule(final int chunkX, final int chunkZ, final ChunkStatus targetStatus, final NewChunkHolder chunkHolder,
+                                  final List<ChunkProgressionTask> allTasks) {
+        return this.schedule(chunkX, chunkZ, targetStatus, chunkHolder, allTasks, chunkHolder.getEffectivePriority());
+    }
+
+    // rets new task scheduled for the _specified_ chunk
+    // note: this must hold the scheduling lock
+    // minPriority is only used to pass the priority through to neighbours, as priority calculation has not yet been done
+    // schedule will ignore the generation target, so it should be checked by the caller to ensure the target is not regressed!
+    private ChunkProgressionTask schedule(final int chunkX, final int chunkZ, final ChunkStatus targetStatus,
+                                          final NewChunkHolder chunkHolder, final List<ChunkProgressionTask> allTasks,
+                                          final PrioritisedExecutor.Priority minPriority) {
+        if (!this.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Not holding scheduling lock");
+        }
+
+        if (chunkHolder.hasGenerationTask()) {
+            chunkHolder.upgradeGenTarget(targetStatus);
+            return null;
+        }
+
+        final PrioritisedExecutor.Priority requestedPriority = PrioritisedExecutor.Priority.max(minPriority, chunkHolder.getEffectivePriority());
+        final ChunkStatus currentGenStatus = chunkHolder.getCurrentGenStatus();
+        final ChunkAccess chunk = chunkHolder.getCurrentChunk();
+
+        if (currentGenStatus == null) {
+            // not yet loaded
+            final ChunkProgressionTask task = this.createTask(
+                chunkX, chunkZ, chunk, chunkHolder, Collections.emptyList(), ChunkStatus.EMPTY, requestedPriority
+            );
+
+            allTasks.add(task);
+
+            final List<NewChunkHolder> chunkHolderNeighbours = new ArrayList<>(1);
+            chunkHolderNeighbours.add(chunkHolder);
+
+            chunkHolder.setGenerationTarget(targetStatus);
+            chunkHolder.setGenerationTask(task, ChunkStatus.EMPTY, chunkHolderNeighbours);
+
+            return task;
+        }
+
+        if (currentGenStatus.isOrAfter(targetStatus)) {
+            // nothing to do
+            return null;
+        }
+
+        // we know for sure now that we want to schedule _something_, so set the target
+        chunkHolder.setGenerationTarget(targetStatus);
+
+        final ChunkStatus chunkRealStatus = chunk.getStatus();
+        final ChunkStatus toStatus = currentGenStatus.getNextStatus();
+
+        // if this chunk has already generated up to or past the specified status, then we don't
+        // need the neighbours AT ALL.
+        final int neighbourReadRadius = chunkRealStatus.isOrAfter(toStatus) ? toStatus.loadRange : toStatus.getRange();
+
+        boolean unGeneratedNeighbours = false;
+
+        // copied from MCUtil.getSpiralOutChunks
+        for (int r = 1; r <= neighbourReadRadius; r++) {
+            int x = -r;
+            int z = r;
+
+            // Iterates the edge of half of the box; then negates for other half.
+            while (x <= r && z > -r) {
+                final int radius = Math.max(Math.abs(x), Math.abs(z));
+                final ChunkStatus requiredNeighbourStatus = ChunkMap.getDependencyStatus(toStatus, radius);
+
+                unGeneratedNeighbours |= this.checkNeighbour(
+                    chunkX + x, chunkZ + z, requiredNeighbourStatus, chunkHolder, allTasks, requestedPriority
+                );
+                unGeneratedNeighbours |= this.checkNeighbour(
+                    chunkX - x, chunkZ - z, requiredNeighbourStatus, chunkHolder, allTasks, requestedPriority
+                );
+
+                if (x < r) {
+                    x++;
+                } else {
+                    z--;
+                }
+            }
+        }
+
+        if (unGeneratedNeighbours) {
+            // can't schedule, but neighbour completion will schedule for us when they're ALL done
+
+            // propagate our priority to neighbours
+            chunkHolder.recalculateNeighbourPriorities();
+            return null;
+        }
+
+        // need to gather neighbours
+
+        final List<ChunkAccess> neighbours;
+        final List<NewChunkHolder> chunkHolderNeighbours;
+        if (neighbourReadRadius <= 0) {
+            neighbours = new ArrayList<>(1);
+            chunkHolderNeighbours = new ArrayList<>(1);
+            neighbours.add(chunk);
+            chunkHolderNeighbours.add(chunkHolder);
+        } else {
+            // the iteration order is _very_ important, as all generation statuses expect a certain order such that:
+            // chunkAtRelative = neighbours.get(relX + relZ * (2 * radius + 1))
+            neighbours = new ArrayList<>((2 * neighbourReadRadius + 1) * (2 * neighbourReadRadius + 1));
+            chunkHolderNeighbours = new ArrayList<>((2 * neighbourReadRadius + 1) * (2 * neighbourReadRadius + 1));
+            for (int dz = -neighbourReadRadius; dz <= neighbourReadRadius; ++dz) {
+                for (int dx = -neighbourReadRadius; dx <= neighbourReadRadius; ++dx) {
+                    final NewChunkHolder holder = (dx | dz) == 0 ? chunkHolder : this.chunkHolderManager.getChunkHolder(dx + chunkX, dz + chunkZ);
+                    neighbours.add(holder.getChunkForNeighbourAccess());
+                    chunkHolderNeighbours.add(holder);
+                }
+            }
+        }
+
+        final ChunkProgressionTask task = this.createTask(chunkX, chunkZ, chunk, chunkHolder, neighbours, toStatus, chunkHolder.getEffectivePriority());
+        allTasks.add(task);
+
+        chunkHolder.setGenerationTask(task, toStatus, chunkHolderNeighbours);
+
+        return task;
+    }
+
+    // rets true if the neighbour is not at the required status, false otherwise
+    private boolean checkNeighbour(final int chunkX, final int chunkZ, final ChunkStatus requiredStatus, final NewChunkHolder center,
+                                   final List<ChunkProgressionTask> tasks, final PrioritisedExecutor.Priority minPriority) {
+        final NewChunkHolder chunkHolder = this.chunkHolderManager.getChunkHolder(chunkX, chunkZ);
+
+        if (chunkHolder == null) {
+            throw new IllegalStateException("Missing chunkholder when required");
+        }
+
+        final ChunkStatus holderStatus = chunkHolder.getCurrentGenStatus();
+        if (holderStatus != null && holderStatus.isOrAfter(requiredStatus)) {
+            return false;
+        }
+
+        if (chunkHolder.hasFailedGeneration()) {
+            return true;
+        }
+
+        center.addGenerationBlockingNeighbour(chunkHolder);
+        chunkHolder.addWaitingNeighbour(center, requiredStatus);
+
+        if (chunkHolder.upgradeGenTarget(requiredStatus)) {
+            return true;
+        }
+
+        // not at status required, so we need to schedule its generation
+        this.schedule(
+            chunkX, chunkZ, requiredStatus, chunkHolder, tasks, minPriority
+        );
+
+        return true;
+    }
+
+    /**
+     * @deprecated Chunk tasks must be tied to coordinates in the future
+     */
+    @Deprecated
+    public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final Runnable run) {
+        return this.scheduleChunkTask(run, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    /**
+     * @deprecated Chunk tasks must be tied to coordinates in the future
+     */
+    @Deprecated
+    public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final Runnable run, final PrioritisedExecutor.Priority priority) {
+        return this.mainThreadExecutor.queueRunnable(run, priority);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask createChunkTask(final int chunkX, final int chunkZ, final Runnable run) {
+        return this.createChunkTask(chunkX, chunkZ, run, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask createChunkTask(final int chunkX, final int chunkZ, final Runnable run,
+                                                               final PrioritisedExecutor.Priority priority) {
+        return this.mainThreadExecutor.createTask(run, priority);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final int chunkX, final int chunkZ, final Runnable run) {
+        return this.mainThreadExecutor.queueRunnable(run);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final int chunkX, final int chunkZ, final Runnable run,
+                                                                 final PrioritisedExecutor.Priority priority) {
+        return this.mainThreadExecutor.queueRunnable(run, priority);
+    }
+
+    public void executeTasksUntil(final BooleanSupplier exit) {
+        if (Bukkit.isPrimaryThread()) {
+            this.mainThreadExecutor.executeConditionally(exit);
+        } else {
+            long counter = 1L;
+            while (!exit.getAsBoolean()) {
+                counter = ConcurrentUtil.linearLongBackoff(counter, 100_000L, 5_000_000L); // 100us, 5ms
+            }
+        }
+    }
+
+    public boolean halt(final boolean sync, final long maxWaitNS) {
+        this.lightExecutor.halt();
+        this.genExecutor.halt();
+        this.parallelGenExecutor.halt();
+        this.loadExecutor.halt();
+        final long time = System.nanoTime();
+        if (sync) {
+            for (long failures = 9L;; failures = ConcurrentUtil.linearLongBackoff(failures, 500_000L, 50_000_000L)) {
+                if (
+                    !this.lightExecutor.isActive() &&
+                        !this.genExecutor.isActive() &&
+                        !this.parallelGenExecutor.isActive() &&
+                        !this.loadExecutor.isActive()
+                ) {
+                    return true;
+                }
+                if ((System.nanoTime() - time) >= maxWaitNS) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    public static final ArrayDeque<ChunkInfo> WAITING_CHUNKS = new ArrayDeque<>(); // stack
+
+    public static final class ChunkInfo {
+
+        public final int chunkX;
+        public final int chunkZ;
+        public final ServerLevel world;
+
+        public ChunkInfo(final int chunkX, final int chunkZ, final ServerLevel world) {
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+            this.world = world;
+        }
+
+        @Override
+        public String toString() {
+            return "[( " + this.chunkX + "," + this.chunkZ + ") in '" + this.world.getWorld().getName() + "']";
+        }
+    }
+
+    public static void pushChunkWait(final ServerLevel world, final int chunkX, final int chunkZ) {
+        synchronized (WAITING_CHUNKS) {
+            WAITING_CHUNKS.push(new ChunkInfo(chunkX, chunkZ, world));
+        }
+    }
+
+    public static void popChunkWait() {
+        synchronized (WAITING_CHUNKS) {
+            WAITING_CHUNKS.pop();
+        }
+    }
+
+    public static ChunkInfo[] getChunkInfos() {
+        synchronized (WAITING_CHUNKS) {
+            return WAITING_CHUNKS.toArray(new ChunkInfo[0]);
+        }
+    }
+
+    public static void dumpAllChunkLoadInfo(final boolean longPrint) {
+        final ChunkInfo[] chunkInfos = getChunkInfos();
+        if (chunkInfos.length > 0) {
+            LOGGER.error("Chunk wait task info below: ");
+            for (final ChunkInfo chunkInfo : chunkInfos) {
+                final NewChunkHolder holder = chunkInfo.world.chunkTaskScheduler.chunkHolderManager.getChunkHolder(chunkInfo.chunkX, chunkInfo.chunkZ);
+                LOGGER.error("Chunk wait: " + chunkInfo);
+                LOGGER.error("Chunk holder: " + holder);
+            }
+
+            if (longPrint) {
+                final File file = new File(new File(new File("."), "debug"), "chunks-watchdog.txt");
+                LOGGER.error("Writing chunk information dump to " + file);
+                try {
+                    MCUtil.dumpChunks(file, true);
+                    LOGGER.error("Successfully written chunk information!");
+                } catch (final Throwable thr) {
+                    MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file.toString(), thr);
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkUpgradeGenericStatusTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkUpgradeGenericStatusTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..e96ecf351a1952b4e23e9a352f32d326146380e7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkUpgradeGenericStatusTask.java
@@ -0,0 +1,209 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.datafixers.util.Either;
+import com.mojang.logging.LogUtils;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerChunkCache;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+
+public final class ChunkUpgradeGenericStatusTask extends ChunkProgressionTask implements Runnable {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    protected final ChunkAccess fromChunk;
+    protected final ChunkStatus fromStatus;
+    protected final ChunkStatus toStatus;
+    protected final List<ChunkAccess> neighbours;
+
+    protected final PrioritisedExecutor.PrioritisedTask generateTask;
+
+    public ChunkUpgradeGenericStatusTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                                         final int chunkZ, final ChunkAccess chunk, final List<ChunkAccess> neighbours,
+                                         final ChunkStatus toStatus, final PrioritisedExecutor.Priority priority) {
+        super(scheduler, world, chunkX, chunkZ);
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.fromChunk = chunk;
+        this.fromStatus = chunk.getStatus();
+        this.toStatus = toStatus;
+        this.neighbours = neighbours;
+        this.generateTask = (this.toStatus.isParallelCapable ? this.scheduler.parallelGenExecutor : this.scheduler.genExecutor)
+            .createTask(this, priority);
+    }
+
+    @Override
+    public ChunkStatus getTargetStatus() {
+        return this.toStatus;
+    }
+
+    private boolean isEmptyTask() {
+        // must use fromStatus here to avoid any race condition with run() overwriting the status
+        final boolean generation = !this.fromStatus.isOrAfter(this.toStatus);
+        return (generation && this.toStatus.isEmptyGenStatus()) || (!generation && this.toStatus.isEmptyLoadStatus());
+    }
+
+    @Override
+    public void run() {
+        final ChunkAccess chunk = this.fromChunk;
+
+        final ServerChunkCache serverChunkCache = this.world.chunkSource;
+        final ChunkMap chunkMap = serverChunkCache.chunkMap;
+
+        final CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completeFuture;
+
+        final boolean generation;
+        boolean completing = false;
+
+        // note: should optimise the case where the chunk does not need to execute the status, because
+        // schedule() calls this synchronously if it will run through that path
+
+        try {
+            generation = !chunk.getStatus().isOrAfter(this.toStatus);
+            if (generation) {
+                if (this.toStatus.isEmptyGenStatus()) {
+                    if (chunk instanceof ProtoChunk) {
+                        ((ProtoChunk)chunk).setStatus(this.toStatus);
+                    }
+                    completing = true;
+                    this.complete(chunk, null);
+                    return;
+                }
+                completeFuture = this.toStatus.generate(Runnable::run, this.world, chunkMap.generator, chunkMap.structureTemplateManager,
+                    serverChunkCache.getLightEngine(), null, this.neighbours, false)
+                    .whenComplete((final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either, final Throwable throwable) -> {
+                        final ChunkAccess newChunk = (either == null) ? null : either.left().orElse(null);
+                        if (newChunk instanceof ProtoChunk) {
+                            ((ProtoChunk)newChunk).setStatus(ChunkUpgradeGenericStatusTask.this.toStatus);
+                        }
+                    }
+                );
+            } else {
+                if (this.toStatus.isEmptyLoadStatus()) {
+                    completing = true;
+                    this.complete(chunk, null);
+                    return;
+                }
+                completeFuture = this.toStatus.load(this.world, chunkMap.structureTemplateManager, serverChunkCache.getLightEngine(), null, chunk);
+            }
+        } catch (final Throwable throwable) {
+            if (!completing) {
+                this.complete(null, throwable);
+
+                if (throwable instanceof ThreadDeath) {
+                    throw (ThreadDeath)throwable;
+                }
+                return;
+            }
+
+            this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                "Target status", ChunkTaskScheduler.stringIfNull(this.toStatus),
+                "From status", ChunkTaskScheduler.stringIfNull(this.fromStatus),
+                "Generation task", this
+            ), throwable);
+
+            if (!(throwable instanceof ThreadDeath)) {
+                LOGGER.error("Failed to complete status for chunk: status:" + this.toStatus + ", chunk: (" + this.chunkX + "," + this.chunkZ + "), world: " + this.world.getWorld().getName(), throwable);
+            } else {
+                // ensure the chunk system can respond, then die
+                throw (ThreadDeath)throwable;
+            }
+            return;
+        }
+
+        if (!completeFuture.isDone() && !this.toStatus.warnedAboutNoImmediateComplete.getAndSet(true)) {
+            LOGGER.warn("Future status not complete after scheduling: " + this.toStatus.toString() + ", generate: " + generation);
+        }
+
+        final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either;
+        final ChunkAccess newChunk;
+
+        try {
+            either = completeFuture.join();
+            newChunk = (either == null) ? null : either.left().orElse(null);
+        } catch (final Throwable throwable) {
+            this.complete(null, throwable);
+            // ensure the chunk system can respond, then die
+            if (throwable instanceof ThreadDeath) {
+                throw (ThreadDeath)throwable;
+            }
+            return;
+        }
+
+        if (newChunk == null) {
+            this.complete(null, new IllegalStateException("Chunk for status: " + ChunkUpgradeGenericStatusTask.this.toStatus.toString() + ", generation: " + generation + " should not be null! Either: " + either).fillInStackTrace());
+            return;
+        }
+
+        this.complete(newChunk, null);
+    }
+
+    protected volatile boolean scheduled;
+    protected static final VarHandle SCHEDULED_HANDLE = ConcurrentUtil.getVarHandle(ChunkUpgradeGenericStatusTask.class, "scheduled", boolean.class);
+
+    @Override
+    public boolean isScheduled() {
+        return this.scheduled;
+    }
+
+    @Override
+    public void schedule() {
+        if ((boolean)SCHEDULED_HANDLE.getAndSet((ChunkUpgradeGenericStatusTask)this, true)) {
+            throw new IllegalStateException("Cannot double call schedule()");
+        }
+        if (this.isEmptyTask()) {
+            if (this.generateTask.cancel()) {
+                this.run();
+            }
+        } else {
+            this.generateTask.queue();
+        }
+    }
+
+    @Override
+    public void cancel() {
+        if (this.generateTask.cancel()) {
+            this.complete(null, null);
+        }
+    }
+
+    @Override
+    public PrioritisedExecutor.Priority getPriority() {
+        return this.generateTask.getPriority();
+    }
+
+    @Override
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.generateTask.lowerPriority(priority);
+    }
+
+    @Override
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.generateTask.setPriority(priority);
+    }
+
+    @Override
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.generateTask.raisePriority(priority);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/GenericDataLoadTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/GenericDataLoadTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..ffbfaef2a57f0f26d0143f3a8fcf937bee7e7398
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/GenericDataLoadTask.java
@@ -0,0 +1,746 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.completable.Completable;
+import ca.spottedleaf.concurrentutil.executor.Cancellable;
+import ca.spottedleaf.concurrentutil.executor.standard.DelayedPrioritisedTask;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.io.RegionFileIOThread;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ServerLevel;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.BiConsumer;
+
+public abstract class GenericDataLoadTask<OnMain,FinalCompletion> {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    protected static final CompoundTag CANCELLED_DATA = new CompoundTag();
+
+    // reference count is the upper 32 bits
+    protected final AtomicLong stageAndReferenceCount = new AtomicLong(STAGE_NOT_STARTED);
+
+    protected static final long STAGE_MASK        = 0xFFFFFFFFL;
+    protected static final long STAGE_CANCELLED   = 0xFFFFFFFFL;
+    protected static final long STAGE_NOT_STARTED = 0L;
+    protected static final long STAGE_LOADING     = 1L;
+    protected static final long STAGE_PROCESSING  = 2L;
+    protected static final long STAGE_COMPLETED   = 3L;
+
+    // for loading data off disk
+    protected final LoadDataFromDiskTask loadDataFromDiskTask;
+    // processing off-main
+    protected final PrioritisedExecutor.PrioritisedTask processOffMain;
+    // processing on-main
+    protected final PrioritisedExecutor.PrioritisedTask processOnMain;
+
+    protected final ChunkTaskScheduler scheduler;
+    protected final ServerLevel world;
+    protected final int chunkX;
+    protected final int chunkZ;
+    protected final RegionFileIOThread.RegionFileType type;
+
+    public GenericDataLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                               final int chunkZ, final RegionFileIOThread.RegionFileType type,
+                               final PrioritisedExecutor.Priority priority) {
+        this.scheduler = scheduler;
+        this.world = world;
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+        this.type = type;
+
+        final ProcessOnMainTask mainTask;
+        if (this.hasOnMain()) {
+            mainTask = new ProcessOnMainTask();
+            this.processOnMain = this.createOnMain(mainTask, priority);
+        } else {
+            mainTask = null;
+            this.processOnMain = null;
+        }
+
+        final ProcessOffMainTask offMainTask;
+        if (this.hasOffMain()) {
+            offMainTask = new ProcessOffMainTask(mainTask);
+            this.processOffMain = this.createOffMain(offMainTask, priority);
+        } else {
+            offMainTask = null;
+            this.processOffMain = null;
+        }
+
+        if (this.processOffMain == null && this.processOnMain == null) {
+            throw new IllegalStateException("Illegal class implementation: " + this.getClass().getName() + ", should be able to schedule at least one task!");
+        }
+
+        this.loadDataFromDiskTask = new LoadDataFromDiskTask(world, chunkX, chunkZ, type, new DataLoadCallback(offMainTask, mainTask), priority);
+    }
+
+    public static final record TaskResult<L, R>(L left, R right) {}
+
+    protected abstract boolean hasOffMain();
+
+    protected abstract boolean hasOnMain();
+
+    protected abstract PrioritisedExecutor.PrioritisedTask createOffMain(final Runnable run, final PrioritisedExecutor.Priority priority);
+
+    protected abstract PrioritisedExecutor.PrioritisedTask createOnMain(final Runnable run, final PrioritisedExecutor.Priority priority);
+
+    protected abstract TaskResult<OnMain, Throwable> runOffMain(final CompoundTag data, final Throwable throwable);
+
+    protected abstract TaskResult<FinalCompletion, Throwable> runOnMain(final OnMain data, final Throwable throwable);
+
+    protected abstract void onComplete(final TaskResult<FinalCompletion,Throwable> result);
+
+    protected abstract TaskResult<FinalCompletion, Throwable> completeOnMainOffMain(final OnMain data, final Throwable throwable);
+
+    @Override
+    public String toString() {
+        return "GenericDataLoadTask{class: " + this.getClass().getName() + ", world: " + this.world.getWorld().getName() +
+            ", chunk: (" + this.chunkX + "," + this.chunkZ + "), hashcode: " + System.identityHashCode(this) + ", priority: " + this.getPriority() +
+            ", type: " + this.type.toString() + "}";
+    }
+
+    public PrioritisedExecutor.Priority getPriority() {
+        if (this.processOnMain != null) {
+            return this.processOnMain.getPriority();
+        } else {
+            return this.processOffMain.getPriority();
+        }
+    }
+
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        // can't lower I/O tasks, we don't know what they affect
+        if (this.processOffMain != null) {
+            this.processOffMain.lowerPriority(priority);
+        }
+        if (this.processOnMain != null) {
+            this.processOnMain.lowerPriority(priority);
+        }
+    }
+
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        // can't lower I/O tasks, we don't know what they affect
+        this.loadDataFromDiskTask.raisePriority(priority);
+        if (this.processOffMain != null) {
+            this.processOffMain.setPriority(priority);
+        }
+        if (this.processOnMain != null) {
+            this.processOnMain.setPriority(priority);
+        }
+    }
+
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        // can't lower I/O tasks, we don't know what they affect
+        this.loadDataFromDiskTask.raisePriority(priority);
+        if (this.processOffMain != null) {
+            this.processOffMain.raisePriority(priority);
+        }
+        if (this.processOnMain != null) {
+            this.processOnMain.raisePriority(priority);
+        }
+    }
+
+    // returns whether scheduleNow() needs to be called
+    public boolean schedule(final boolean delay) {
+        if (this.stageAndReferenceCount.get() != STAGE_NOT_STARTED ||
+            !this.stageAndReferenceCount.compareAndSet(STAGE_NOT_STARTED, (1L << 32) | STAGE_LOADING)) {
+            // try and increment reference count
+            int failures = 0;
+            for (long curr = this.stageAndReferenceCount.get();;) {
+                if ((curr & STAGE_MASK) == STAGE_CANCELLED || (curr & STAGE_MASK) == STAGE_COMPLETED) {
+                    // cancelled or completed, nothing to do here
+                    return false;
+                }
+
+                if (curr == (curr = this.stageAndReferenceCount.compareAndExchange(curr, curr + (1L << 32)))) {
+                    // successful
+                    return false;
+                }
+
+                ++failures;
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.backoff();
+                }
+            }
+        }
+
+        if (!delay) {
+            this.scheduleNow();
+            return false;
+        }
+        return true;
+    }
+
+    public void scheduleNow() {
+        this.loadDataFromDiskTask.schedule(); // will schedule the rest
+    }
+
+    // assumes the current stage cannot be completed
+    // returns false if cancelled, returns true if can proceed
+    private boolean advanceStage(final long expect, final long to) {
+        int failures = 0;
+        for (long curr = this.stageAndReferenceCount.get();;) {
+            if ((curr & STAGE_MASK) != expect) {
+                // must be cancelled
+                return false;
+            }
+
+            final long newVal = (curr & ~STAGE_MASK) | to;
+            if (curr == (curr = this.stageAndReferenceCount.compareAndExchange(curr, newVal))) {
+                return true;
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public boolean cancel() {
+        int failures = 0;
+        for (long curr = this.stageAndReferenceCount.get();;) {
+            if ((curr & STAGE_MASK) == STAGE_COMPLETED || (curr & STAGE_MASK) == STAGE_CANCELLED) {
+                return false;
+            }
+
+             if ((curr & STAGE_MASK) == STAGE_NOT_STARTED || (curr & ~STAGE_MASK) == (1L << 32)) {
+                // no other references, so we can cancel
+                final long newVal = STAGE_CANCELLED;
+                if (curr == (curr = this.stageAndReferenceCount.compareAndExchange(curr, newVal))) {
+                    this.loadDataFromDiskTask.cancel();
+                    if (this.processOffMain != null) {
+                        this.processOffMain.cancel();
+                    }
+                    if (this.processOnMain != null) {
+                        this.processOnMain.cancel();
+                    }
+                    this.onComplete(null);
+                    return true;
+                }
+            } else {
+                if ((curr & ~STAGE_MASK) == (0L << 32)) {
+                    throw new IllegalStateException("Reference count cannot be zero here");
+                }
+                // just decrease the reference count
+                final long newVal = curr - (1L << 32);
+                if (curr == (curr = this.stageAndReferenceCount.compareAndExchange(curr, newVal))) {
+                    return false;
+                }
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    protected final class DataLoadCallback implements BiConsumer<CompoundTag, Throwable> {
+
+        protected final ProcessOffMainTask offMainTask;
+        protected final ProcessOnMainTask onMainTask;
+
+        public DataLoadCallback(final ProcessOffMainTask offMainTask, final ProcessOnMainTask onMainTask) {
+            this.offMainTask = offMainTask;
+            this.onMainTask = onMainTask;
+        }
+
+        @Override
+        public void accept(final CompoundTag compoundTag, final Throwable throwable) {
+            if (GenericDataLoadTask.this.stageAndReferenceCount.get() == STAGE_CANCELLED) {
+                // don't try to schedule further
+                return;
+            }
+
+            try {
+                if (compoundTag == CANCELLED_DATA) {
+                    // cancelled, except this isn't possible
+                    LOGGER.error("Data callback says cancelled, but stage does not?");
+                    return;
+                }
+
+                // get off of the regionfile callback ASAP, no clue what locks are held right now...
+                if (GenericDataLoadTask.this.processOffMain != null) {
+                    this.offMainTask.data = compoundTag;
+                    this.offMainTask.throwable = throwable;
+                    GenericDataLoadTask.this.processOffMain.queue();
+                    return;
+                } else {
+                    // no off-main task, so go straight to main
+                    this.onMainTask.data = (OnMain)compoundTag;
+                    this.onMainTask.throwable = throwable;
+                    GenericDataLoadTask.this.processOnMain.queue();
+                }
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr2) {
+                LOGGER.error("Failed I/O callback for task: " + GenericDataLoadTask.this.toString(), thr2);
+                GenericDataLoadTask.this.scheduler.unrecoverableChunkSystemFailure(
+                    GenericDataLoadTask.this.chunkX, GenericDataLoadTask.this.chunkZ, Map.of(
+                        "Callback throwable", ChunkTaskScheduler.stringIfNull(throwable)
+                    ), thr2);
+            }
+        }
+    }
+
+    protected final class ProcessOffMainTask implements Runnable {
+
+        protected CompoundTag data;
+        protected Throwable throwable;
+        protected final ProcessOnMainTask schedule;
+
+        public ProcessOffMainTask(final ProcessOnMainTask schedule) {
+            this.schedule = schedule;
+        }
+
+        @Override
+        public void run() {
+            if (!GenericDataLoadTask.this.advanceStage(STAGE_LOADING, this.schedule == null ? STAGE_COMPLETED : STAGE_PROCESSING)) {
+                // cancelled
+                return;
+            }
+            final TaskResult<OnMain, Throwable> newData = GenericDataLoadTask.this.runOffMain(this.data, this.throwable);
+
+            if (GenericDataLoadTask.this.stageAndReferenceCount.get() == STAGE_CANCELLED) {
+                // don't try to schedule further
+                return;
+            }
+
+            if (this.schedule != null) {
+                final TaskResult<FinalCompletion, Throwable> syncComplete = GenericDataLoadTask.this.completeOnMainOffMain(newData.left, newData.right);
+
+                if (syncComplete != null) {
+                    if (GenericDataLoadTask.this.advanceStage(STAGE_PROCESSING, STAGE_COMPLETED)) {
+                        GenericDataLoadTask.this.onComplete(syncComplete);
+                    } // else: cancelled
+                    return;
+                }
+
+                this.schedule.data = newData.left;
+                this.schedule.throwable = newData.right;
+
+                GenericDataLoadTask.this.processOnMain.queue();
+            } else {
+                GenericDataLoadTask.this.onComplete((TaskResult<FinalCompletion, Throwable>)newData);
+            }
+        }
+    }
+
+    protected final class ProcessOnMainTask implements Runnable {
+
+        protected OnMain data;
+        protected Throwable throwable;
+
+        @Override
+        public void run() {
+            if (!GenericDataLoadTask.this.advanceStage(STAGE_PROCESSING, STAGE_COMPLETED)) {
+                // cancelled
+                return;
+            }
+            final TaskResult<FinalCompletion, Throwable> result = GenericDataLoadTask.this.runOnMain(this.data, this.throwable);
+
+            GenericDataLoadTask.this.onComplete(result);
+        }
+    }
+
+    public static final class LoadDataFromDiskTask {
+
+        protected volatile int priority;
+        protected static final VarHandle PRIORITY_HANDLE = ConcurrentUtil.getVarHandle(LoadDataFromDiskTask.class, "priority", int.class);
+
+        protected static final int PRIORITY_EXECUTED         = Integer.MIN_VALUE >>> 0;
+        protected static final int PRIORITY_LOAD_SCHEDULED   = Integer.MIN_VALUE >>> 1;
+        protected static final int PRIORITY_UNLOAD_SCHEDULED = Integer.MIN_VALUE >>> 2;
+
+        protected static final int PRIORITY_FLAGS = ~Character.MAX_VALUE;
+
+        protected final int getPriorityVolatile() {
+            return (int)PRIORITY_HANDLE.getVolatile((LoadDataFromDiskTask)this);
+        }
+
+        protected final int compareAndExchangePriorityVolatile(final int expect, final int update) {
+            return (int)PRIORITY_HANDLE.compareAndExchange((LoadDataFromDiskTask)this, (int)expect, (int)update);
+        }
+
+        protected final int getAndOrPriorityVolatile(final int val) {
+            return (int)PRIORITY_HANDLE.getAndBitwiseOr((LoadDataFromDiskTask)this, (int)val);
+        }
+
+        protected final void setPriorityPlain(final int val) {
+            PRIORITY_HANDLE.set((LoadDataFromDiskTask)this, (int)val);
+        }
+
+        private final ServerLevel world;
+        private final int chunkX;
+        private final int chunkZ;
+
+        private final RegionFileIOThread.RegionFileType type;
+        private Cancellable dataLoadTask;
+        private Cancellable dataUnloadCancellable;
+        private DelayedPrioritisedTask dataUnloadTask;
+
+        private final BiConsumer<CompoundTag, Throwable> onComplete;
+
+        // onComplete should be caller sensitive, it may complete synchronously with schedule() - which does
+        // hold a priority lock.
+        public LoadDataFromDiskTask(final ServerLevel world, final int chunkX, final int chunkZ,
+                                    final RegionFileIOThread.RegionFileType type,
+                                    final BiConsumer<CompoundTag, Throwable> onComplete,
+                                    final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+            this.world = world;
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+            this.type = type;
+            this.onComplete = onComplete;
+            this.setPriorityPlain(priority.priority);
+        }
+
+        private void complete(final CompoundTag data, final Throwable throwable) {
+            try {
+                this.onComplete.accept(data, throwable);
+            } catch (final Throwable thr2) {
+                this.world.chunkTaskScheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                    "Completed throwable", ChunkTaskScheduler.stringIfNull(throwable),
+                    "Regionfile type", ChunkTaskScheduler.stringIfNull(this.type)
+                ), thr2);
+                if (thr2 instanceof ThreadDeath) {
+                    throw (ThreadDeath)thr2;
+                }
+            }
+        }
+
+        protected boolean markExecuting() {
+            return (this.getAndOrPriorityVolatile(PRIORITY_EXECUTED) & PRIORITY_EXECUTED) == 0;
+        }
+
+        protected boolean isMarkedExecuted() {
+            return (this.getPriorityVolatile() & PRIORITY_EXECUTED) != 0;
+        }
+
+        public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+
+            int failures = 0;
+            for (int curr = this.getPriorityVolatile();;) {
+                if ((curr & PRIORITY_EXECUTED) != 0) {
+                    // cancelled or executed
+                    return;
+                }
+
+                if ((curr & PRIORITY_LOAD_SCHEDULED) != 0) {
+                    RegionFileIOThread.lowerPriority(this.world, this.chunkX, this.chunkZ, this.type, priority);
+                    return;
+                }
+
+                if ((curr & PRIORITY_UNLOAD_SCHEDULED) != 0) {
+                    if (this.dataUnloadTask != null) {
+                        this.dataUnloadTask.lowerPriority(priority);
+                    }
+                    // no return - we need to propagate priority
+                }
+
+                if (!priority.isHigherPriority(curr & ~PRIORITY_FLAGS)) {
+                    return;
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority | (curr & PRIORITY_FLAGS)))) {
+                    return;
+                }
+
+                // failed, retry
+
+                ++failures;
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.backoff();
+                }
+            }
+        }
+
+        public void setPriority(final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+
+            int failures = 0;
+            for (int curr = this.getPriorityVolatile();;) {
+                if ((curr & PRIORITY_EXECUTED) != 0) {
+                    // cancelled or executed
+                    return;
+                }
+
+                if ((curr & PRIORITY_LOAD_SCHEDULED) != 0) {
+                    RegionFileIOThread.setPriority(this.world, this.chunkX, this.chunkZ, this.type, priority);
+                    return;
+                }
+
+                if ((curr & PRIORITY_UNLOAD_SCHEDULED) != 0) {
+                    if (this.dataUnloadTask != null) {
+                        this.dataUnloadTask.setPriority(priority);
+                    }
+                    // no return - we need to propagate priority
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority | (curr & PRIORITY_FLAGS)))) {
+                    return;
+                }
+
+                // failed, retry
+
+                ++failures;
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.backoff();
+                }
+            }
+        }
+
+        public void raisePriority(final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+
+            int failures = 0;
+            for (int curr = this.getPriorityVolatile();;) {
+                if ((curr & PRIORITY_EXECUTED) != 0) {
+                    // cancelled or executed
+                    return;
+                }
+
+                if ((curr & PRIORITY_LOAD_SCHEDULED) != 0) {
+                    RegionFileIOThread.raisePriority(this.world, this.chunkX, this.chunkZ, this.type, priority);
+                    return;
+                }
+
+                if ((curr & PRIORITY_UNLOAD_SCHEDULED) != 0) {
+                    if (this.dataUnloadTask != null) {
+                        this.dataUnloadTask.raisePriority(priority);
+                    }
+                    // no return - we need to propagate priority
+                }
+
+                if (!priority.isLowerPriority(curr & ~PRIORITY_FLAGS)) {
+                    return;
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority | (curr & PRIORITY_FLAGS)))) {
+                    return;
+                }
+
+                // failed, retry
+
+                ++failures;
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.backoff();
+                }
+            }
+        }
+
+        public void cancel() {
+            if ((this.getAndOrPriorityVolatile(PRIORITY_EXECUTED) & PRIORITY_EXECUTED) != 0) {
+                // cancelled or executed already
+                return;
+            }
+
+            // OK if we miss the field read, the task cannot complete if the cancelled bit is set and
+            // the write to dataLoadTask will check for the cancelled bit
+            if (this.dataUnloadCancellable != null) {
+                this.dataUnloadCancellable.cancel();
+            }
+
+            if (this.dataLoadTask != null) {
+                this.dataLoadTask.cancel();
+            }
+
+            this.complete(CANCELLED_DATA, null);
+        }
+
+        private final AtomicBoolean scheduled = new AtomicBoolean();
+
+        public void schedule() {
+            if (this.scheduled.getAndSet(true)) {
+                throw new IllegalStateException("schedule() called twice");
+            }
+            int priority = this.getPriorityVolatile();
+
+            if ((priority & PRIORITY_EXECUTED) != 0) {
+                // cancelled
+                return;
+            }
+
+            final BiConsumer<CompoundTag, Throwable> consumer = (final CompoundTag data, final Throwable thr) -> {
+                // because cancelScheduled() cannot actually stop this task from executing in every case, we need
+                // to mark complete here to ensure we do not double complete
+                if (LoadDataFromDiskTask.this.markExecuting()) {
+                    LoadDataFromDiskTask.this.complete(data, thr);
+                } // else: cancelled
+            };
+
+            final PrioritisedExecutor.Priority initialPriority = PrioritisedExecutor.Priority.getPriority(priority);
+            boolean scheduledUnload = false;
+
+            final NewChunkHolder holder = this.world.chunkTaskScheduler.chunkHolderManager.getChunkHolder(this.chunkX, this.chunkZ);
+            if (holder != null) {
+                final BiConsumer<CompoundTag, Throwable> unloadConsumer = (final CompoundTag data, final Throwable thr) -> {
+                    if (data != null) {
+                        consumer.accept(data, null);
+                    } else {
+                        // need to schedule task
+                        LoadDataFromDiskTask.this.schedule(false, consumer, PrioritisedExecutor.Priority.getPriority(LoadDataFromDiskTask.this.getPriorityVolatile() & ~PRIORITY_FLAGS));
+                    }
+                };
+                Cancellable unloadCancellable = null;
+                CompoundTag syncComplete = null;
+                final NewChunkHolder.UnloadTask unloadTask = holder.getUnloadTask(this.type); // can be null if no task exists
+                final Completable<CompoundTag> unloadCompletable = unloadTask == null ? null : unloadTask.completable();
+                if (unloadCompletable != null) {
+                    unloadCancellable = unloadCompletable.addAsynchronousWaiter(unloadConsumer);
+                    if (unloadCancellable == null) {
+                        syncComplete = unloadCompletable.getResult();
+                    }
+                }
+
+                if (syncComplete != null) {
+                    consumer.accept(syncComplete, null);
+                    return;
+                }
+
+                if (unloadCancellable != null) {
+                    scheduledUnload = true;
+                    this.dataUnloadCancellable = unloadCancellable;
+                    this.dataUnloadTask = unloadTask.task();
+                }
+            }
+
+            this.schedule(scheduledUnload, consumer, initialPriority);
+        }
+
+        private void schedule(final boolean scheduledUnload, final BiConsumer<CompoundTag, Throwable> consumer, final PrioritisedExecutor.Priority initialPriority) {
+            int priority = this.getPriorityVolatile();
+
+            if ((priority & PRIORITY_EXECUTED) != 0) {
+                // cancelled
+                return;
+            }
+
+            if (!scheduledUnload) {
+                this.dataLoadTask = RegionFileIOThread.loadDataAsync(
+                    this.world, this.chunkX, this.chunkZ, this.type, consumer,
+                    initialPriority.isHigherPriority(PrioritisedExecutor.Priority.NORMAL), initialPriority
+                );
+            }
+
+            int failures = 0;
+            for (;;) {
+                if (priority == (priority = this.compareAndExchangePriorityVolatile(priority, priority | (scheduledUnload ? PRIORITY_UNLOAD_SCHEDULED : PRIORITY_LOAD_SCHEDULED)))) {
+                    return;
+                }
+
+                if ((priority & PRIORITY_EXECUTED) != 0) {
+                    // cancelled or executed
+                    if (this.dataUnloadCancellable != null) {
+                        this.dataUnloadCancellable.cancel();
+                    }
+
+                    if (this.dataLoadTask != null) {
+                        this.dataLoadTask.cancel();
+                    }
+                    return;
+                }
+
+                if (scheduledUnload) {
+                    if (this.dataUnloadTask != null) {
+                        this.dataUnloadTask.setPriority(PrioritisedExecutor.Priority.getPriority(priority & ~PRIORITY_FLAGS));
+                    }
+                } else {
+                    RegionFileIOThread.setPriority(this.world, this.chunkX, this.chunkZ, this.type, PrioritisedExecutor.Priority.getPriority(priority & ~PRIORITY_FLAGS));
+                }
+
+                ++failures;
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.backoff();
+                }
+            }
+        }
+
+        /*
+        private static final class LoadDataPriorityHolder extends PriorityHolder {
+
+            protected final LoadDataFromDiskTask task;
+
+            protected LoadDataPriorityHolder(final PrioritisedExecutor.Priority priority, final LoadDataFromDiskTask task) {
+                super(priority);
+                this.task = task;
+            }
+
+            @Override
+            protected void cancelScheduled() {
+                final Cancellable dataLoadTask = this.task.dataLoadTask;
+                if (dataLoadTask != null) {
+                    // OK if we miss the field read, the task cannot complete if the cancelled bit is set and
+                    // the write to dataLoadTask will check for the cancelled bit
+                    this.task.dataLoadTask.cancel();
+                }
+                this.task.complete(CANCELLED_DATA, null);
+            }
+
+            @Override
+            protected PrioritisedExecutor.Priority getScheduledPriority() {
+                final LoadDataFromDiskTask task = this.task;
+                return RegionFileIOThread.getPriority(task.world, task.chunkX, task.chunkZ, task.type);
+            }
+
+            @Override
+            protected void scheduleTask(final PrioritisedExecutor.Priority priority) {
+                final LoadDataFromDiskTask task = this.task;
+                final BiConsumer<CompoundTag, Throwable> consumer = (final CompoundTag data, final Throwable thr) -> {
+                    // because cancelScheduled() cannot actually stop this task from executing in every case, we need
+                    // to mark complete here to ensure we do not double complete
+                    if (LoadDataPriorityHolder.this.markExecuting()) {
+                        LoadDataPriorityHolder.this.task.complete(data, thr);
+                    } // else: cancelled
+                };
+                task.dataLoadTask = RegionFileIOThread.loadDataAsync(
+                    task.world, task.chunkX, task.chunkZ, task.type, consumer,
+                    priority.isHigherPriority(PrioritisedExecutor.Priority.NORMAL), priority
+                );
+                if (this.isMarkedExecuted()) {
+                    // if we are marked as completed, it could be:
+                    // 1. we were cancelled
+                    // 2. the consumer was completed
+                    // in the 2nd case, cancel() does nothing
+                    // in the 1st case, we ensure cancel() is called as it is possible for the cancelling thread
+                    // to miss the field write here
+                    task.dataLoadTask.cancel();
+                }
+            }
+
+            @Override
+            protected void lowerPriorityScheduled(final PrioritisedExecutor.Priority priority) {
+                final LoadDataFromDiskTask task = this.task;
+                RegionFileIOThread.lowerPriority(task.world, task.chunkX, task.chunkZ, task.type, priority);
+            }
+
+            @Override
+            protected void setPriorityScheduled(final PrioritisedExecutor.Priority priority) {
+                final LoadDataFromDiskTask task = this.task;
+                RegionFileIOThread.setPriority(task.world, task.chunkX, task.chunkZ, task.type, priority);
+            }
+
+            @Override
+            protected void raisePriorityScheduled(final PrioritisedExecutor.Priority priority) {
+                final LoadDataFromDiskTask task = this.task;
+                RegionFileIOThread.raisePriority(task.world, task.chunkX, task.chunkZ, task.type, priority);
+            }
+        }
+         */
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a4ec0f1fb3bac0e84e6bd3aaeb77f44e248aadb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -0,0 +1,2071 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.completable.Completable;
+import ca.spottedleaf.concurrentutil.executor.Cancellable;
+import ca.spottedleaf.concurrentutil.executor.standard.DelayedPrioritisedTask;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.io.RegionFileIOThread;
+import io.papermc.paper.chunk.system.poi.PoiChunk;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import io.papermc.paper.util.WorldUtil;
+import io.papermc.paper.world.ChunkEntitySlices;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.TicketType;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import net.minecraft.world.level.chunk.storage.EntityStorage;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+
+public final class NewChunkHolder {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    public static final Thread.UncaughtExceptionHandler CHUNKSYSTEM_UNCAUGHT_EXCEPTION_HANDLER = new Thread.UncaughtExceptionHandler() {
+        @Override
+        public void uncaughtException(final Thread thread, final Throwable throwable) {
+            if (!(throwable instanceof ThreadDeath)) {
+                LOGGER.error("Uncaught exception in thread " + thread.getName(), throwable);
+            }
+        }
+    };
+
+    public final ServerLevel world;
+    public final int chunkX;
+    public final int chunkZ;
+
+    public final ChunkTaskScheduler scheduler;
+
+    // load/unload state
+
+    // chunk data state
+
+    private ChunkEntitySlices entityChunk;
+    // entity chunk that is loaded, but not yet deserialized
+    private CompoundTag pendingEntityChunk;
+
+    ChunkEntitySlices loadInEntityChunk(final boolean transientChunk) {
+        TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot sync load entity data off-main");
+        final CompoundTag entityChunk;
+        final ChunkEntitySlices ret;
+        this.scheduler.schedulingLock.lock();
+        try {
+            if (this.entityChunk != null && (transientChunk || !this.entityChunk.isTransient())) {
+                return this.entityChunk;
+            }
+            final CompoundTag pendingEntityChunk = this.pendingEntityChunk;
+            if (!transientChunk && pendingEntityChunk == null) {
+                throw new IllegalStateException("Must load entity data from disk before loading in the entity chunk!");
+            }
+
+            if (this.entityChunk == null) {
+                ret = this.entityChunk = new ChunkEntitySlices(
+                    this.world, this.chunkX, this.chunkZ, this.getChunkStatus(),
+                    WorldUtil.getMinSection(this.world), WorldUtil.getMaxSection(this.world)
+                );
+
+                ret.setTransient(transientChunk);
+
+                this.world.getEntityLookup().entitySectionLoad(this.chunkX, this.chunkZ, ret);
+            } else {
+                // transientChunk = false here
+                ret = this.entityChunk;
+                this.entityChunk.setTransient(false);
+            }
+
+            if (!transientChunk) {
+                this.pendingEntityChunk = null;
+                entityChunk = pendingEntityChunk == EMPTY_ENTITY_CHUNK ? null : pendingEntityChunk;
+            } else {
+                entityChunk = null;
+            }
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+
+        if (!transientChunk) {
+            if (entityChunk != null) {
+                final List<Entity> entities = EntityStorage.readEntities(this.world, entityChunk);
+
+                this.world.getEntityLookup().addEntityChunkEntities(entities);
+            }
+        }
+
+        return ret;
+    }
+
+    // needed to distinguish whether the entity chunk has been read from disk but is empty or whether it has _not_
+    // been read from disk
+    private static final CompoundTag EMPTY_ENTITY_CHUNK = new CompoundTag();
+
+    private ChunkLoadTask.EntityDataLoadTask entityDataLoadTask;
+    // note: if entityDataLoadTask is cancelled, but on its completion entityDataLoadTaskWaiters.size() != 0,
+    // then the task is rescheduled
+    private List<GenericDataLoadTaskCallback> entityDataLoadTaskWaiters;
+
+    public ChunkLoadTask.EntityDataLoadTask getEntityDataLoadTask() {
+        return this.entityDataLoadTask;
+    }
+
+    // must hold schedule lock for the two below functions
+
+    // returns only if the data has been loaded from disk, DOES NOT relate to whether it has been deserialized
+    // or added into the world (or even into entityChunk)
+    public boolean isEntityChunkNBTLoaded() {
+        return (this.entityChunk != null && !this.entityChunk.isTransient()) || this.pendingEntityChunk != null;
+    }
+
+    private void completeEntityLoad(final GenericDataLoadTask.TaskResult<CompoundTag, Throwable> result) {
+        final List<GenericDataLoadTaskCallback> completeWaiters;
+        ChunkLoadTask.EntityDataLoadTask entityDataLoadTask = null;
+        boolean scheduleEntityTask = false;
+        this.scheduler.schedulingLock.lock();
+        try {
+            final List<GenericDataLoadTaskCallback> waiters = this.entityDataLoadTaskWaiters;
+            this.entityDataLoadTask = null;
+            if (result != null) {
+                this.entityDataLoadTaskWaiters = null;
+                this.pendingEntityChunk = result.left() == null ? EMPTY_ENTITY_CHUNK : result.left();
+                if (result.right() != null) {
+                    LOGGER.error("Unhandled entity data load exception, data data will be lost: ", result.right());
+                }
+
+                completeWaiters = waiters;
+            } else {
+                // cancelled
+                completeWaiters = null;
+
+                // need to re-schedule?
+                if (waiters.isEmpty()) {
+                    this.entityDataLoadTaskWaiters = null;
+                    // no tasks to schedule _for_
+                } else {
+                    entityDataLoadTask = this.entityDataLoadTask = new ChunkLoadTask.EntityDataLoadTask(
+                        this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority()
+                    );
+                    entityDataLoadTask.addCallback(this::completeEntityLoad);
+                    // need one schedule() per waiter
+                    for (final GenericDataLoadTaskCallback callback : waiters) {
+                        scheduleEntityTask |= entityDataLoadTask.schedule(true);
+                    }
+                }
+            }
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+
+        if (scheduleEntityTask) {
+            entityDataLoadTask.scheduleNow();
+        }
+
+        // avoid holding the scheduling lock while completing
+        if (completeWaiters != null) {
+            for (final GenericDataLoadTaskCallback callback : completeWaiters) {
+                callback.accept(result);
+            }
+        }
+
+        this.scheduler.schedulingLock.lock();
+        try {
+            this.checkUnload();
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+    }
+
+    // note: it is guaranteed that the consumer cannot be called for the entirety that the schedule lock is held
+    // however, when the consumer is invoked, it will hold the schedule lock
+    public GenericDataLoadTaskCallback getOrLoadEntityData(final Consumer<GenericDataLoadTask.TaskResult<CompoundTag, Throwable>> consumer) {
+        if (this.isEntityChunkNBTLoaded()) {
+            throw new IllegalStateException("Cannot load entity data, it is already loaded");
+        }
+        // why not just acquire the lock? because the caller NEEDS to call isEntityChunkNBTLoaded before this!
+        if (!this.scheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Must hold scheduling lock");
+        }
+
+        final GenericDataLoadTaskCallback ret = new EntityDataLoadTaskCallback((Consumer)consumer, this);
+
+        if (this.entityDataLoadTask == null) {
+            this.entityDataLoadTask = new ChunkLoadTask.EntityDataLoadTask(
+                this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority()
+            );
+            this.entityDataLoadTask.addCallback(this::completeEntityLoad);
+            this.entityDataLoadTaskWaiters = new ArrayList<>();
+        }
+        this.entityDataLoadTaskWaiters.add(ret);
+        if (this.entityDataLoadTask.schedule(true)) {
+            ret.schedule = this.entityDataLoadTask;
+        }
+        this.checkUnload();
+
+        return ret;
+    }
+
+    private static final class EntityDataLoadTaskCallback extends GenericDataLoadTaskCallback {
+
+        public EntityDataLoadTaskCallback(final Consumer<GenericDataLoadTask.TaskResult<?, Throwable>> consumer, final NewChunkHolder chunkHolder) {
+            super(consumer, chunkHolder);
+        }
+
+        @Override
+        void internalCancel() {
+            this.chunkHolder.entityDataLoadTaskWaiters.remove(this);
+            this.chunkHolder.entityDataLoadTask.cancel();
+        }
+    }
+
+    private PoiChunk poiChunk;
+
+    private ChunkLoadTask.PoiDataLoadTask poiDataLoadTask;
+    // note: if entityDataLoadTask is cancelled, but on its completion entityDataLoadTaskWaiters.size() != 0,
+    // then the task is rescheduled
+    private List<GenericDataLoadTaskCallback> poiDataLoadTaskWaiters;
+
+    public ChunkLoadTask.PoiDataLoadTask getPoiDataLoadTask() {
+        return this.poiDataLoadTask;
+    }
+
+    // must hold schedule lock for the two below functions
+
+    public boolean isPoiChunkLoaded() {
+        return this.poiChunk != null;
+    }
+
+    private void completePoiLoad(final GenericDataLoadTask.TaskResult<PoiChunk, Throwable> result) {
+        final List<GenericDataLoadTaskCallback> completeWaiters;
+        ChunkLoadTask.PoiDataLoadTask poiDataLoadTask = null;
+        boolean schedulePoiTask = false;
+        this.scheduler.schedulingLock.lock();
+        try {
+            final List<GenericDataLoadTaskCallback> waiters = this.poiDataLoadTaskWaiters;
+            this.poiDataLoadTask = null;
+            if (result != null) {
+                this.poiDataLoadTaskWaiters = null;
+                this.poiChunk = result.left();
+                if (result.right() != null) {
+                    LOGGER.error("Unhandled poi load exception, poi data will be lost: ", result.right());
+                }
+
+                completeWaiters = waiters;
+            } else {
+                // cancelled
+                completeWaiters = null;
+
+                // need to re-schedule?
+                if (waiters.isEmpty()) {
+                    this.poiDataLoadTaskWaiters = null;
+                    // no tasks to schedule _for_
+                } else {
+                    poiDataLoadTask = this.poiDataLoadTask = new ChunkLoadTask.PoiDataLoadTask(
+                        this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority()
+                    );
+                    poiDataLoadTask.addCallback(this::completePoiLoad);
+                    // need one schedule() per waiter
+                    for (final GenericDataLoadTaskCallback callback : waiters) {
+                        schedulePoiTask |= poiDataLoadTask.schedule(true);
+                    }
+                }
+            }
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+
+        if (schedulePoiTask) {
+            poiDataLoadTask.scheduleNow();
+        }
+
+        // avoid holding the scheduling lock while completing
+        if (completeWaiters != null) {
+            for (final GenericDataLoadTaskCallback callback : completeWaiters) {
+                callback.accept(result);
+            }
+        }
+        this.scheduler.schedulingLock.lock();
+        try {
+            this.checkUnload();
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+    }
+
+    // note: it is guaranteed that the consumer cannot be called for the entirety that the schedule lock is held
+    // however, when the consumer is invoked, it will hold the schedule lock
+    public GenericDataLoadTaskCallback getOrLoadPoiData(final Consumer<GenericDataLoadTask.TaskResult<PoiChunk, Throwable>> consumer) {
+        if (this.isPoiChunkLoaded()) {
+            throw new IllegalStateException("Cannot load poi data, it is already loaded");
+        }
+        // why not just acquire the lock? because the caller NEEDS to call isPoiChunkLoaded before this!
+        if (!this.scheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Must hold scheduling lock");
+        }
+
+        final GenericDataLoadTaskCallback ret = new PoiDataLoadTaskCallback((Consumer)consumer, this);
+
+        if (this.poiDataLoadTask == null) {
+            this.poiDataLoadTask = new ChunkLoadTask.PoiDataLoadTask(
+                this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority()
+            );
+            this.poiDataLoadTask.addCallback(this::completePoiLoad);
+            this.poiDataLoadTaskWaiters = new ArrayList<>();
+        }
+        this.poiDataLoadTaskWaiters.add(ret);
+        if (this.poiDataLoadTask.schedule(true)) {
+            ret.schedule = this.poiDataLoadTask;
+        }
+        this.checkUnload();
+
+        return ret;
+    }
+
+    private static final class PoiDataLoadTaskCallback extends GenericDataLoadTaskCallback {
+
+        public PoiDataLoadTaskCallback(final Consumer<GenericDataLoadTask.TaskResult<?, Throwable>> consumer, final NewChunkHolder chunkHolder) {
+            super(consumer, chunkHolder);
+        }
+
+        @Override
+        void internalCancel() {
+            this.chunkHolder.poiDataLoadTaskWaiters.remove(this);
+            this.chunkHolder.poiDataLoadTask.cancel();
+        }
+    }
+
+    public static abstract class GenericDataLoadTaskCallback implements Cancellable, Consumer<GenericDataLoadTask.TaskResult<?, Throwable>> {
+
+        protected final Consumer<GenericDataLoadTask.TaskResult<?, Throwable>> consumer;
+        protected final NewChunkHolder chunkHolder;
+        protected boolean completed;
+        protected GenericDataLoadTask<?, ?> schedule;
+        protected final AtomicBoolean scheduled = new AtomicBoolean();
+
+        public GenericDataLoadTaskCallback(final Consumer<GenericDataLoadTask.TaskResult<?, Throwable>> consumer,
+                                           final NewChunkHolder chunkHolder) {
+            this.consumer = consumer;
+            this.chunkHolder = chunkHolder;
+        }
+
+        public void schedule() {
+            if (this.scheduled.getAndSet(true)) {
+                throw new IllegalStateException("Double calling schedule()");
+            }
+            if (this.schedule != null) {
+                this.schedule.scheduleNow();
+                this.schedule = null;
+            }
+        }
+
+        boolean isCompleted() {
+            return this.completed;
+        }
+
+        // must hold scheduling lock
+        private boolean setCompleted() {
+            if (this.completed) {
+                return false;
+            }
+            return this.completed = true;
+        }
+
+        @Override
+        public void accept(final GenericDataLoadTask.TaskResult<?, Throwable> result) {
+            if (result != null) {
+                if (this.setCompleted()) {
+                    this.consumer.accept(result);
+                } else {
+                    throw new IllegalStateException("Cannot be cancelled at this point");
+                }
+            } else {
+                throw new NullPointerException("Result cannot be null (cancelled)");
+            }
+        }
+
+        // holds scheduling lock
+        abstract void internalCancel();
+
+        @Override
+        public boolean cancel() {
+            this.chunkHolder.scheduler.schedulingLock.lock();
+            try {
+                if (!this.completed) {
+                    this.completed = true;
+                    this.internalCancel();
+                    return true;
+                }
+                return false;
+            } finally {
+                this.chunkHolder.scheduler.schedulingLock.unlock();
+            }
+        }
+    }
+
+    private ChunkAccess currentChunk;
+
+    // generation status state
+
+    /**
+     * Current status the chunk has been brought up to by the chunk system. null indicates no work at all
+     */
+    private ChunkStatus currentGenStatus;
+
+    // This allows unsynchronised access to the chunk and last gen status
+    private volatile ChunkCompletion lastChunkCompletion;
+
+    public ChunkCompletion getLastChunkCompletion() {
+        return this.lastChunkCompletion;
+    }
+
+    public static final record ChunkCompletion(ChunkAccess chunk, ChunkStatus genStatus) {};
+
+    /**
+     * The target final chunk status the chunk system will bring the chunk to.
+     */
+    private ChunkStatus requestedGenStatus;
+
+    private ChunkProgressionTask generationTask;
+    private ChunkStatus generationTaskStatus;
+
+    /**
+     * contains the neighbours that this chunk generation is blocking on
+     */
+    protected final ReferenceLinkedOpenHashSet<NewChunkHolder> neighboursBlockingGenTask = new ReferenceLinkedOpenHashSet<>(4);
+
+    /**
+     * map of ChunkHolder -> Required Status for this chunk
+     */
+    protected final Reference2ObjectLinkedOpenHashMap<NewChunkHolder, ChunkStatus> neighboursWaitingForUs = new Reference2ObjectLinkedOpenHashMap<>();
+
+    public void addGenerationBlockingNeighbour(final NewChunkHolder neighbour) {
+        this.neighboursBlockingGenTask.add(neighbour);
+    }
+
+    public void addWaitingNeighbour(final NewChunkHolder neighbour, final ChunkStatus requiredStatus) {
+        final boolean wasEmpty = this.neighboursWaitingForUs.isEmpty();
+        this.neighboursWaitingForUs.put(neighbour, requiredStatus);
+        if (wasEmpty) {
+            this.checkUnload();
+        }
+    }
+
+    // priority state
+
+    // the target priority for this chunk to generate at
+    // TODO this will screw over scheduling at lower priorities to neighbours, fix
+    private PrioritisedExecutor.Priority priority = PrioritisedExecutor.Priority.NORMAL;
+    private boolean priorityLocked;
+
+    // the priority neighbouring chunks have requested this chunk generate at
+    private PrioritisedExecutor.Priority neighbourRequestedPriority = PrioritisedExecutor.Priority.IDLE;
+
+    public PrioritisedExecutor.Priority getEffectivePriority() {
+        return PrioritisedExecutor.Priority.max(this.priority, this.neighbourRequestedPriority);
+    }
+
+    protected void recalculateNeighbourRequestedPriority() {
+        if (this.neighboursWaitingForUs.isEmpty()) {
+            this.neighbourRequestedPriority = PrioritisedExecutor.Priority.IDLE;
+            return;
+        }
+
+        PrioritisedExecutor.Priority max = PrioritisedExecutor.Priority.IDLE;
+
+        for (final NewChunkHolder holder : this.neighboursWaitingForUs.keySet()) {
+            final PrioritisedExecutor.Priority neighbourPriority = holder.getEffectivePriority();
+            if (neighbourPriority.isHigherPriority(max)) {
+                max = neighbourPriority;
+            }
+        }
+
+        final PrioritisedExecutor.Priority current = this.getEffectivePriority();
+        this.neighbourRequestedPriority = max;
+        final PrioritisedExecutor.Priority next = this.getEffectivePriority();
+
+        if (current == next) {
+            return;
+        }
+
+        // our effective priority has changed, so change our task
+        if (this.generationTask != null) {
+            this.generationTask.setPriority(next);
+        }
+
+        // now propagate this to our neighbours
+        this.recalculateNeighbourPriorities();
+    }
+
+    public void recalculateNeighbourPriorities() {
+        for (final NewChunkHolder holder : this.neighboursBlockingGenTask) {
+            holder.recalculateNeighbourRequestedPriority();
+        }
+    }
+
+    // must hold scheduling lock
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        if (this.priority != null && this.priority.isHigherOrEqualPriority(priority)) {
+            return;
+        }
+        this.setPriority(priority);
+    }
+
+    private void lockPriority() {
+        this.priority = PrioritisedExecutor.Priority.NORMAL;
+        this.priorityLocked = true;
+    }
+
+    // must hold scheduling lock
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        if (this.priorityLocked) {
+            return;
+        }
+        final PrioritisedExecutor.Priority old = this.getEffectivePriority();
+        this.priority = priority;
+        final PrioritisedExecutor.Priority newPriority = this.getEffectivePriority();
+
+        if (old != newPriority) {
+            if (this.generationTask != null) {
+                this.generationTask.setPriority(newPriority);
+            }
+        }
+
+        this.recalculateNeighbourPriorities();
+    }
+
+    // must hold scheduling lock
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        if (this.priority != null && this.priority.isLowerOrEqualPriority(priority)) {
+            return;
+        }
+        this.setPriority(priority);
+    }
+
+    // error handling state
+    private ChunkStatus failedGenStatus;
+    private Throwable genTaskException;
+    private Thread genTaskFailedThread;
+
+    private boolean failedLightUpdate;
+
+    public void failedLightUpdate() {
+        this.failedLightUpdate = true;
+    }
+
+    public boolean hasFailedGeneration() {
+        return this.genTaskException != null;
+    }
+
+    // ticket level state
+    private int oldTicketLevel = ChunkMap.MAX_CHUNK_DISTANCE + 1;
+    private int currentTicketLevel = ChunkMap.MAX_CHUNK_DISTANCE + 1;
+
+    public int getTicketLevel() {
+        return this.currentTicketLevel;
+    }
+
+    public final ChunkHolder vanillaChunkHolder;
+
+    public NewChunkHolder(final ServerLevel world, final int chunkX, final int chunkZ, final ChunkTaskScheduler scheduler) {
+        this.world = world;
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+        this.scheduler = scheduler;
+        this.vanillaChunkHolder = new ChunkHolder(new ChunkPos(chunkX, chunkZ), world, world.getLightEngine(), world.chunkSource.chunkMap, this);
+    }
+
+    protected ImposterProtoChunk wrappedChunkForNeighbour;
+
+    // holds scheduling lock
+    public ChunkAccess getChunkForNeighbourAccess() {
+        // Vanilla overrides the status futures with an imposter chunk to prevent writes to full chunks
+        // But we don't store per-status futures, so we need this hack
+        if (this.wrappedChunkForNeighbour != null) {
+            return this.wrappedChunkForNeighbour;
+        }
+        final ChunkAccess ret = this.currentChunk;
+        return ret instanceof LevelChunk fullChunk ? this.wrappedChunkForNeighbour = new ImposterProtoChunk(fullChunk, false) : ret;
+    }
+
+    public ChunkAccess getCurrentChunk() {
+        return this.currentChunk;
+    }
+
+    int getCurrentTicketLevel() {
+        return this.currentTicketLevel;
+    }
+
+    void updateTicketLevel(final int toLevel) {
+        this.currentTicketLevel = toLevel;
+    }
+
+    private int totalNeighboursUsingThisChunk = 0;
+
+    // holds schedule lock
+    public void addNeighbourUsingChunk() {
+        final int now = ++this.totalNeighboursUsingThisChunk;
+
+        if (now == 1) {
+            this.checkUnload();
+        }
+    }
+
+    // holds schedule lock
+    public void removeNeighbourUsingChunk() {
+        final int now = --this.totalNeighboursUsingThisChunk;
+
+        if (now == 0) {
+            this.checkUnload();
+        }
+
+        if (now < 0) {
+            throw new IllegalStateException("Neighbours using this chunk cannot be negative");
+        }
+    }
+
+    // must hold scheduling lock
+    // returns string reason for why chunk should remain loaded, null otherwise
+    public final String isSafeToUnload() {
+        // is ticket level below threshold?
+        if (this.oldTicketLevel <= ChunkHolderManager.MAX_TICKET_LEVEL) {
+            return "ticket_level";
+        }
+
+        // are we being used by another chunk for generation?
+        if (this.totalNeighboursUsingThisChunk != 0) {
+            return "neighbours_generating";
+        }
+
+        // are we going to be used by another chunk for generation?
+        if (!this.neighboursWaitingForUs.isEmpty()) {
+            return "neighbours_waiting";
+        }
+
+        // chunk must be marked inaccessible (i.e unloaded to plugins)
+        if (this.getChunkStatus() != ChunkHolder.FullChunkStatus.INACCESSIBLE) {
+            return "fullchunkstatus";
+        }
+
+        // are we currently generating anything, or have requested generation?
+        if (this.generationTask != null) {
+            return "generating";
+        }
+        if (this.requestedGenStatus != null) {
+            return "requested_generation";
+        }
+
+        // entity data requested?
+        if (this.entityDataLoadTask != null) {
+            return "entity_data_requested";
+        }
+
+        // poi data requested?
+        if (this.poiDataLoadTask != null) {
+            return "poi_data_requested";
+        }
+
+        // are we pending serialization?
+        if (this.entityDataUnload != null) {
+            return "entity_serialization";
+        }
+        if (this.poiDataUnload != null) {
+            return "poi_serialization";
+        }
+        if (this.chunkDataUnload != null) {
+            return "chunk_serialization";
+        }
+
+        // Note: light tasks do not need a check, as they add a ticket.
+
+        // nothing is using this chunk, so it should be unloaded
+        return null;
+    }
+
+    /** Unloaded from chunk map */
+    boolean killed;
+
+    // must hold scheduling lock
+    private void checkUnload() {
+        if (this.killed) {
+            return;
+        }
+        if (this.isSafeToUnload() == null) {
+            // ensure in unload queue
+            this.scheduler.chunkHolderManager.unloadQueue.add(this);
+        } else {
+            // ensure not in unload queue
+            this.scheduler.chunkHolderManager.unloadQueue.remove(this);
+        }
+    }
+
+    static final record UnloadState(NewChunkHolder holder, ChunkAccess chunk, ChunkEntitySlices entityChunk, PoiChunk poiChunk) {};
+
+    // note: these are completed with null to indicate that no write occurred
+    // they are also completed with null to indicate a null write occurred
+    private UnloadTask chunkDataUnload;
+    private UnloadTask entityDataUnload;
+    private UnloadTask poiDataUnload;
+
+    public static final record UnloadTask(Completable<CompoundTag> completable, DelayedPrioritisedTask task) {}
+
+    public UnloadTask getUnloadTask(final RegionFileIOThread.RegionFileType type) {
+        switch (type) {
+            case CHUNK_DATA:
+                return this.chunkDataUnload;
+            case ENTITY_DATA:
+                return this.entityDataUnload;
+            case POI_DATA:
+                return this.poiDataUnload;
+            default:
+                throw new IllegalStateException("Unknown regionfile type " + type);
+        }
+    }
+
+    private UnloadState unloadState;
+
+    // holds schedule lock
+    UnloadState unloadStage1() {
+        // because we hold the scheduling lock, we cannot actually unload anything
+        // so we need to null this chunk's state
+        ChunkAccess chunk = this.currentChunk;
+        ChunkEntitySlices entityChunk = this.entityChunk;
+        PoiChunk poiChunk = this.poiChunk;
+        // chunk state
+        this.currentChunk = null;
+        this.currentGenStatus = null;
+        this.wrappedChunkForNeighbour = null;
+        this.lastChunkCompletion = null;
+        // entity chunk state
+        this.entityChunk = null;
+        this.pendingEntityChunk = null;
+
+        // poi chunk state
+        this.poiChunk = null;
+
+        // priority state
+        this.priorityLocked = false;
+
+        if (chunk != null) {
+            this.chunkDataUnload = new UnloadTask(new Completable<>(), new DelayedPrioritisedTask(PrioritisedExecutor.Priority.NORMAL));
+        }
+        if (poiChunk != null) {
+            this.poiDataUnload = new UnloadTask(new Completable<>(), null);
+        }
+        if (entityChunk != null) {
+            this.entityDataUnload = new UnloadTask(new Completable<>(), null);
+        }
+
+        return this.unloadState = (chunk != null || entityChunk != null || poiChunk != null) ? new UnloadState(this, chunk, entityChunk, poiChunk) : null;
+    }
+
+    // data is null if failed or does not need to be saved
+    void completeAsyncChunkDataSave(final CompoundTag data) {
+        if (data != null) {
+            RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, data, RegionFileIOThread.RegionFileType.CHUNK_DATA);
+        }
+        this.chunkDataUnload.completable().complete(data);
+        this.scheduler.schedulingLock.lock();
+        try {
+            // can only write to these fields while holding the schedule lock
+            this.chunkDataUnload = null;
+            this.checkUnload();
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+    }
+
+    void unloadStage2(final UnloadState state) {
+        this.unloadState = null;
+        final ChunkAccess chunk = state.chunk();
+        final ChunkEntitySlices entityChunk = state.entityChunk();
+        final PoiChunk poiChunk = state.poiChunk();
+
+        final boolean shouldLevelChunkNotSave = (chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave);
+
+        // unload chunk data
+        if (chunk != null) {
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.setLoaded(false);
+            }
+
+            if (!shouldLevelChunkNotSave) {
+                this.saveChunk(chunk, true);
+            } else {
+                this.completeAsyncChunkDataSave(null);
+            }
+
+            if (chunk instanceof LevelChunk levelChunk) {
+                this.world.unload(levelChunk);
+            }
+        }
+
+        // unload entity data
+        if (entityChunk != null) {
+            this.saveEntities(entityChunk, true);
+            // yes this is a hack to pass the compound tag through...
+            final CompoundTag lastEntityUnload = this.lastEntityUnload;
+            this.lastEntityUnload = null;
+
+            if (entityChunk.unload()) {
+                this.scheduler.schedulingLock.lock();
+                try {
+                    entityChunk.setTransient(true);
+                    this.entityChunk = entityChunk;
+                } finally {
+                    this.scheduler.schedulingLock.unlock();
+                }
+            } else {
+                this.world.getEntityLookup().entitySectionUnload(this.chunkX, this.chunkZ);
+            }
+            // we need to delay the callback until after determining transience, otherwise a potential loader could
+            // set entityChunk before we do
+            this.entityDataUnload.completable().complete(lastEntityUnload);
+        }
+
+        // unload poi data
+        if (poiChunk != null) {
+            if (poiChunk.isDirty() && !shouldLevelChunkNotSave) {
+                this.savePOI(poiChunk, true);
+            } else {
+                this.poiDataUnload.completable().complete(null);
+            }
+
+            if (poiChunk.isLoaded()) {
+                this.world.getPoiManager().onUnload(CoordinateUtils.getChunkKey(this.chunkX, this.chunkZ));
+            }
+        }
+    }
+
+    boolean unloadStage3() {
+        // can only write to these while holding the schedule lock, and we instantly complete them in stage2
+        this.poiDataUnload = null;
+        this.entityDataUnload = null;
+
+        // we need to check if anything has been loaded in the meantime (or if we have transient entities)
+        if (this.entityChunk != null || this.poiChunk != null || this.currentChunk != null) {
+            return false;
+        }
+
+        return this.isSafeToUnload() == null;
+    }
+
+    private void cancelGenTask() {
+        if (this.generationTask != null) {
+            this.generationTask.cancel();
+        } else {
+            // otherwise, we are blocking on neighbours, so remove them
+            if (!this.neighboursBlockingGenTask.isEmpty()) {
+                for (final NewChunkHolder neighbour : this.neighboursBlockingGenTask) {
+                    if (neighbour.neighboursWaitingForUs.remove(this) == null) {
+                        throw new IllegalStateException("Corrupt state");
+                    }
+                    if (neighbour.neighboursWaitingForUs.isEmpty()) {
+                        neighbour.checkUnload();
+                    }
+                }
+                this.neighboursBlockingGenTask.clear();
+                this.checkUnload();
+            }
+        }
+    }
+
+    // holds: ticket level update lock
+    // holds: schedule lock
+    public void processTicketLevelUpdate(final List<ChunkProgressionTask> scheduledTasks, final List<NewChunkHolder> changedLoadStatus) {
+        final int oldLevel = this.oldTicketLevel;
+        final int newLevel = this.currentTicketLevel;
+
+        if (oldLevel == newLevel) {
+            return;
+        }
+
+        this.oldTicketLevel = newLevel;
+
+        final ChunkHolder.FullChunkStatus oldState = ChunkHolder.getFullChunkStatus(oldLevel);
+        final ChunkHolder.FullChunkStatus newState = ChunkHolder.getFullChunkStatus(newLevel);
+        final boolean oldUnloaded = oldLevel > ChunkHolderManager.MAX_TICKET_LEVEL;
+        final boolean newUnloaded = newLevel > ChunkHolderManager.MAX_TICKET_LEVEL;
+
+        final ChunkStatus maxGenerationStatusOld = ChunkHolder.getStatus(oldLevel);
+        final ChunkStatus maxGenerationStatusNew = ChunkHolder.getStatus(newLevel);
+
+        // check for cancellations from downgrading ticket level
+        if (this.requestedGenStatus != null && !newState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && newLevel > oldLevel) {
+            // note: cancel() may invoke onChunkGenComplete synchronously here
+            if (newUnloaded) {
+                // need to cancel all tasks
+                // note: requested status must be set to null here before cancellation, to indicate to the
+                // completion logic that we do not want rescheduling to occur
+                this.requestedGenStatus = null;
+                this.cancelGenTask();
+            } else {
+                final ChunkStatus toCancel = maxGenerationStatusNew.getNextStatus();
+                final ChunkStatus currentRequestedStatus = this.requestedGenStatus;
+
+                if (currentRequestedStatus.isOrAfter(toCancel)) {
+                    // we do have to cancel something here
+                    // clamp requested status to the maximum
+                    if (this.currentGenStatus != null && this.currentGenStatus.isOrAfter(maxGenerationStatusNew)) {
+                        // already generated to status, so we must cancel
+                        this.requestedGenStatus = null;
+                        this.cancelGenTask();
+                    } else {
+                        // not generated to status, so we may have to cancel
+                        // note: gen task is always 1 status above current gen status if not null
+                        this.requestedGenStatus = maxGenerationStatusNew;
+                        if (this.generationTaskStatus != null && this.generationTaskStatus.isOrAfter(toCancel)) {
+                            // TOOD is this even possible? i don't think so
+                            throw new IllegalStateException("?????");
+                        }
+                    }
+                }
+            }
+        }
+
+        if (newState != oldState) {
+            if (newState.isOrAfter(oldState)) {
+                // status upgrade
+                if (!oldState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && newState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                    // may need to schedule full load
+                    if (this.currentGenStatus != ChunkStatus.FULL) {
+                        if (this.requestedGenStatus != null) {
+                            this.requestedGenStatus = ChunkStatus.FULL;
+                        } else {
+                            this.scheduler.schedule(
+                                this.chunkX, this.chunkZ, ChunkStatus.FULL, this, scheduledTasks
+                            );
+                        }
+                    } else {
+                        // now we are fully loaded
+                        this.queueBorderFullStatus(true, changedLoadStatus);
+                    }
+                }
+            } else {
+                // status downgrade
+                if (!newState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING) && oldState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING)) {
+                    this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.ENTITY_TICKING, null);
+                }
+
+                if (!newState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING) && oldState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING)) {
+                    this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.TICKING, null);
+                }
+
+                if (!newState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && oldState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                    this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.BORDER, null);
+                }
+            }
+        }
+
+        if (oldState != newState) {
+            if (this.onTicketUpdate(oldState, newState)) {
+                changedLoadStatus.add(this);
+            }
+        }
+
+        if (oldUnloaded != newUnloaded) {
+            this.checkUnload();
+        }
+    }
+
+    /*
+        For full chunks, vanilla just loads chunks around it up to FEATURES, 1 radius
+
+        For ticking chunks, it updates the persistent entity manager (soon to be completely nuked by EntitySliceManager, which
+        will also need to be updated but with far less implications)
+        It also shoves the scheduled block ticks into the tick scheduler
+
+        For entity ticking chunks, updates the entity manager (see above)
+     */
+
+    static final int NEIGHBOUR_RADIUS = 2;
+    private long fullNeighbourChunksLoadedBitset;
+
+    private static int getFullNeighbourIndex(final int relativeX, final int relativeZ) {
+        // index = (relativeX + NEIGHBOUR_CACHE_RADIUS) + (relativeZ + NEIGHBOUR_CACHE_RADIUS) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)
+        // optimised variant of the above by moving some of the ops to compile time
+        return relativeX + (relativeZ * (NEIGHBOUR_RADIUS * 2 + 1)) + (NEIGHBOUR_RADIUS + NEIGHBOUR_RADIUS * ((NEIGHBOUR_RADIUS * 2 + 1)));
+    }
+    public final boolean isNeighbourFullLoaded(final int relativeX, final int relativeZ) {
+        return (this.fullNeighbourChunksLoadedBitset & (1L << getFullNeighbourIndex(relativeX, relativeZ))) != 0;
+    }
+
+    // returns true if this chunk changed full status
+    public final boolean setNeighbourFullLoaded(final int relativeX, final int relativeZ) {
+        final long before = this.fullNeighbourChunksLoadedBitset;
+        final int index = getFullNeighbourIndex(relativeX, relativeZ);
+        this.fullNeighbourChunksLoadedBitset |= (1L << index);
+        return this.onNeighbourChange(before, this.fullNeighbourChunksLoadedBitset);
+    }
+
+    // returns true if this chunk changed full status
+    public final boolean setNeighbourFullUnloaded(final int relativeX, final int relativeZ) {
+        final long before = this.fullNeighbourChunksLoadedBitset;
+        final int index = getFullNeighbourIndex(relativeX, relativeZ);
+        this.fullNeighbourChunksLoadedBitset &= ~(1L << index);
+        return this.onNeighbourChange(before, this.fullNeighbourChunksLoadedBitset);
+    }
+
+    public static boolean areNeighboursFullLoaded(final long bitset, final int radius) {
+        // index = relativeX + (relativeZ * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)) + (NEIGHBOUR_CACHE_RADIUS + NEIGHBOUR_CACHE_RADIUS * ((NEIGHBOUR_CACHE_RADIUS * 2 + 1)))
+        switch (radius) {
+            case 0: {
+                return (bitset & (1L << getFullNeighbourIndex(0, 0))) != 0L;
+            }
+            case 1: {
+                long mask = 0L;
+                for (int dx = -1; dx <= 1; ++dx) {
+                    for (int dz = -1; dz <= 1; ++dz) {
+                        mask |= (1L << getFullNeighbourIndex(dx, dz));
+                    }
+                }
+                return (bitset & mask) == mask;
+            }
+            case 2: {
+                long mask = 0L;
+                for (int dx = -2; dx <= 2; ++dx) {
+                    for (int dz = -2; dz <= 2; ++dz) {
+                        mask |= (1L << getFullNeighbourIndex(dx, dz));
+                    }
+                }
+                return (bitset & mask) == mask;
+            }
+
+            default: {
+                throw new IllegalArgumentException("Radius not recognized: " + radius);
+            }
+        }
+    }
+
+    // upper 16 bits are pending status, lower 16 bits are current status
+    private volatile long chunkStatus;
+    private static final long PENDING_STATUS_MASK = Long.MIN_VALUE >> 31;
+    private static final ChunkHolder.FullChunkStatus[] CHUNK_STATUS_BY_ID = ChunkHolder.FullChunkStatus.values();
+    private static final VarHandle CHUNK_STATUS_HANDLE = ConcurrentUtil.getVarHandle(NewChunkHolder.class, "chunkStatus", long.class);
+
+    public static ChunkHolder.FullChunkStatus getCurrentChunkStatus(final long encoded) {
+        return CHUNK_STATUS_BY_ID[(int)encoded];
+    }
+
+    public static ChunkHolder.FullChunkStatus getPendingChunkStatus(final long encoded) {
+        return CHUNK_STATUS_BY_ID[(int)(encoded >>> 32)];
+    }
+
+    public ChunkHolder.FullChunkStatus getChunkStatus() {
+        return getCurrentChunkStatus(((long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this)));
+    }
+
+    public boolean isEntityTickingReady() {
+        return this.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
+    }
+
+    public boolean isTickingReady() {
+        return this.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.TICKING);
+    }
+
+    public boolean isFullChunkReady() {
+        return this.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
+    }
+
+    private static ChunkHolder.FullChunkStatus getStatusForBitset(final long bitset) {
+        if (areNeighboursFullLoaded(bitset, 2)) {
+            return ChunkHolder.FullChunkStatus.ENTITY_TICKING;
+        } else if (areNeighboursFullLoaded(bitset, 1)) {
+            return ChunkHolder.FullChunkStatus.TICKING;
+        } else if (areNeighboursFullLoaded(bitset, 0)) {
+            return ChunkHolder.FullChunkStatus.BORDER;
+        } else {
+            return ChunkHolder.FullChunkStatus.INACCESSIBLE;
+        }
+    }
+
+    // note: only while updating ticket level, so holds ticket update lock + scheduling lock
+    protected final boolean onTicketUpdate(final ChunkHolder.FullChunkStatus oldState, final ChunkHolder.FullChunkStatus newState) {
+        if (oldState == newState) {
+            return false;
+        }
+
+        // preserve border request after full status complete, as it does not set anything in the bitset
+        ChunkHolder.FullChunkStatus byNeighbours = getStatusForBitset(this.fullNeighbourChunksLoadedBitset);
+        if (byNeighbours == ChunkHolder.FullChunkStatus.INACCESSIBLE && newState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && this.currentGenStatus == ChunkStatus.FULL) {
+            byNeighbours = ChunkHolder.FullChunkStatus.BORDER;
+        }
+
+        final ChunkHolder.FullChunkStatus toSet;
+
+        if (newState.isOrAfter(byNeighbours)) {
+            // must clamp to neighbours level, even though we have the ticket level
+            toSet = byNeighbours;
+        } else {
+            // must clamp to ticket level, even though we have the neighbours
+            toSet = newState;
+        }
+
+        long curr = (long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this);
+
+        if (curr == ((long)toSet.ordinal() | ((long)toSet.ordinal() << 32))) {
+            // nothing to do
+            return false;
+        }
+
+        int failures = 0;
+        for (;;) {
+            final long update = (curr & ~PENDING_STATUS_MASK) | ((long)toSet.ordinal() << 32);
+            if (curr == (curr = (long)CHUNK_STATUS_HANDLE.compareAndExchange((NewChunkHolder)this, curr, update))) {
+                return true;
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    protected final boolean onNeighbourChange(final long bitsetBefore, final long bitsetAfter) {
+        ChunkHolder.FullChunkStatus oldState = getStatusForBitset(bitsetBefore);
+        ChunkHolder.FullChunkStatus newState = getStatusForBitset(bitsetAfter);
+        final ChunkHolder.FullChunkStatus currStateTicketLevel = ChunkHolder.getFullChunkStatus(this.oldTicketLevel);
+        if (oldState.isOrAfter(currStateTicketLevel)) {
+            oldState = currStateTicketLevel;
+        }
+        if (newState.isOrAfter(currStateTicketLevel)) {
+            newState = currStateTicketLevel;
+        }
+        // preserve border request after full status complete, as it does not set anything in the bitset
+        if (newState == ChunkHolder.FullChunkStatus.INACCESSIBLE && currStateTicketLevel.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && this.currentGenStatus == ChunkStatus.FULL) {
+            newState = ChunkHolder.FullChunkStatus.BORDER;
+        }
+
+        if (oldState == newState) {
+            return false;
+        }
+
+        int failures = 0;
+        for (long curr = (long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this);;) {
+            final long update = (curr & ~PENDING_STATUS_MASK) | ((long)newState.ordinal() << 32);
+            if (curr == (curr = (long)CHUNK_STATUS_HANDLE.compareAndExchange((NewChunkHolder)this, curr, update))) {
+                return true;
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    private boolean queueBorderFullStatus(final boolean loaded, final List<NewChunkHolder> changedFullStatus) {
+        final ChunkHolder.FullChunkStatus toStatus = loaded ? ChunkHolder.FullChunkStatus.BORDER : ChunkHolder.FullChunkStatus.INACCESSIBLE;
+
+        int failures = 0;
+        for (long curr = (long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this);;) {
+            final ChunkHolder.FullChunkStatus currPending = getPendingChunkStatus(curr);
+            if (loaded && currPending != ChunkHolder.FullChunkStatus.INACCESSIBLE) {
+                throw new IllegalStateException("Expected " + ChunkHolder.FullChunkStatus.INACCESSIBLE + " for pending, but got " + currPending);
+            }
+
+            final long update = (curr & ~PENDING_STATUS_MASK) | ((long)toStatus.ordinal() << 32);
+            if (curr == (curr = (long)CHUNK_STATUS_HANDLE.compareAndExchange((NewChunkHolder)this, curr, update))) {
+                if ((int)(update) != (int)(update >>> 32)) {
+                    changedFullStatus.add(this);
+                    return true;
+                }
+                return false;
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    // only call on main thread, must hold ticket level and scheduling lock
+    private void onFullChunkLoadChange(final boolean loaded, final List<NewChunkHolder> changedFullStatus) {
+        for (int dz = -NEIGHBOUR_RADIUS; dz <= NEIGHBOUR_RADIUS; ++dz) {
+            for (int dx = -NEIGHBOUR_RADIUS; dx <= NEIGHBOUR_RADIUS; ++dx) {
+                final NewChunkHolder holder = (dx | dz) == 0 ? this : this.scheduler.chunkHolderManager.getChunkHolder(dx + this.chunkX, dz + this.chunkZ);
+                if (loaded) {
+                    if (holder.setNeighbourFullLoaded(-dx, -dz)) {
+                        changedFullStatus.add(holder);
+                    }
+                } else {
+                    if (holder != null && holder.setNeighbourFullUnloaded(-dx, -dz)) {
+                        changedFullStatus.add(holder);
+                    }
+                }
+            }
+        }
+    }
+
+    private ChunkHolder.FullChunkStatus updateCurrentState(final ChunkHolder.FullChunkStatus to) {
+        int failures = 0;
+        for (long curr = (long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this);;) {
+            final long update = (curr & PENDING_STATUS_MASK) | (long)to.ordinal();
+            if (curr == (curr = (long)CHUNK_STATUS_HANDLE.compareAndExchange((NewChunkHolder)this, curr, update))) {
+                return getPendingChunkStatus(curr);
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    private void changeEntityChunkStatus(final ChunkHolder.FullChunkStatus toStatus) {
+        this.world.getEntityLookup().chunkStatusChange(this.chunkX, this.chunkZ, toStatus);
+    }
+
+    private boolean processingFullStatus = false;
+
+    // only to be called on the main thread, no locks need to be held
+    public boolean handleFullStatusChange(final List<NewChunkHolder> changedFullStatus) {
+        TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot update full status thread off-main");
+
+        boolean ret = false;
+
+        if (this.processingFullStatus) {
+            // we cannot process updates recursively
+            return ret;
+        }
+
+        // note: use opaque reads for chunk status read since we need it to be atomic
+
+        // test if anything changed
+        final long statusCheck = (long)CHUNK_STATUS_HANDLE.getOpaque((NewChunkHolder)this);
+        if ((int)statusCheck == (int)(statusCheck >>> 32)) {
+            // nothing changed
+            return ret;
+        }
+
+        final ChunkTaskScheduler scheduler = this.scheduler;
+        final ChunkHolderManager holderManager = scheduler.chunkHolderManager;
+        final int ticketKeep;
+        final Long ticketId;
+        holderManager.ticketLock.lock();
+        try {
+            ticketKeep = this.currentTicketLevel;
+            ticketId = Long.valueOf(holderManager.getNextStatusUpgradeId());
+            holderManager.addTicketAtLevel(TicketType.STATUS_UPGRADE, this.chunkX, this.chunkZ, ticketKeep, ticketId);
+        } finally {
+            holderManager.ticketLock.unlock();
+        }
+
+        this.processingFullStatus = true;
+        try {
+            for (;;) {
+                final long currStateEncoded = (long)CHUNK_STATUS_HANDLE.getOpaque((NewChunkHolder)this);
+                final ChunkHolder.FullChunkStatus currState = getCurrentChunkStatus(currStateEncoded);
+                ChunkHolder.FullChunkStatus nextState = getPendingChunkStatus(currStateEncoded);
+                if (currState == nextState) {
+                    if (nextState == ChunkHolder.FullChunkStatus.INACCESSIBLE) {
+                        this.scheduler.schedulingLock.lock();
+                        try {
+                            this.checkUnload();
+                        } finally {
+                            this.scheduler.schedulingLock.unlock();
+                        }
+                    }
+                    break;
+                }
+
+                // chunks cannot downgrade state while status is pending a change
+                final LevelChunk chunk = (LevelChunk)this.currentChunk;
+
+                // Note: we assume that only load/unload contain plugin logic
+                // plugin logic is anything stupid enough to possibly change the chunk status while it is already
+                // being changed (i.e during load it is possible it will try to set to full ticking)
+                // in order to allow this change, we also need this plugin logic to be contained strictly after all
+                // of the chunk system load callbacks are invoked
+                if (nextState.isOrAfter(currState)) {
+                    // state upgrade
+                    if (!currState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && nextState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.BORDER);
+                        holderManager.ensureInAutosave(this);
+                        this.changeEntityChunkStatus(ChunkHolder.FullChunkStatus.BORDER);
+                        chunk.onChunkLoad(this);
+                        this.onFullChunkLoadChange(true, changedFullStatus);
+                        this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.BORDER, chunk);
+                    }
+
+                    if (!currState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING) && nextState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING)) {
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.TICKING);
+                        this.changeEntityChunkStatus(ChunkHolder.FullChunkStatus.TICKING);
+                        chunk.onChunkTicking(this);
+                        this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.TICKING, chunk);
+                    }
+
+                    if (!currState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING) && nextState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING)) {
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
+                        this.changeEntityChunkStatus(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
+                        chunk.onChunkEntityTicking(this);
+                        this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.ENTITY_TICKING, chunk);
+                    }
+                } else {
+                    if (currState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING) && !nextState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING)) {
+                        this.changeEntityChunkStatus(ChunkHolder.FullChunkStatus.TICKING);
+                        chunk.onChunkNotEntityTicking(this);
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.TICKING);
+                    }
+
+                    if (currState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING) && !nextState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING)) {
+                        this.changeEntityChunkStatus(ChunkHolder.FullChunkStatus.BORDER);
+                        chunk.onChunkNotTicking(this);
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.BORDER);
+                    }
+
+                    if (currState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && !nextState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                        this.onFullChunkLoadChange(false, changedFullStatus);
+                        this.changeEntityChunkStatus(ChunkHolder.FullChunkStatus.INACCESSIBLE);
+                        chunk.onChunkUnload(this);
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.INACCESSIBLE);
+                    }
+                }
+
+                ret = true;
+            }
+        } finally {
+            this.processingFullStatus = false;
+            holderManager.removeTicketAtLevel(TicketType.STATUS_UPGRADE, this.chunkX, this.chunkZ, ticketKeep, ticketId);
+        }
+
+        return ret;
+    }
+
+    // note: must hold scheduling lock
+    // rets true if the current requested gen status is not null (effectively, whether further scheduling is not needed)
+    boolean upgradeGenTarget(final ChunkStatus toStatus) {
+        if (toStatus == null) {
+            throw new NullPointerException("toStatus cannot be null");
+        }
+        if (this.requestedGenStatus == null && this.generationTask == null) {
+            return false;
+        }
+        if (this.requestedGenStatus == null || !this.requestedGenStatus.isOrAfter(toStatus)) {
+            this.requestedGenStatus = toStatus;
+        }
+        return true;
+    }
+
+    public void setGenerationTarget(final ChunkStatus toStatus) {
+        this.requestedGenStatus = toStatus;
+    }
+
+    public boolean hasGenerationTask() {
+        return this.generationTask != null;
+    }
+
+    public ChunkStatus getCurrentGenStatus() {
+        return this.currentGenStatus;
+    }
+
+    public ChunkStatus getRequestedGenStatus() {
+        return this.requestedGenStatus;
+    }
+
+    private final Reference2ObjectOpenHashMap<ChunkStatus, List<Consumer<ChunkAccess>>> statusWaiters = new Reference2ObjectOpenHashMap<>();
+
+    void addStatusConsumer(final ChunkStatus status, final Consumer<ChunkAccess> consumer) {
+        this.statusWaiters.computeIfAbsent(status, (final ChunkStatus keyInMap) -> {
+            return new ArrayList<>(4);
+        }).add(consumer);
+    }
+
+    private void completeStatusConsumers(ChunkStatus status, final ChunkAccess chunk) {
+        // need to tell future statuses to complete if cancelled
+        do {
+            this.completeStatusConsumers0(status, chunk);
+        } while (chunk == null && status != (status = status.getNextStatus()));
+    }
+
+    private void completeStatusConsumers0(final ChunkStatus status, final ChunkAccess chunk) {
+        final List<Consumer<ChunkAccess>> consumers;
+        consumers = this.statusWaiters.remove(status);
+
+        if (consumers == null) {
+            return;
+        }
+
+        // must be scheduled to main, we do not trust the callback to not do anything stupid
+        this.scheduler.scheduleChunkTask(this.chunkX, this.chunkZ, () -> {
+            for (final Consumer<ChunkAccess> consumer : consumers) {
+                try {
+                    consumer.accept(chunk);
+                } catch (final ThreadDeath thr) {
+                    throw thr;
+                } catch (final Throwable thr) {
+                    LOGGER.error("Failed to process chunk status callback", thr);
+                }
+            }
+        }, PrioritisedExecutor.Priority.HIGHEST);
+    }
+
+    private final Reference2ObjectOpenHashMap<ChunkHolder.FullChunkStatus, List<Consumer<LevelChunk>>> fullStatusWaiters = new Reference2ObjectOpenHashMap<>();
+
+    void addFullStatusConsumer(final ChunkHolder.FullChunkStatus status, final Consumer<LevelChunk> consumer) {
+        this.fullStatusWaiters.computeIfAbsent(status, (final ChunkHolder.FullChunkStatus keyInMap) -> {
+            return new ArrayList<>(4);
+        }).add(consumer);
+    }
+
+    private void completeFullStatusConsumers(ChunkHolder.FullChunkStatus status, final LevelChunk chunk) {
+        // need to tell future statuses to complete if cancelled
+        final ChunkHolder.FullChunkStatus max = CHUNK_STATUS_BY_ID[CHUNK_STATUS_BY_ID.length - 1];
+
+        for (;;) {
+            this.completeFullStatusConsumers0(status, chunk);
+            if (chunk != null || status == max) {
+                break;
+            }
+            status = CHUNK_STATUS_BY_ID[status.ordinal() + 1];
+        }
+    }
+
+    private void completeFullStatusConsumers0(final ChunkHolder.FullChunkStatus status, final LevelChunk chunk) {
+        final List<Consumer<LevelChunk>> consumers;
+        consumers = this.fullStatusWaiters.remove(status);
+
+        if (consumers == null) {
+            return;
+        }
+
+        // must be scheduled to main, we do not trust the callback to not do anything stupid
+        this.scheduler.scheduleChunkTask(this.chunkX, this.chunkZ, () -> {
+            for (final Consumer<LevelChunk> consumer : consumers) {
+                try {
+                    consumer.accept(chunk);
+                } catch (final ThreadDeath thr) {
+                    throw thr;
+                } catch (final Throwable thr) {
+                    LOGGER.error("Failed to process chunk status callback", thr);
+                }
+            }
+        }, PrioritisedExecutor.Priority.HIGHEST);
+    }
+
+    // note: must hold scheduling lock
+    private void onChunkGenComplete(final ChunkAccess newChunk, final ChunkStatus newStatus,
+                                    final List<ChunkProgressionTask> scheduleList, final List<NewChunkHolder> changedLoadStatus) {
+        if (!this.neighboursBlockingGenTask.isEmpty()) {
+            throw new IllegalStateException("Cannot have neighbours blocking this gen task");
+        }
+        if (newChunk != null || (this.requestedGenStatus == null || !this.requestedGenStatus.isOrAfter(newStatus))) {
+            this.completeStatusConsumers(newStatus, newChunk);
+        }
+        // done now, clear state (must be done before scheduling new tasks)
+        this.generationTask = null;
+        this.generationTaskStatus = null;
+        if (newChunk == null) {
+            // task was cancelled
+            // should be careful as this could be called while holding the schedule lock and/or inside the
+            // ticket level update
+            // while a task may be cancelled, it is possible for it to be later re-scheduled
+            // however, because generationTask is only set to null on _completion_, the scheduler leaves
+            // the rescheduling logic to us here
+            final ChunkStatus requestedGenStatus = this.requestedGenStatus;
+            this.requestedGenStatus = null;
+            if (requestedGenStatus != null) {
+                // it looks like it has been requested, so we must reschedule
+                if (!this.neighboursWaitingForUs.isEmpty()) {
+                    for (final Iterator<Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus>> iterator = this.neighboursWaitingForUs.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+                        final Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus> entry = iterator.next();
+
+                        final NewChunkHolder chunkHolder = entry.getKey();
+                        final ChunkStatus toStatus = entry.getValue();
+
+                        if (!requestedGenStatus.isOrAfter(toStatus)) {
+                            // if we were cancelled, we are responsible for removing the waiter
+                            if (!chunkHolder.neighboursBlockingGenTask.remove(this)) {
+                                throw new IllegalStateException("Corrupt state");
+                            }
+                            if (chunkHolder.neighboursBlockingGenTask.isEmpty()) {
+                                chunkHolder.checkUnload();
+                            }
+                            iterator.remove();
+                            continue;
+                        }
+                    }
+                }
+
+                // note: only after generationTask -> null, generationTaskStatus -> null, and requestedGenStatus -> null
+                this.scheduler.schedule(
+                    this.chunkX, this.chunkZ, requestedGenStatus, this, scheduleList
+                );
+
+                // return, can't do anything further
+                return;
+            }
+
+            if (!this.neighboursWaitingForUs.isEmpty()) {
+                for (final NewChunkHolder chunkHolder : this.neighboursWaitingForUs.keySet()) {
+                    if (!chunkHolder.neighboursBlockingGenTask.remove(this)) {
+                        throw new IllegalStateException("Corrupt state");
+                    }
+                    if (chunkHolder.neighboursBlockingGenTask.isEmpty()) {
+                        chunkHolder.checkUnload();
+                    }
+                }
+                this.neighboursWaitingForUs.clear();
+            }
+            // reset priority, we have nothing left to generate to
+            this.setPriority(PrioritisedExecutor.Priority.NORMAL);
+            this.checkUnload();
+            return;
+        }
+
+        this.currentChunk = newChunk;
+        this.currentGenStatus = newStatus;
+        this.lastChunkCompletion = new ChunkCompletion(newChunk, newStatus);
+
+        final ChunkStatus requestedGenStatus = this.requestedGenStatus;
+
+        List<NewChunkHolder> needsScheduling = null;
+        boolean recalculatePriority = false;
+        for (final Iterator<Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus>> iterator
+             = this.neighboursWaitingForUs.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+            final Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus> entry = iterator.next();
+            final NewChunkHolder neighbour = entry.getKey();
+            final ChunkStatus requiredStatus = entry.getValue();
+
+            if (!newStatus.isOrAfter(requiredStatus)) {
+                if (requestedGenStatus == null || !requestedGenStatus.isOrAfter(requiredStatus)) {
+                    // if we're cancelled, still need to clear this map
+                    if (!neighbour.neighboursBlockingGenTask.remove(this)) {
+                        throw new IllegalStateException("Neighbour is not waiting for us?");
+                    }
+                    if (neighbour.neighboursBlockingGenTask.isEmpty()) {
+                        neighbour.checkUnload();
+                    }
+
+                    iterator.remove();
+                }
+                continue;
+            }
+
+            // doesn't matter what isCancelled is here, we need to schedule if we can
+
+            recalculatePriority = true;
+            if (!neighbour.neighboursBlockingGenTask.remove(this)) {
+                throw new IllegalStateException("Neighbour is not waiting for us?");
+            }
+
+            if (neighbour.neighboursBlockingGenTask.isEmpty()) {
+                if (neighbour.requestedGenStatus != null) {
+                    if (needsScheduling == null) {
+                        needsScheduling = new ArrayList<>();
+                    }
+                    needsScheduling.add(neighbour);
+                } else {
+                    neighbour.checkUnload();
+                }
+            }
+
+            // remove last; access to entry will throw if removed
+            iterator.remove();
+        }
+
+        if (newStatus == ChunkStatus.FULL) {
+            this.lockPriority();
+            // must use oldTicketLevel, we hold the schedule lock but not the ticket level lock
+            // however, schedule lock needs to be held for ticket level callback, so we're fine here
+            if (ChunkHolder.getFullChunkStatus(this.oldTicketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                this.queueBorderFullStatus(true, changedLoadStatus);
+            }
+        }
+
+        if (recalculatePriority) {
+            this.recalculateNeighbourRequestedPriority();
+        }
+
+        if (requestedGenStatus != null && !newStatus.isOrAfter(requestedGenStatus)) {
+            this.scheduleNeighbours(needsScheduling, scheduleList);
+
+            // we need to schedule more tasks now
+            this.scheduler.schedule(
+                this.chunkX, this.chunkZ, requestedGenStatus, this, scheduleList
+            );
+        } else {
+            // we're done now
+            if (requestedGenStatus != null) {
+                this.requestedGenStatus = null;
+            }
+            // reached final stage, so stop scheduling now
+            this.setPriority(PrioritisedExecutor.Priority.NORMAL);
+            this.checkUnload();
+
+            this.scheduleNeighbours(needsScheduling, scheduleList);
+        }
+    }
+
+    private void scheduleNeighbours(final List<NewChunkHolder> needsScheduling, final List<ChunkProgressionTask> scheduleList) {
+        if (needsScheduling != null) {
+            for (int i = 0, len = needsScheduling.size(); i < len; ++i) {
+                final NewChunkHolder neighbour = needsScheduling.get(i);
+
+                this.scheduler.schedule(
+                    neighbour.chunkX, neighbour.chunkZ, neighbour.requestedGenStatus, neighbour, scheduleList
+                );
+            }
+        }
+    }
+
+    public void setGenerationTask(final ChunkProgressionTask generationTask, final ChunkStatus taskStatus,
+                                  final List<NewChunkHolder> neighbours) {
+        if (this.generationTask != null || (this.currentGenStatus != null && this.currentGenStatus.isOrAfter(taskStatus))) {
+            throw new IllegalStateException("Currently generating or provided task is trying to generate to a level we are already at!");
+        }
+        if (this.requestedGenStatus == null || !this.requestedGenStatus.isOrAfter(taskStatus)) {
+            throw new IllegalStateException("Cannot schedule generation task when not requested");
+        }
+        this.generationTask = generationTask;
+        this.generationTaskStatus = taskStatus;
+
+        for (int i = 0, len = neighbours.size(); i < len; ++i) {
+            neighbours.get(i).addNeighbourUsingChunk();
+        }
+
+        this.checkUnload();
+
+        generationTask.onComplete((final ChunkAccess access, final Throwable thr) -> {
+            if (generationTask != this.generationTask) {
+                throw new IllegalStateException(
+                    "Cannot complete generation task '" + generationTask + "' because we are waiting on '" + this.generationTask + "' instead!"
+                );
+            }
+            if (thr != null) {
+                if (this.genTaskException != null) {
+                    // first one is probably the TRUE problem
+                    return;
+                }
+                // don't set generation task to null, so that scheduling will not attempt to create another task and it
+                // will automatically block any further scheduling usage of this chunk as it will wait forever for a failed
+                // task to complete
+                this.genTaskException = thr;
+                this.failedGenStatus = taskStatus;
+                this.genTaskFailedThread = Thread.currentThread();
+
+                this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                    "Generation task", ChunkTaskScheduler.stringIfNull(generationTask),
+                    "Task to status", ChunkTaskScheduler.stringIfNull(taskStatus)
+                ), thr);
+                return;
+            }
+
+            final boolean scheduleTasks;
+            List<ChunkProgressionTask> tasks = ChunkHolderManager.getCurrentTicketUpdateScheduling();
+            if (tasks == null) {
+                scheduleTasks = true;
+                tasks = new ArrayList<>();
+            } else {
+                scheduleTasks = false;
+                // we are currently updating ticket levels, so we already hold the schedule lock
+                // this means we have to leave the ticket level update to handle the scheduling
+            }
+            final List<NewChunkHolder> changedLoadStatus = new ArrayList<>();
+            this.scheduler.schedulingLock.lock();
+            try {
+                for (int i = 0, len = neighbours.size(); i < len; ++i) {
+                    neighbours.get(i).removeNeighbourUsingChunk();
+                }
+                this.onChunkGenComplete(access, taskStatus, tasks, changedLoadStatus);
+            } finally {
+                this.scheduler.schedulingLock.unlock();
+            }
+            this.scheduler.chunkHolderManager.addChangedStatuses(changedLoadStatus);
+
+            if (scheduleTasks) {
+                // can't hold the lock while scheduling, so we have to build the tasks and then schedule after
+                for (int i = 0, len = tasks.size(); i < len; ++i) {
+                    tasks.get(i).schedule();
+                }
+            }
+        });
+    }
+
+    public PoiChunk getPoiChunk() {
+        return this.poiChunk;
+    }
+
+    public ChunkEntitySlices getEntityChunk() {
+        return this.entityChunk;
+    }
+
+    public long lastAutoSave;
+
+    public boolean save(final boolean shutdown, final boolean unloading) {
+        TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot save data off-main");
+
+        ChunkAccess chunk = this.getCurrentChunk();
+        PoiChunk poi = this.getPoiChunk();
+        ChunkEntitySlices entities = this.getEntityChunk();
+        boolean executedUnloadTask = false;
+
+        if (shutdown) {
+            // make sure that the async unloads complete
+            if (this.unloadState != null) {
+                // must have errored during unload
+                chunk = this.unloadState.chunk();
+                poi = this.unloadState.poiChunk();
+                entities = this.unloadState.entityChunk();
+            }
+            final UnloadTask chunkUnloadTask = this.chunkDataUnload;
+            final DelayedPrioritisedTask chunkDataUnloadTask = chunkUnloadTask == null ? null : chunkUnloadTask.task();
+            if (chunkDataUnloadTask != null) {
+                final PrioritisedExecutor.PrioritisedTask unloadTask = chunkDataUnloadTask.getTask();
+                if (unloadTask != null) {
+                    executedUnloadTask = unloadTask.execute();
+                }
+            }
+        }
+
+        boolean canSaveChunk = !(chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) &&
+                                (chunk != null && ((shutdown || chunk instanceof LevelChunk) && chunk.isUnsaved()));
+        boolean canSavePOI = !(chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) && (poi != null && poi.isDirty());
+        boolean canSaveEntities = entities != null;
+
+        try (co.aikar.timings.Timing ignored = this.world.timings.chunkSave.startTiming()) { // Paper
+            if (canSaveChunk) {
+                canSaveChunk = this.saveChunk(chunk, unloading);
+            }
+            if (canSavePOI) {
+                canSavePOI = this.savePOI(poi, unloading);
+            }
+            if (canSaveEntities) {
+                // on shutdown, we need to force transient entity chunks to save
+                canSaveEntities = this.saveEntities(entities, unloading || shutdown);
+                if (unloading || shutdown) {
+                    this.lastEntityUnload = null;
+                }
+            }
+        }
+
+        return executedUnloadTask | canSaveChunk | canSaveEntities | canSavePOI;
+    }
+
+    static final class AsyncChunkSerializeTask implements Runnable {
+
+        private final ServerLevel world;
+        private final ChunkAccess chunk;
+        private final ChunkSerializer.AsyncSaveData asyncSaveData;
+        private final NewChunkHolder toComplete;
+
+        public AsyncChunkSerializeTask(final ServerLevel world, final ChunkAccess chunk, final ChunkSerializer.AsyncSaveData asyncSaveData,
+                                       final NewChunkHolder toComplete) {
+            this.world = world;
+            this.chunk = chunk;
+            this.asyncSaveData = asyncSaveData;
+            this.toComplete = toComplete;
+        }
+
+        @Override
+        public void run() {
+            final CompoundTag toSerialize;
+            try {
+                toSerialize = ChunkSerializer.saveChunk(this.world, this.chunk, this.asyncSaveData);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable throwable) {
+                LOGGER.error("Failed to asynchronously save chunk " + this.chunk.getPos() + " for world '" + this.world.getWorld().getName() + "', falling back to synchronous save", throwable);
+                this.world.chunkTaskScheduler.scheduleChunkTask(this.chunk.locX, this.chunk.locZ, () -> {
+                    final CompoundTag synchronousSave;
+                    try {
+                        synchronousSave = ChunkSerializer.saveChunk(AsyncChunkSerializeTask.this.world, AsyncChunkSerializeTask.this.chunk, AsyncChunkSerializeTask.this.asyncSaveData);
+                    } catch (final ThreadDeath death) {
+                        throw death;
+                    } catch (final Throwable throwable2) {
+                        LOGGER.error("Failed to synchronously save chunk " + AsyncChunkSerializeTask.this.chunk.getPos() + " for world '" + AsyncChunkSerializeTask.this.world.getWorld().getName() + "', chunk data will be lost", throwable2);
+                        AsyncChunkSerializeTask.this.toComplete.completeAsyncChunkDataSave(null);
+                        return;
+                    }
+
+                    AsyncChunkSerializeTask.this.toComplete.completeAsyncChunkDataSave(synchronousSave);
+                    LOGGER.info("Successfully serialized chunk " + AsyncChunkSerializeTask.this.chunk.getPos() + " for world '" + AsyncChunkSerializeTask.this.world.getWorld().getName() + "' synchronously");
+
+                }, PrioritisedExecutor.Priority.HIGHEST);
+                return;
+            }
+            this.toComplete.completeAsyncChunkDataSave(toSerialize);
+        }
+
+        @Override
+        public String toString() {
+            return "AsyncChunkSerializeTask{" +
+                "chunk={pos=" + this.chunk.getPos() + ",world=\"" + this.world.getWorld().getName() + "\"}" +
+                "}";
+        }
+    }
+
+    private boolean saveChunk(final ChunkAccess chunk, final boolean unloading) {
+        if (!chunk.isUnsaved()) {
+            if (unloading) {
+                this.completeAsyncChunkDataSave(null);
+            }
+            return false;
+        }
+        boolean completing = false;
+        try {
+            if (unloading) {
+                try {
+                    final ChunkSerializer.AsyncSaveData asyncSaveData = ChunkSerializer.getAsyncSaveData(this.world, chunk);
+
+                    final PrioritisedExecutor.PrioritisedTask task = this.scheduler.loadExecutor.createTask(new AsyncChunkSerializeTask(this.world, chunk, asyncSaveData, this));
+
+                    this.chunkDataUnload.task().setTask(task);
+
+                    task.queue();
+
+                    return true;
+                } catch (final ThreadDeath death) {
+                    throw death;
+                } catch (final Throwable thr) {
+                    LOGGER.error("Failed to prepare async chunk data (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "', falling back to synchronous save", thr);
+                    // fall through to synchronous save
+                }
+            }
+
+            final CompoundTag save = ChunkSerializer.saveChunk(this.world, chunk, null);
+
+            if (unloading) {
+                completing = true;
+                this.completeAsyncChunkDataSave(save);
+                LOGGER.info("Successfully serialized chunk data (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "' synchronously");
+            } else {
+                RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, save, RegionFileIOThread.RegionFileType.CHUNK_DATA);
+            }
+        } catch (final ThreadDeath death) {
+            throw death;
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to save chunk data (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "'");
+            if (unloading && !completing) {
+                this.completeAsyncChunkDataSave(null);
+            }
+        }
+
+        return true;
+    }
+
+    private boolean lastEntitySaveNull;
+    private CompoundTag lastEntityUnload;
+    private boolean saveEntities(final ChunkEntitySlices entities, final boolean unloading) {
+        try {
+            CompoundTag mergeFrom = null;
+            if (entities.isTransient()) {
+                if (!unloading) {
+                    // if we're a transient chunk, we cannot save until unloading because otherwise a double save will
+                    // result in double adding the entities
+                    return false;
+                }
+                try {
+                    mergeFrom = RegionFileIOThread.loadData(this.world, this.chunkX, this.chunkZ, RegionFileIOThread.RegionFileType.ENTITY_DATA, PrioritisedExecutor.Priority.BLOCKING);
+                } catch (final Exception ex) {
+                    LOGGER.error("Cannot merge transient entities for chunk (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "', data on disk will be replaced", ex);
+                }
+            }
+
+            final CompoundTag save = entities.save();
+            if (mergeFrom != null) {
+                if (save == null) {
+                    // don't override the data on disk with nothing
+                    return false;
+                } else {
+                    EntityStorage.copyEntities(mergeFrom, save);
+                }
+            }
+            if (save == null && this.lastEntitySaveNull) {
+                return false;
+            }
+
+            RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, save, RegionFileIOThread.RegionFileType.ENTITY_DATA);
+            this.lastEntitySaveNull = save == null;
+            if (unloading) {
+                this.lastEntityUnload = save;
+            }
+        } catch (final ThreadDeath death) {
+            throw death;
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to save entity data (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "'");
+        }
+
+        return true;
+    }
+
+    private boolean lastPoiSaveNull;
+    private boolean savePOI(final PoiChunk poi, final boolean unloading) {
+        try {
+            final CompoundTag save = poi.save();
+            poi.setDirty(false);
+            if (save == null && this.lastPoiSaveNull) {
+                if (unloading) {
+                    this.poiDataUnload.completable().complete(null);
+                }
+                return false;
+            }
+
+            RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, save, RegionFileIOThread.RegionFileType.POI_DATA);
+            this.lastPoiSaveNull = save == null;
+            if (unloading) {
+                this.poiDataUnload.completable().complete(save);
+            }
+        } catch (final ThreadDeath death) {
+            throw death;
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to save poi data (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "'");
+        }
+
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        final ChunkCompletion lastCompletion = this.lastChunkCompletion;
+        final ChunkEntitySlices entityChunk = this.entityChunk;
+        final long chunkStatus = this.chunkStatus;
+        final int fullChunkStatus = (int)chunkStatus;
+        final int pendingChunkStatus = (int)(chunkStatus >>> 32);
+        final ChunkHolder.FullChunkStatus currentFullStatus = fullChunkStatus < 0 || fullChunkStatus >= CHUNK_STATUS_BY_ID.length ? null : CHUNK_STATUS_BY_ID[fullChunkStatus];
+        final ChunkHolder.FullChunkStatus pendingFullStatus = pendingChunkStatus < 0 || pendingChunkStatus >= CHUNK_STATUS_BY_ID.length ? null : CHUNK_STATUS_BY_ID[pendingChunkStatus];
+        return "NewChunkHolder{" +
+            "world=" + this.world.getWorld().getName() +
+            ", chunkX=" + this.chunkX +
+            ", chunkZ=" + this.chunkZ +
+            ", entityChunkFromDisk=" + (entityChunk != null && !entityChunk.isTransient()) +
+            ", lastChunkCompletion={chunk_class=" + (lastCompletion == null || lastCompletion.chunk() == null ? "null" : lastCompletion.chunk().getClass().getName()) + ",status=" + (lastCompletion == null ? "null" : lastCompletion.genStatus()) + "}" +
+            ", currentGenStatus=" + this.currentGenStatus +
+            ", requestedGenStatus=" + this.requestedGenStatus +
+            ", generationTask=" + this.generationTask +
+            ", generationTaskStatus=" + this.generationTaskStatus +
+            ", priority=" + this.priority +
+            ", priorityLocked=" + this.priorityLocked +
+            ", neighbourRequestedPriority=" + this.neighbourRequestedPriority +
+            ", effective_priority=" + this.getEffectivePriority() +
+            ", oldTicketLevel=" + this.oldTicketLevel +
+            ", currentTicketLevel=" + this.currentTicketLevel +
+            ", totalNeighboursUsingThisChunk=" + this.totalNeighboursUsingThisChunk +
+            ", fullNeighbourChunksLoadedBitset=" + this.fullNeighbourChunksLoadedBitset +
+            ", chunkStatusRaw=" + chunkStatus +
+            ", currentChunkStatus=" + currentFullStatus +
+            ", pendingChunkStatus=" + pendingFullStatus +
+            ", is_unload_safe=" + this.isSafeToUnload() +
+            ", killed=" + this.killed +
+            '}';
+    }
+
+    private static JsonElement serializeCompletable(final Completable<?> completable) {
+        if (completable == null) {
+            return new JsonPrimitive("null");
+        }
+
+        final JsonObject ret = new JsonObject();
+        final boolean isCompleted = completable.isCompleted();
+        ret.addProperty("completed", Boolean.valueOf(isCompleted));
+
+        if (isCompleted) {
+            ret.addProperty("completed_exceptionally", Boolean.valueOf(completable.getThrowable() != null));
+        }
+
+        return ret;
+    }
+
+    // holds ticket and scheduling lock
+    public JsonObject getDebugJson() {
+        final JsonObject ret = new JsonObject();
+
+        final ChunkCompletion lastCompletion = this.lastChunkCompletion;
+        final ChunkEntitySlices slices = this.entityChunk;
+        final PoiChunk poiChunk = this.poiChunk;
+
+        ret.addProperty("chunkX", Integer.valueOf(this.chunkX));
+        ret.addProperty("chunkZ", Integer.valueOf(this.chunkZ));
+        ret.addProperty("entity_chunk", slices == null ? "null" : "transient=" + slices.isTransient());
+        ret.addProperty("poi_chunk", "null=" + (poiChunk == null));
+        ret.addProperty("completed_chunk_class", lastCompletion == null ? "null" : lastCompletion.chunk().getClass().getName());
+        ret.addProperty("completed_gen_status", lastCompletion == null ? "null" : lastCompletion.genStatus().toString());
+        ret.addProperty("priority", Objects.toString(this.priority));
+        ret.addProperty("neighbour_requested_priority", Objects.toString(this.neighbourRequestedPriority));
+        ret.addProperty("generation_task", Objects.toString(this.generationTask));
+        ret.addProperty("is_safe_unload", Objects.toString(this.isSafeToUnload()));
+        ret.addProperty("old_ticket_level", Integer.valueOf(this.oldTicketLevel));
+        ret.addProperty("current_ticket_level", Integer.valueOf(this.currentTicketLevel));
+        ret.addProperty("neighbours_using_chunk", Integer.valueOf(this.totalNeighboursUsingThisChunk));
+
+        final JsonObject neighbourWaitState = new JsonObject();
+        ret.add("neighbour_state", neighbourWaitState);
+
+        final JsonArray blockingGenNeighbours = new JsonArray();
+        neighbourWaitState.add("blocking_gen_task", blockingGenNeighbours);
+        for (final NewChunkHolder blockingGenNeighbour : this.neighboursBlockingGenTask) {
+            final JsonObject neighbour = new JsonObject();
+            blockingGenNeighbours.add(neighbour);
+
+            neighbour.addProperty("chunkX", Integer.valueOf(blockingGenNeighbour.chunkX));
+            neighbour.addProperty("chunkZ", Integer.valueOf(blockingGenNeighbour.chunkZ));
+        }
+
+        final JsonArray neighboursWaitingForUs = new JsonArray();
+        neighbourWaitState.add("neighbours_waiting_on_us", neighboursWaitingForUs);
+        for (final Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus> entry : this.neighboursWaitingForUs.reference2ObjectEntrySet()) {
+            final NewChunkHolder holder = entry.getKey();
+            final ChunkStatus status = entry.getValue();
+
+            final JsonObject neighbour = new JsonObject();
+            neighboursWaitingForUs.add(neighbour);
+
+
+            neighbour.addProperty("chunkX", Integer.valueOf(holder.chunkX));
+            neighbour.addProperty("chunkZ", Integer.valueOf(holder.chunkZ));
+            neighbour.addProperty("waiting_for", Objects.toString(status));
+        }
+
+        ret.addProperty("fullchunkstatus", Objects.toString(this.getChunkStatus()));
+        ret.addProperty("fullchunkstatus_raw", Long.valueOf(this.chunkStatus));
+        ret.addProperty("generation_task", Objects.toString(this.generationTask));
+        ret.addProperty("requested_generation", Objects.toString(this.requestedGenStatus));
+        ret.addProperty("has_entity_load_task", Boolean.valueOf(this.entityDataLoadTask != null));
+        ret.addProperty("has_poi_load_task", Boolean.valueOf(this.poiDataLoadTask != null));
+
+        final UnloadTask entityDataUnload = this.entityDataUnload;
+        final UnloadTask poiDataUnload = this.poiDataUnload;
+        final UnloadTask chunkDataUnload = this.chunkDataUnload;
+
+        ret.add("entity_unload_completable", serializeCompletable(entityDataUnload == null ? null : entityDataUnload.completable()));
+        ret.add("poi_unload_completable", serializeCompletable(poiDataUnload == null ? null : poiDataUnload.completable()));
+        ret.add("chunk_unload_completable", serializeCompletable(chunkDataUnload == null ? null : chunkDataUnload.completable()));
+
+        final DelayedPrioritisedTask unloadTask = chunkDataUnload == null ? null : chunkDataUnload.task();
+        if (unloadTask == null) {
+            ret.addProperty("unload_task_priority", "null");
+            ret.addProperty("unload_task_priority_raw", "null");
+        } else {
+            ret.addProperty("unload_task_priority", Objects.toString(unloadTask.getPriority()));
+            ret.addProperty("unload_task_priority_raw", Integer.valueOf(unloadTask.getPriorityInternal()));
+        }
+
+        ret.addProperty("killed", Boolean.valueOf(this.killed));
+
+        return ret;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/PriorityHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/PriorityHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..b4c56bf12dc8dd17452210ece4fd67411cc6b2fd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/PriorityHolder.java
@@ -0,0 +1,215 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import java.lang.invoke.VarHandle;
+
+public abstract class PriorityHolder {
+
+    protected volatile int priority;
+    protected static final VarHandle PRIORITY_HANDLE = ConcurrentUtil.getVarHandle(PriorityHolder.class, "priority", int.class);
+
+    protected static final int PRIORITY_SCHEDULED = Integer.MIN_VALUE >>> 0;
+    protected static final int PRIORITY_EXECUTED  = Integer.MIN_VALUE >>> 1;
+
+    protected final int getPriorityVolatile() {
+        return (int)PRIORITY_HANDLE.getVolatile((PriorityHolder)this);
+    }
+
+    protected final int compareAndExchangePriorityVolatile(final int expect, final int update) {
+        return (int)PRIORITY_HANDLE.compareAndExchange((PriorityHolder)this, (int)expect, (int)update);
+    }
+
+    protected final int getAndOrPriorityVolatile(final int val) {
+        return (int)PRIORITY_HANDLE.getAndBitwiseOr((PriorityHolder)this, (int)val);
+    }
+
+    protected final void setPriorityPlain(final int val) {
+        PRIORITY_HANDLE.set((PriorityHolder)this, (int)val);
+    }
+
+    protected PriorityHolder(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.setPriorityPlain(priority.priority);
+    }
+
+    // used only for debug json
+    public boolean isScheduled() {
+        return (this.getPriorityVolatile() & PRIORITY_SCHEDULED) != 0;
+    }
+
+    // returns false if cancelled
+    protected boolean markExecuting() {
+        return (this.getAndOrPriorityVolatile(PRIORITY_EXECUTED) & PRIORITY_EXECUTED) == 0;
+    }
+
+    protected boolean isMarkedExecuted() {
+        return (this.getPriorityVolatile() & PRIORITY_EXECUTED) != 0;
+    }
+
+    public void cancel() {
+        if ((this.getAndOrPriorityVolatile(PRIORITY_EXECUTED) & PRIORITY_EXECUTED) != 0) {
+            // cancelled already
+            return;
+        }
+        this.cancelScheduled();
+    }
+
+    public void schedule() {
+        int priority = this.getPriorityVolatile();
+
+        if ((priority & PRIORITY_SCHEDULED) != 0) {
+            throw new IllegalStateException("schedule() called twice");
+        }
+
+        if ((priority & PRIORITY_EXECUTED) != 0) {
+            // cancelled
+            return;
+        }
+
+        this.scheduleTask(PrioritisedExecutor.Priority.getPriority(priority));
+
+        int failures = 0;
+        for (;;) {
+            if (priority == (priority = this.compareAndExchangePriorityVolatile(priority, priority | PRIORITY_SCHEDULED))) {
+                return;
+            }
+
+            if ((priority & PRIORITY_SCHEDULED) != 0) {
+                throw new IllegalStateException("schedule() called twice");
+            }
+
+            if ((priority & PRIORITY_EXECUTED) != 0) {
+                // cancelled or executed
+                return;
+            }
+
+            this.setPriorityScheduled(PrioritisedExecutor.Priority.getPriority(priority));
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public final PrioritisedExecutor.Priority getPriority() {
+        final int ret = this.getPriorityVolatile();
+        if ((ret & PRIORITY_EXECUTED) != 0) {
+            return PrioritisedExecutor.Priority.COMPLETING;
+        }
+        if ((ret & PRIORITY_SCHEDULED) != 0) {
+            return this.getScheduledPriority();
+        }
+        return PrioritisedExecutor.Priority.getPriority(ret);
+    }
+
+    public final void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+
+        int failures = 0;
+        for (int curr = this.getPriorityVolatile();;) {
+            if ((curr & PRIORITY_EXECUTED) != 0) {
+                return;
+            }
+
+            if ((curr & PRIORITY_SCHEDULED) != 0) {
+                this.lowerPriorityScheduled(priority);
+                return;
+            }
+
+            if (!priority.isLowerPriority(curr)) {
+                return;
+            }
+
+            if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority))) {
+                return;
+            }
+
+            // failed, retry
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public final void setPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+
+        int failures = 0;
+        for (int curr = this.getPriorityVolatile();;) {
+            if ((curr & PRIORITY_EXECUTED) != 0) {
+                return;
+            }
+
+            if ((curr & PRIORITY_SCHEDULED) != 0) {
+                this.setPriorityScheduled(priority);
+                return;
+            }
+
+            if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority))) {
+                return;
+            }
+
+            // failed, retry
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public final void raisePriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+
+        int failures = 0;
+        for (int curr = this.getPriorityVolatile();;) {
+            if ((curr & PRIORITY_EXECUTED) != 0) {
+                return;
+            }
+
+            if ((curr & PRIORITY_SCHEDULED) != 0) {
+                this.raisePriorityScheduled(priority);
+                return;
+            }
+
+            if (!priority.isHigherPriority(curr)) {
+                return;
+            }
+
+            if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority))) {
+                return;
+            }
+
+            // failed, retry
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    protected abstract void cancelScheduled();
+
+    protected abstract PrioritisedExecutor.Priority getScheduledPriority();
+
+    protected abstract void scheduleTask(final PrioritisedExecutor.Priority priority);
+
+    protected abstract void lowerPriorityScheduled(final PrioritisedExecutor.Priority priority);
+
+    protected abstract void setPriorityScheduled(final PrioritisedExecutor.Priority priority);
+
+    protected abstract void raisePriorityScheduled(final PrioritisedExecutor.Priority priority);
+}
diff --git a/src/main/java/io/papermc/paper/command/PaperCommand.java b/src/main/java/io/papermc/paper/command/PaperCommand.java
index 60b0ce4557390ee7030efe4c90933402c57bab59..0167864dd8fbc8145af31597040d187a0660228c 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommand.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommand.java
@@ -45,7 +45,7 @@ public final class PaperCommand extends Command {
         commands.put(Set.of("entity"), new EntityCommand());
         commands.put(Set.of("reload"), new ReloadCommand());
         commands.put(Set.of("version"), new VersionCommand());
-        commands.put(Set.of("debug", "chunkinfo"), new ChunkDebugCommand());
+        commands.put(Set.of("debug", "chunkinfo", "holderinfo"), new ChunkDebugCommand());
         commands.put(Set.of("fixlight"), new FixLightCommand());
         commands.put(Set.of("syncloadinfo"), new SyncLoadInfoCommand());
         commands.put(Set.of("dumpitem"), new DumpItemCommand());
diff --git a/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java b/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
index 28a9550449be9a212f054b02e43fbd8a3781efcf..628c549b1436c3de75071ecd6182a9beadd4840b 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
@@ -13,6 +13,10 @@ import net.minecraft.server.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
 import org.bukkit.Bukkit;
 import org.bukkit.command.CommandSender;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -33,6 +37,7 @@ public final class ChunkDebugCommand implements PaperSubcommand {
         switch (subCommand) {
             case "debug" -> this.doDebug(sender, args);
             case "chunkinfo" -> this.doChunkInfo(sender, args);
+            case "holderinfo" -> this.doHolderInfo(sender, args);
         }
         return true;
     }
@@ -45,6 +50,16 @@ public final class ChunkDebugCommand implements PaperSubcommand {
                     return CommandUtil.getListMatchingLast(sender, args, "help", "chunks");
                 }
             }
+            case "holderinfo" -> {
+                List<String> worldNames = new ArrayList<>();
+                worldNames.add("*");
+                for (org.bukkit.World world : Bukkit.getWorlds()) {
+                    worldNames.add(world.getName());
+                }
+                if (args.length == 1) {
+                    return CommandUtil.getListMatchingLast(sender, args, worldNames);
+                }
+            }
             case "chunkinfo" -> {
                 List<String> worldNames = new ArrayList<>();
                 worldNames.add("*");
@@ -134,6 +149,89 @@ public final class ChunkDebugCommand implements PaperSubcommand {
         }
     }
 
+    private void doHolderInfo(final CommandSender sender, final String[] args) {
+        List<org.bukkit.World> worlds;
+        if (args.length < 1 || args[0].equals("*")) {
+            worlds = Bukkit.getWorlds();
+        } else {
+            worlds = new ArrayList<>(args.length);
+            for (final String arg : args) {
+                org.bukkit.@Nullable World world = Bukkit.getWorld(arg);
+                if (world == null) {
+                    sender.sendMessage(text("World '" + arg + "' is invalid", RED));
+                    return;
+                }
+                worlds.add(world);
+            }
+        }
+
+        int accumulatedTotal = 0;
+        int accumulatedCanUnload = 0;
+        int accumulatedNull = 0;
+        int accumulatedReadOnly = 0;
+        int accumulatedProtoChunk = 0;
+        int accumulatedFullChunk = 0;
+
+        for (final org.bukkit.World bukkitWorld : worlds) {
+            final ServerLevel world = ((CraftWorld) bukkitWorld).getHandle();
+
+            int total = 0;
+            int canUnload = 0;
+            int nullChunks = 0;
+            int readOnly = 0;
+            int protoChunk = 0;
+            int fullChunk = 0;
+
+            for (final ChunkHolder chunk : world.chunkTaskScheduler.chunkHolderManager.getOldChunkHolders()) { // Paper - change updating chunks map
+                final ChunkAccess lastChunk = chunk.getAvailableChunkNow();
+
+                ++total;
+
+                if (lastChunk == null) {
+                    ++nullChunks;
+                } else if (lastChunk instanceof ImposterProtoChunk) {
+                    ++readOnly;
+                } else if (lastChunk instanceof ProtoChunk) {
+                    ++protoChunk;
+                } else if (lastChunk instanceof LevelChunk) {
+                    ++fullChunk;
+                }
+
+                if (chunk.newChunkHolder.isSafeToUnload() == null) {
+                    ++canUnload;
+                }
+            }
+
+            accumulatedTotal += total;
+            accumulatedCanUnload += canUnload;
+            accumulatedNull += nullChunks;
+            accumulatedReadOnly += readOnly;
+            accumulatedProtoChunk += protoChunk;
+            accumulatedFullChunk += fullChunk;
+
+            sender.sendMessage(text().append(text("Chunks in ", BLUE), text(bukkitWorld.getName(), GREEN), text(":")));
+            sender.sendMessage(text().color(DARK_AQUA).append(
+                text("Total: ", BLUE), text(total),
+                text(" Unloadable: ", BLUE), text(canUnload),
+                text(" Null: ", BLUE), text(nullChunks),
+                text(" ReadOnly: ", BLUE), text(readOnly),
+                text(" Proto: ", BLUE), text(protoChunk),
+                text(" Full: ", BLUE), text(fullChunk)
+            ));
+        }
+        if (worlds.size() > 1) {
+            sender.sendMessage(text().append(text("Chunks in ", BLUE), text("all listed worlds", GREEN), text(":", DARK_AQUA)));
+            sender.sendMessage(text().color(DARK_AQUA).append(
+                text("Total: ", BLUE), text(accumulatedTotal),
+                text(" Unloadable: ", BLUE), text(accumulatedCanUnload),
+                text(" Null: ", BLUE), text(accumulatedNull),
+                text(" ReadOnly: ", BLUE), text(accumulatedReadOnly),
+                text(" Proto: ", BLUE), text(accumulatedProtoChunk),
+                text(" Full: ", BLUE), text(accumulatedFullChunk)
+            ));
+        }
+    }
+
     private void doDebug(final CommandSender sender, final String[] args) {
         if (args.length < 1) {
             sender.sendMessage(text("Use /paper debug [chunks] help for more information on a specific command", RED));
@@ -151,7 +249,7 @@ public final class ChunkDebugCommand implements PaperSubcommand {
                     "chunks-" + DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss").format(LocalDateTime.now()) + ".txt");
                 sender.sendMessage(text("Writing chunk information dump to " + file, GREEN));
                 try {
-                    MCUtil.dumpChunks(file);
+                    MCUtil.dumpChunks(file, false);
                     sender.sendMessage(text("Successfully written chunk information!", GREEN));
                 } catch (Throwable thr) {
                     MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file.toString(), thr);
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 0c61d1c65ce2c6d13bdfe2f96a3dc16aace07742..0e94a67cd866519d556f0d43ef16555a193e908b 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -132,6 +132,20 @@ public class GlobalConfiguration extends ConfigurationPart {
         public double playerMaxChunkLoadRate = -1.0;
     }
 
+    public ChunkSystem chunkSystem;
+
+    public class ChunkSystem extends ConfigurationPart.Post {
+
+        public int ioThreads = -1;
+        public int workerThreads = -1;
+        public String genParallelism = "default";
+
+        @Override
+        public void postProcess() {
+            io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.init(this);
+        }
+    }
+
     public UnsupportedSettings unsupportedSettings;
 
     public class UnsupportedSettings extends ConfigurationPart {
diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index d59885ee9c8b29d5bac34dce0597e345e5358c77..fc57850b80303fcade89ca95794f63910404a407 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -6,7 +6,7 @@ import net.minecraft.world.entity.Entity;
 import org.bukkit.Bukkit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-public final class TickThread extends Thread {
+public class TickThread extends Thread {
 
     public static final boolean STRICT_THREAD_CHECKS = Boolean.getBoolean("paper.strict-thread-checks");
 
@@ -16,6 +16,10 @@ public final class TickThread extends Thread {
         }
     }
 
+    /**
+     * @deprecated
+     */
+    @Deprecated
     public static void softEnsureTickThread(final String reason) {
         if (!STRICT_THREAD_CHECKS) {
             return;
@@ -23,6 +27,10 @@ public final class TickThread extends Thread {
         ensureTickThread(reason);
     }
 
+    /**
+     * @deprecated
+     */
+    @Deprecated
     public static void ensureTickThread(final String reason) {
         if (!isTickThread()) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
@@ -66,14 +74,14 @@ public final class TickThread extends Thread {
     }
 
     public static boolean isTickThread() {
-        return Bukkit.isPrimaryThread();
+        return Thread.currentThread() instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final int chunkX, final int chunkZ) {
-        return Bukkit.isPrimaryThread();
+        return Thread.currentThread() instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final Entity entity) {
-        return Bukkit.isPrimaryThread();
+        return Thread.currentThread() instanceof TickThread;
     }
 }
diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index 47b5f75d9f27cf3ab947fd1f69cbd609fb9f2749..a0714c48b141a36009afdb30d4bf5429601d37dd 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -1,8 +1,10 @@
 package io.papermc.paper.world;
 
 import com.destroystokyo.paper.util.maplist.EntityList;
+import io.papermc.paper.chunk.system.entity.EntityLookup;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
+import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.Mth;
@@ -10,7 +12,12 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.storage.EntityStorage;
+import net.minecraft.world.level.entity.Visibility;
 import net.minecraft.world.phys.AABB;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
@@ -20,8 +27,8 @@ public final class ChunkEntitySlices {
 
     protected final int minSection;
     protected final int maxSection;
-    protected final int chunkX;
-    protected final int chunkZ;
+    public final int chunkX;
+    public final int chunkZ;
     protected final ServerLevel world;
 
     protected final EntityCollectionBySection allEntities;
@@ -31,6 +38,16 @@ public final class ChunkEntitySlices {
 
     public ChunkHolder.FullChunkStatus status;
 
+    protected boolean isTransient;
+
+    public boolean isTransient() {
+        return this.isTransient;
+    }
+
+    public void setTransient(final boolean value) {
+        this.isTransient = value;
+    }
+
     // TODO implement container search optimisations
 
     public ChunkEntitySlices(final ServerLevel world, final int chunkX, final int chunkZ, final ChunkHolder.FullChunkStatus status,
@@ -65,28 +82,121 @@ public final class ChunkEntitySlices {
 
         return ret.toArray(new org.bukkit.entity.Entity[0]);
     }
+
+    public CompoundTag save() {
+        final int len = this.entities.size();
+        if (len == 0) {
+            return null;
+        }
+
+        final Entity[] rawData = this.entities.getRawData();
+        final List<Entity> collectedEntities = new ArrayList<>(len);
+        for (int i = 0; i < len; ++i) {
+            final Entity entity = rawData[i];
+            if (entity.shouldBeSaved()) {
+                collectedEntities.add(entity);
+            }
+        }
+
+        if (collectedEntities.isEmpty()) {
+            return null;
+        }
+
+        return EntityStorage.saveEntityChunk(collectedEntities, new ChunkPos(this.chunkX, this.chunkZ), this.world);
+    }
+
+    // returns true if this chunk has transient entities remaining
+    public boolean unload() {
+        final int len = this.entities.size();
+        final Entity[] collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
+
+        for (int i = 0; i < len; ++i) {
+            final Entity entity = collectedEntities[i];
+            if (entity.isRemoved()) {
+                // removed by us below
+                continue;
+            }
+            if (entity.shouldBeSaved()) {
+                entity.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+                if (entity.isVehicle()) {
+                    // we cannot assume that these entities are contained within this chunk, because entities can
+                    // desync - so we need to remove them all
+                    for (final Entity passenger : entity.getIndirectPassengers()) {
+                        passenger.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+                    }
+                }
+            }
+        }
+
+        return this.entities.size() != 0;
+    }
+
+    private List<Entity> getAllEntities() {
+        final int len = this.entities.size();
+        if (len == 0) {
+            return new ArrayList<>();
+        }
+
+        final Entity[] rawData = this.entities.getRawData();
+        final List<Entity> collectedEntities = new ArrayList<>(len);
+        for (int i = 0; i < len; ++i) {
+            collectedEntities.add(rawData[i]);
+        }
+
+        return collectedEntities;
+    }
+
+    public void callEntitiesLoadEvent() {
+        CraftEventFactory.callEntitiesLoadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), this.getAllEntities());
+    }
+
+    public void callEntitiesUnloadEvent() {
+        CraftEventFactory.callEntitiesUnloadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), this.getAllEntities());
+    }
     // Paper end - optimise CraftChunk#getEntities
 
     public boolean isEmpty() {
         return this.entities.size() == 0;
     }
 
-    private void updateTicketLevels() {
+    public void mergeInto(final ChunkEntitySlices slices) {
         final Entity[] entities = this.entities.getRawData();
         for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
             final Entity entity = entities[i];
-            entity.chunkStatus = this.status;
+            slices.addEntity(entity, entity.sectionY);
         }
     }
 
-    public synchronized void updateStatus(final ChunkHolder.FullChunkStatus status) {
+    private boolean preventStatusUpdates;
+    public boolean startPreventingStatusUpdates() {
+        final boolean ret = this.preventStatusUpdates;
+        this.preventStatusUpdates = true;
+        return ret;
+    }
+
+    public void stopPreventingStatusUpdates(final boolean prev) {
+        this.preventStatusUpdates = prev;
+    }
+
+    public void updateStatus(final ChunkHolder.FullChunkStatus status, final EntityLookup lookup) {
         this.status = status;
-        this.updateTicketLevels();
+
+        final Entity[] entities = this.entities.getRawData();
+
+        for (int i = 0, size = this.entities.size(); i < size; ++i) {
+            final Entity entity = entities[i];
+
+            final Visibility oldVisibility = EntityLookup.getEntityStatus(entity);
+            entity.chunkStatus = status;
+            final Visibility newVisibility = EntityLookup.getEntityStatus(entity);
+
+            lookup.entityStatusChange(entity, this, oldVisibility, newVisibility, false, false, false);
+        }
     }
 
-    public synchronized void addEntity(final Entity entity, final int chunkSection) {
+    public boolean addEntity(final Entity entity, final int chunkSection) {
         if (!this.entities.add(entity)) {
-            return;
+            return false;
         }
         entity.chunkStatus = this.status;
         final int sectionIndex = chunkSection - this.minSection;
@@ -105,13 +215,15 @@ public final class ChunkEntitySlices {
                 entry.getValue().addEntity(entity, sectionIndex);
             }
         }
+
+        return true;
     }
 
-    public synchronized void removeEntity(final Entity entity, final int chunkSection) {
+    public boolean removeEntity(final Entity entity, final int chunkSection) {
         if (!this.entities.remove(entity)) {
-            return;
+            return false;
         }
-        entity.chunkStatus = ChunkHolder.FullChunkStatus.INACCESSIBLE;
+        entity.chunkStatus = null;
         final int sectionIndex = chunkSection - this.minSection;
 
         this.allEntities.removeEntity(entity, sectionIndex);
@@ -128,6 +240,8 @@ public final class ChunkEntitySlices {
                 entry.getValue().removeEntity(entity, sectionIndex);
             }
         }
+
+        return true;
     }
 
     public void getHardCollidingEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
@@ -138,6 +252,10 @@ public final class ChunkEntitySlices {
         this.allEntities.getEntitiesWithEnderDragonParts(except, box, into, predicate);
     }
 
+    public void getEntitiesWithoutDragonParts(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
+        this.allEntities.getEntities(except, box, into, predicate);
+    }
+
     public <T extends Entity> void getEntities(final EntityType<?> type, final AABB box, final List<? super T> into,
                                                final Predicate<? super T> predicate) {
         this.allEntities.getEntities(type, box, (List)into, (Predicate)predicate);
@@ -172,21 +290,11 @@ public final class ChunkEntitySlices {
         if (collection != null) {
             collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
         } else {
-            synchronized (this) {
-                this.entitiesByClass.putIfAbsent(clazz, collection = this.initClass(clazz));
-            }
+            this.entitiesByClass.putIfAbsent(clazz, collection = this.initClass(clazz));
             collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
         }
     }
 
-    public synchronized void updateEntity(final Entity entity) {
-        /*// TODO
-        if (prev aabb != entity.getBoundingBox()) {
-            this.entityMap.delete(entity, prev aabb);
-            this.entityMap.insert(entity, prev aabb = entity.getBoundingBox());
-        }*/
-    }
-
     protected static final class BasicEntityList<E extends Entity> {
 
         protected static final Entity[] EMPTY = new Entity[0];
@@ -321,8 +429,6 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            // TODO use the bitset
-
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
@@ -362,8 +468,6 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            // TODO use the bitset
-
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
@@ -415,8 +519,6 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            // TODO use the bitset
-
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
@@ -468,8 +570,6 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            // TODO use the bitset
-
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
diff --git a/src/main/java/io/papermc/paper/world/EntitySliceManager.java b/src/main/java/io/papermc/paper/world/EntitySliceManager.java
index 3ba094e640d7fe7803e2bbdab8ff3beb6f50e8a0..6608e54922a1e35a8719742e3020110526de1053 100644
--- a/src/main/java/io/papermc/paper/world/EntitySliceManager.java
+++ b/src/main/java/io/papermc/paper/world/EntitySliceManager.java
@@ -46,7 +46,7 @@ public final class EntitySliceManager {
             this.statusMap.put(CoordinateUtils.getChunkKey(x, z), newStatus);
             final ChunkEntitySlices slices = this.getChunk(x, z);
             if (slices != null) {
-                slices.updateStatus(newStatus);
+                //slices.updateStatus(newStatus); // Paper - rewrite chunk system - not used, don't care! delete patch later!
             }
         }
     }
diff --git a/src/main/java/net/minecraft/server/ChunkSystem.java b/src/main/java/net/minecraft/server/ChunkSystem.java
index 81ea64443a843736f9ada97900d173c302e39ba0..e191fb38e64e5f8da2b84bc8eb392e6382d46588 100644
--- a/src/main/java/net/minecraft/server/ChunkSystem.java
+++ b/src/main/java/net/minecraft/server/ChunkSystem.java
@@ -30,7 +30,7 @@ public final class ChunkSystem {
     }
 
     public static void scheduleChunkTask(final ServerLevel level, final int chunkX, final int chunkZ, final Runnable run, final PrioritisedExecutor.Priority priority) {
-        level.chunkSource.mainThreadProcessor.execute(run);
+        level.chunkTaskScheduler.scheduleChunkTask(chunkX, chunkZ, run, priority); // Paper - rewrite chunk system
     }
 
     public static void scheduleChunkLoad(final ServerLevel level, final int chunkX, final int chunkZ, final boolean gen,
@@ -53,206 +53,32 @@ public final class ChunkSystem {
         });
     }
 
-    static final TicketType<Long> CHUNK_LOAD = TicketType.create("chunk_load", Long::compareTo);
-
-    // Paper start - priority
-    private static int getPriorityBoost(final PrioritisedExecutor.Priority priority) {
-        if (priority.isLowerOrEqualPriority(PrioritisedExecutor.Priority.NORMAL)) {
-            return 0;
-        }
-
-        int dist = PrioritisedExecutor.Priority.BLOCKING.ordinal() - PrioritisedExecutor.Priority.NORMAL.ordinal();
-
-
-        return (net.minecraft.server.level.DistanceManager.URGENT_PRIORITY * (priority.ordinal() - PrioritisedExecutor.Priority.NORMAL.ordinal())) / dist;
-    }
-    // Paper end - priority
-
-    private static long chunkLoadCounter = 0L;
+    // Paper - rewrite chunk system
     public static void scheduleChunkLoad(final ServerLevel level, final int chunkX, final int chunkZ, final ChunkStatus toStatus,
                                          final boolean addTicket, final PrioritisedExecutor.Priority priority, final Consumer<ChunkAccess> onComplete) {
-        if (!Bukkit.isPrimaryThread()) {
-            scheduleChunkTask(level, chunkX, chunkZ, () -> {
-                scheduleChunkLoad(level, chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
-            }, priority);
-            return;
-        }
-
-        final int minLevel = 33 + ChunkStatus.getDistance(toStatus);
-        final Long chunkReference = addTicket ? Long.valueOf(++chunkLoadCounter) : null;
-        final ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
-        final int priorityBoost = getPriorityBoost(priority);
-
-        if (addTicket) {
-            level.chunkSource.addTicketAtLevel(CHUNK_LOAD, chunkPos, minLevel, chunkReference);
-        }
-        level.chunkSource.runDistanceManagerUpdates();
-
-        if (priorityBoost == net.minecraft.server.level.DistanceManager.URGENT_PRIORITY) {
-            level.chunkSource.markUrgent(chunkPos);
-        } else if (priorityBoost != 0) {
-            level.chunkSource.markHighPriority(chunkPos, priorityBoost);
-        }
-
-        final Consumer<ChunkAccess> loadCallback = (final ChunkAccess chunk) -> {
-            try {
-                if (onComplete != null) {
-                    onComplete.accept(chunk);
-                }
-            } catch (final ThreadDeath death) {
-                throw death;
-            } catch (final Throwable thr) {
-                LOGGER.error("Exception handling chunk load callback", thr);
-                SneakyThrow.sneaky(thr);
-            } finally {
-                if (addTicket) {
-                    level.chunkSource.addTicketAtLevel(TicketType.UNKNOWN, chunkPos, minLevel, chunkPos);
-                    level.chunkSource.removeTicketAtLevel(CHUNK_LOAD, chunkPos, minLevel, chunkReference);
-                }
-                if (priorityBoost == net.minecraft.server.level.DistanceManager.URGENT_PRIORITY) {
-                    level.chunkSource.clearUrgent(chunkPos);
-                } else if (priorityBoost != 0) {
-                    level.chunkSource.clearPriorityTickets(chunkPos);
-                }
-            }
-        };
-
-        final ChunkHolder holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(CoordinateUtils.getChunkKey(chunkX, chunkZ));
-
-        if (holder == null || holder.getTicketLevel() > minLevel) {
-            loadCallback.accept(null);
-            return;
-        }
-
-        final CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> loadFuture = holder.getOrScheduleFuture(toStatus, level.chunkSource.chunkMap);
-
-        if (loadFuture.isDone()) {
-            loadCallback.accept(loadFuture.join().left().orElse(null));
-            return;
-        }
-
-        loadFuture.whenCompleteAsync((final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either, final Throwable thr) -> {
-            if (thr != null) {
-                loadCallback.accept(null);
-                return;
-            }
-            loadCallback.accept(either.left().orElse(null));
-        }, (final Runnable r) -> {
-            scheduleChunkTask(level, chunkX, chunkZ, r, PrioritisedExecutor.Priority.HIGHEST);
-        });
+        level.chunkTaskScheduler.scheduleChunkLoad(chunkX, chunkZ, toStatus, addTicket, priority, onComplete); // Paper - rewrite chunk system
     }
 
     public static void scheduleTickingState(final ServerLevel level, final int chunkX, final int chunkZ,
                                             final ChunkHolder.FullChunkStatus toStatus, final boolean addTicket,
                                             final PrioritisedExecutor.Priority priority, final Consumer<LevelChunk> onComplete) {
-        if (toStatus == ChunkHolder.FullChunkStatus.INACCESSIBLE) {
-            throw new IllegalArgumentException("Cannot wait for INACCESSIBLE status");
-        }
-
-        if (!Bukkit.isPrimaryThread()) {
-            scheduleChunkTask(level, chunkX, chunkZ, () -> {
-                scheduleTickingState(level, chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
-            }, priority);
-            return;
-        }
-
-        final int minLevel = 33 - (toStatus.ordinal() - 1);
-        final int radius = toStatus.ordinal() - 1;
-        final Long chunkReference = addTicket ? Long.valueOf(++chunkLoadCounter) : null;
-        final ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
-        final int priorityBoost = getPriorityBoost(priority);
-
-        if (addTicket) {
-            level.chunkSource.addTicketAtLevel(CHUNK_LOAD, chunkPos, minLevel, chunkReference);
-        }
-        level.chunkSource.runDistanceManagerUpdates();
-
-        if (priorityBoost != 0) {
-            level.chunkSource.markAreaHighPriority(chunkPos, priorityBoost, radius);
-        }
-
-        final Consumer<LevelChunk> loadCallback = (final LevelChunk chunk) -> {
-            try {
-                if (onComplete != null) {
-                    onComplete.accept(chunk);
-                }
-            } catch (final ThreadDeath death) {
-                throw death;
-            } catch (final Throwable thr) {
-                LOGGER.error("Exception handling chunk load callback", thr);
-                SneakyThrow.sneaky(thr);
-            } finally {
-                if (addTicket) {
-                    level.chunkSource.addTicketAtLevel(TicketType.UNKNOWN, chunkPos, minLevel, chunkPos);
-                    level.chunkSource.removeTicketAtLevel(CHUNK_LOAD, chunkPos, minLevel, chunkReference);
-                }
-                if (priorityBoost != 0) {
-                    level.chunkSource.clearAreaPriorityTickets(chunkPos, radius);
-                }
-            }
-        };
-
-        final ChunkHolder holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(CoordinateUtils.getChunkKey(chunkX, chunkZ));
-
-        if (holder == null || holder.getTicketLevel() > minLevel) {
-            loadCallback.accept(null);
-            return;
-        }
-
-        final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> tickingState;
-        switch (toStatus) {
-            case BORDER: {
-                tickingState = holder.getFullChunkFuture();
-                break;
-            }
-            case TICKING: {
-                tickingState = holder.getTickingChunkFuture();
-                break;
-            }
-            case ENTITY_TICKING: {
-                tickingState = holder.getEntityTickingChunkFuture();
-                break;
-            }
-            default: {
-                throw new IllegalStateException("Cannot reach here");
-            }
-        }
-
-        if (tickingState.isDone()) {
-            loadCallback.accept(tickingState.join().left().orElse(null));
-            return;
-        }
-
-        tickingState.whenCompleteAsync((final Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either, final Throwable thr) -> {
-            if (thr != null) {
-                loadCallback.accept(null);
-                return;
-            }
-            loadCallback.accept(either.left().orElse(null));
-        }, (final Runnable r) -> {
-            scheduleChunkTask(level, chunkX, chunkZ, r, PrioritisedExecutor.Priority.HIGHEST);
-        });
+        level.chunkTaskScheduler.scheduleTickingState(chunkX, chunkZ, toStatus, addTicket, priority, onComplete); // Paper - rewrite chunk system
     }
 
     public static List<ChunkHolder> getVisibleChunkHolders(final ServerLevel level) {
-        if (Bukkit.isPrimaryThread()) {
-            return level.chunkSource.chunkMap.updatingChunks.getVisibleValuesCopy();
-        }
-        synchronized (level.chunkSource.chunkMap.updatingChunks) {
-            return level.chunkSource.chunkMap.updatingChunks.getVisibleValuesCopy();
-        }
+        return level.chunkTaskScheduler.chunkHolderManager.getOldChunkHolders(); // Paper - rewrite chunk system
     }
 
     public static List<ChunkHolder> getUpdatingChunkHolders(final ServerLevel level) {
-        return level.chunkSource.chunkMap.updatingChunks.getUpdatingValuesCopy();
+        return level.chunkTaskScheduler.chunkHolderManager.getOldChunkHolders(); // Paper - rewrite chunk system
     }
 
     public static int getVisibleChunkHolderCount(final ServerLevel level) {
-        return level.chunkSource.chunkMap.updatingChunks.getVisibleMap().size();
+        return level.chunkTaskScheduler.chunkHolderManager.size(); // Paper - rewrite chunk system
     }
 
     public static int getUpdatingChunkHolderCount(final ServerLevel level) {
-        return level.chunkSource.chunkMap.updatingChunks.getUpdatingMap().size();
+        return level.chunkTaskScheduler.chunkHolderManager.size(); // Paper - rewrite chunk system
     }
 
     public static boolean hasAnyChunkHolders(final ServerLevel level) {
@@ -270,7 +96,7 @@ public final class ChunkSystem {
         for (int index = 0, len = chunkMap.regionManagers.size(); index < len; ++index) {
             chunkMap.regionManagers.get(index).addChunk(holder.pos.x, holder.pos.z);
         }
-        chunkMap.getPoiManager().dequeueUnload(holder.pos.longKey); // Paper - unload POI data
+        // Paper - rewrite chunk system
     }
 
     public static void onChunkHolderDelete(final ServerLevel level, final ChunkHolder holder) {
@@ -278,7 +104,7 @@ public final class ChunkSystem {
         for (int index = 0, len = chunkMap.regionManagers.size(); index < len; ++index) {
             chunkMap.regionManagers.get(index).removeChunk(holder.pos.x, holder.pos.z);
         }
-        chunkMap.getPoiManager().queueUnload(holder.pos.longKey, MinecraftServer.currentTickLong + 1); // Paper - unload POI data
+        // Paper - rewrite chunk system
     }
 
     public static void onChunkBorder(LevelChunk chunk, ChunkHolder holder) {
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 6939ef9b1fe782980e77c351d8a385a573d6a8e6..99f56658c70f99592fb40c9df0ce3e47053d1bd5 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -10,6 +10,7 @@ import com.google.gson.stream.JsonWriter;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet;
 import java.lang.ref.Cleaner;
+import it.unimi.dsi.fastutil.objects.ReferenceArrayList;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.nbt.CompoundTag;
@@ -560,53 +561,47 @@ public final class MCUtil {
         return chunk.getChunkHolderStatus();
     }
 
-    public static void dumpChunks(File file) throws IOException {
+    public static void dumpChunks(File file, boolean watchdog) throws IOException {
         file.getParentFile().mkdirs();
         file.createNewFile();
-        /*
-         * Json format:
-         *
-         * Main data format:
-         *  -server-version:<string>
-         *  -data-version:<int>
-         *  -worlds:
-         *    -name:<world name>
-         *    -view-distance:<int>
-         *    -keep-spawn-loaded:<boolean>
-         *    -keep-spawn-loaded-range:<int>
-         *    -visible-chunk-count:<int>
-         *    -loaded-chunk-count:<int>
-         *    -verified-fully-loaded-chunks:<int>
-         *    -players:<array of player>
-         *    -chunk-data:<array of chunks>
-         *
-         * Player format:
-         *  -name:<string>
-         *  -x:<double>
-         *  -y:<double>
-         *  -z:<double>
-         *
-         * Chunk Format:
-         *  -x:<integer>
-         *  -z:<integer>
-         *  -ticket-level:<integer>
-         *  -state:<string>
-         *  -queued-for-unload:<boolean>
-         *  -status:<string>
-         *  -tickets:<array of tickets>
-         *
-         *
-         * Ticket format:
-         *  -ticket-type:<string>
-         *  -ticket-level:<int>
-         *  -add-tick:<long>
-         *  -object-reason:<string> // This depends on the type of ticket. ie POST_TELEPORT -> entity id
-         */
-        List<org.bukkit.World> worlds = org.bukkit.Bukkit.getWorlds();
+        ReferenceArrayList<org.bukkit.World> worlds = new ReferenceArrayList<>(org.bukkit.Bukkit.getWorlds());
+        ReferenceArrayList<org.bukkit.World> loadedWorlds = new ReferenceArrayList<>(worlds);
         JsonObject data = new JsonObject();
 
         data.addProperty("server-version", org.bukkit.Bukkit.getVersion());
-        data.addProperty("data-version", 0);
+        data.addProperty("data-version", 1);
+
+        {
+            JsonArray players = new JsonArray();
+            data.add("all-players", players);
+            List<ServerPlayer> playerList = MinecraftServer.getServer().getPlayerList().players;
+            for (ServerPlayer player : playerList) {
+                JsonObject playerData = new JsonObject();
+                players.add(playerData);
+
+                Level playerWorld = player.getLevel();
+                org.bukkit.World craftWorld = playerWorld.getWorld();
+                Entity.RemovalReason removalReason = player.getRemovalReason();
+
+                playerData.addProperty("name", player.getScoreboardName());
+                playerData.addProperty("x", player.getX());
+                playerData.addProperty("y", player.getY());
+                playerData.addProperty("z", player.getZ());
+                playerData.addProperty("world", playerWorld == null ? "null world" : craftWorld.getName());
+                playerData.addProperty("removalReason", removalReason == null ? "null" : removalReason.name());
+
+                if (!worlds.contains(craftWorld)) {
+                    worlds.add(craftWorld);
+                }
+            }
+        }
+
+        JsonArray chunkWaitInformation = new JsonArray();
+        data.add("chunk-wait-infos", chunkWaitInformation);
+
+        for (io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.ChunkInfo chunkInfo : io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.getChunkInfos()) {
+            chunkWaitInformation.add(chunkInfo.toString());
+        }
 
         JsonArray worldsData = new JsonArray();
 
@@ -614,35 +609,14 @@ public final class MCUtil {
             JsonObject worldData = new JsonObject();
 
             ServerLevel world = ((org.bukkit.craftbukkit.CraftWorld)bukkitWorld).getHandle();
-            ChunkMap chunkMap = world.getChunkSource().chunkMap;
-            DistanceManager chunkMapDistance = chunkMap.distanceManager;
-            List<ChunkHolder> allChunks = net.minecraft.server.ChunkSystem.getVisibleChunkHolders(world);
             List<ServerPlayer> players = world.players;
 
-            int fullLoadedChunks = 0;
-
-            for (ChunkHolder chunk : allChunks) {
-                if (chunk.getFullChunkNowUnchecked() != null) {
-                    ++fullLoadedChunks;
-                }
-            }
-
-            // sorting by coordinate makes the log easier to read
-            allChunks.sort((ChunkHolder v1, ChunkHolder v2) -> {
-                if (v1.pos.x != v2.pos.x) {
-                    return Integer.compare(v1.pos.x, v2.pos.x);
-                }
-                return Integer.compare(v1.pos.z, v2.pos.z);
-            });
-
+            worldData.addProperty("is-loaded", loadedWorlds.contains(bukkitWorld));
             worldData.addProperty("name", world.getWorld().getName());
             worldData.addProperty("view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()); // Paper - replace chunk loader system
             worldData.addProperty("tick-view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()); // Paper - replace chunk loader system
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig().spawn.keepSpawnLoadedRange * 16);
-            worldData.addProperty("visible-chunk-count", allChunks.size());
-            worldData.addProperty("loaded-chunk-count", chunkMap.entitiesInLevel.size());
-            worldData.addProperty("verified-fully-loaded-chunks", fullLoadedChunks);
 
             JsonArray playersData = new JsonArray();
 
@@ -655,48 +629,10 @@ public final class MCUtil {
                 playerData.addProperty("z", player.getZ());
 
                 playersData.add(playerData);
-
             }
 
             worldData.add("players", playersData);
-
-            JsonArray chunksData = new JsonArray();
-
-            for (ChunkHolder playerChunk : allChunks) {
-                JsonObject chunkData = new JsonObject();
-
-                Set<Ticket<?>> tickets = chunkMapDistance.tickets.get(playerChunk.pos.longKey);
-                ChunkStatus status = getChunkStatus(playerChunk);
-
-                chunkData.addProperty("x", playerChunk.pos.x);
-                chunkData.addProperty("z", playerChunk.pos.z);
-                chunkData.addProperty("ticket-level", playerChunk.getTicketLevel());
-                chunkData.addProperty("priority", playerChunk.queueLevel); // Paper - priority
-                chunkData.addProperty("state", ChunkHolder.getFullChunkStatus(playerChunk.getTicketLevel()).toString());
-                chunkData.addProperty("queued-for-unload", chunkMap.toDrop.contains(playerChunk.pos.longKey));
-                chunkData.addProperty("status", status == null ? "unloaded" : status.toString());
-
-                JsonArray ticketsData = new JsonArray();
-
-                if (tickets != null) {
-                    for (Ticket<?> ticket : tickets) {
-                        JsonObject ticketData = new JsonObject();
-
-                        ticketData.addProperty("ticket-type", ticket.getType().toString());
-                        ticketData.addProperty("ticket-level", ticket.getTicketLevel());
-                        ticketData.addProperty("object-reason", String.valueOf(ticket.key));
-                        ticketData.addProperty("add-tick", ticket.createdTick);
-
-                        ticketsData.add(ticketData);
-                    }
-                }
-
-                chunkData.add("tickets", ticketsData);
-                chunksData.add(chunkData);
-            }
-
-
-            worldData.add("chunk-data", chunksData);
+            worldData.add("chunk-data", watchdog ? world.chunkTaskScheduler.chunkHolderManager.getDebugJsonForWatchdog() : world.chunkTaskScheduler.chunkHolderManager.getDebugJson());
             worldsData.add(worldData);
         }
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 183ed9fda2b41b9ec091ead8774be46e12d9b056..63653c0325b7e1f86aa40590a4cf0e4fd6361ca5 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -303,7 +303,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
         AtomicReference<S> atomicreference = new AtomicReference();
-        Thread thread = new Thread(() -> {
+        Thread thread = new io.papermc.paper.util.TickThread(() -> { // Paper - rewrite chunk system
             ((MinecraftServer) atomicreference.get()).runServer();
         }, "Server thread");
 
@@ -617,7 +617,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.forceDifficulty();
         for (ServerLevel worldserver : this.getAllLevels()) {
             this.prepareLevels(worldserver.getChunkSource().chunkMap.progressListener, worldserver);
-            worldserver.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API
+            //worldserver.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API // Paper - rewrite chunk system, not required to "tick" anything
             this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(worldserver.getWorld()));
         }
 
@@ -834,6 +834,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public abstract boolean shouldRconBroadcast();
 
     public boolean saveAllChunks(boolean suppressLogs, boolean flush, boolean force) {
+        // Paper start - rewrite chunk system - add close param
+        // This allows us to avoid double saving chunks by closing instead of saving then closing
+        return this.saveAllChunks(suppressLogs, flush, force, false);
+    }
+    public boolean saveAllChunks(boolean suppressLogs, boolean flush, boolean force, boolean close) {
+        // Paper end - rewrite chunk system - add close param
         boolean flag3 = false;
 
         for (Iterator iterator = this.getAllLevels().iterator(); iterator.hasNext(); flag3 = true) {
@@ -842,8 +848,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             if (!suppressLogs) {
                 MinecraftServer.LOGGER.info("Saving chunks for level '{}'/{}", worldserver, worldserver.dimension().location());
             }
-
-            worldserver.save((ProgressListener) null, flush, worldserver.noSave && !force);
+            // Paper start - rewrite chunk system
+            worldserver.save((ProgressListener) null, flush, worldserver.noSave && !force, close);
+            if (flush) {
+                MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", worldserver.getChunkSource().chunkMap.getStorageName());
+            }
+            // Paper end - rewrite chunk system
         }
 
         // CraftBukkit start - moved to WorldServer.save
@@ -862,7 +872,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             while (iterator1.hasNext()) {
                 ServerLevel worldserver2 = (ServerLevel) iterator1.next();
 
-                MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", worldserver2.getChunkSource().chunkMap.getStorageName());
+                //MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", worldserver2.getChunkSource().chunkMap.getStorageName()); // Paper - move up
             }
 
             MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage: All dimensions are saved");
@@ -967,38 +977,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         // Paper end - let's be a little more intelligent around crashes
 
-        while (this.levels.values().stream().anyMatch((worldserver1) -> {
-            return worldserver1.getChunkSource().chunkMap.hasWork();
-        })) {
-            this.nextTickTime = Util.getMillis() + 1L;
-            iterator = this.getAllLevels().iterator();
-
-            while (iterator.hasNext()) {
-                worldserver = (ServerLevel) iterator.next();
-                worldserver.getChunkSource().removeTicketsOnClosing();
-                worldserver.getChunkSource().tick(() -> {
-                    return true;
-                }, false);
-                while (worldserver.getChunkSource().pollTask()); // Paper - drain tasks
-            }
-
-            this.forceTicks = true; // Paper
-            while (this.pollTask()); // Paper - drain tasks
-        }
-
-        this.saveAllChunks(false, true, false);
-        iterator = this.getAllLevels().iterator();
+        // Paper - rewrite chunk system
 
-        while (iterator.hasNext()) {
-            worldserver = (ServerLevel) iterator.next();
-            if (worldserver != null) {
-                try {
-                    worldserver.close();
-                } catch (IOException ioexception) {
-                    MinecraftServer.LOGGER.error("Exception closing the level", ioexception);
-                }
-            }
-        }
+        this.saveAllChunks(false, true, false, true); // Paper - rewrite chunk system - move closing into here
+        // Paper - rewrite chunk system
 
         this.isSaving = false;
         this.resources.close();
@@ -1019,7 +1001,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Spigot end
         // Paper start - move final shutdown items here
         LOGGER.info("Flushing Chunk IO");
-        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.close(true, true); // Paper
+        io.papermc.paper.chunk.system.io.RegionFileIOThread.close(true); // Paper // Paper - rewrite chunk system
         LOGGER.info("Closing Thread Pool");
         Util.shutdownExecutors(); // Paper
         LOGGER.info("Closing Server");
@@ -1123,6 +1105,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Paper End
     // Spigot End
 
+    public static volatile RuntimeException chunkSystemCrash; // Paper - rewrite chunk system
+
     protected void runServer() {
         try {
             long serverStartTime = Util.getNanos(); // Paper
@@ -1155,6 +1139,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             long start = System.nanoTime(), curTime, tickSection = start; // Paper - Further improve server tick loop
             lastTick = start - TICK_TIME; // Paper
             while (this.running) {
+                // Paper start - rewrite chunk system
+                // guarantee that nothing can stop the server from halting if it can at least still tick
+                if (this.chunkSystemCrash != null) {
+                    throw this.chunkSystemCrash;
+                }
+                // Paper end - rewrite chunk system
                 long i = ((curTime = System.nanoTime()) / (1000L * 1000L)) - this.nextTickTime; // Paper
 
                 if (i > 5000L && this.nextTickTime - this.lastOverloadWarning >= 30000L) { // CraftBukkit
@@ -2074,7 +2064,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             net.minecraft.world.item.alchemy.PotionBrewing.reload(); // Paper
             new io.papermc.paper.event.server.ServerResourcesReloadedEvent(cause).callEvent(); // Paper
             // Paper start
-            if (Thread.currentThread() != this.serverThread) {
+            if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
                 return;
             }
             // this.getPlayerList().saveAll(); // Paper - we don't need to save everything, just advancements
@@ -2482,7 +2472,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // CraftBukkit start
     @Override
     public boolean isSameThread() {
-        return super.isSameThread() /*|| this.isStopped()*/; // CraftBukkit - MC-142590 // Paper - causes issues elsewhere
+        return io.papermc.paper.util.TickThread.isTickThread(); // Paper - rewrite chunk system
     }
 
     public boolean isDebugging() {
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index b22c3631f30f634bff38ae07dc8096ad6611029f..dbc05d0ecee21d2d83aa6b2337792b588308b812 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -455,7 +455,34 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         return this.getProperties().allowNether;
     }
 
+    static final java.util.concurrent.atomic.AtomicInteger ASYNC_DEBUG_CHUNKS_COUNT = new java.util.concurrent.atomic.AtomicInteger(); // Paper - rewrite chunk system
+
     public void handleConsoleInput(String command, CommandSourceStack commandSource) {
+        // Paper start - rewrite chunk system
+        if (command.equalsIgnoreCase("paper debug chunks --async")) {
+            LOGGER.info("Scheduling async debug chunks");
+            Runnable run = () -> {
+                LOGGER.info("Async debug chunks executing");
+                io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(false);
+                CommandSender sender = MinecraftServer.getServer().console;
+                java.io.File file = new java.io.File(new java.io.File(new java.io.File("."), "debug"),
+                    "chunks-" + java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss").format(java.time.LocalDateTime.now()) + ".txt");
+                sender.sendMessage(net.kyori.adventure.text.Component.text("Writing chunk information dump to " + file, net.kyori.adventure.text.format.NamedTextColor.GREEN));
+                try {
+                    net.minecraft.server.MCUtil.dumpChunks(file, true);
+                    sender.sendMessage(net.kyori.adventure.text.Component.text("Successfully written chunk information!", net.kyori.adventure.text.format.NamedTextColor.GREEN));
+                } catch (Throwable thr) {
+                    MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file.toString(), thr);
+                    sender.sendMessage(net.kyori.adventure.text.Component.text("Failed to dump chunk information, see console", net.kyori.adventure.text.format.NamedTextColor.RED));
+                }
+            };
+            Thread t = new Thread(run);
+            t.setName("Async debug thread #" + ASYNC_DEBUG_CHUNKS_COUNT.getAndIncrement());
+            t.setDaemon(true);
+            t.start();
+            return;
+        }
+        // Paper end - rewrite chunk system
         this.serverCommandQueue.add(new ConsoleInput(command, commandSource));
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index a041161dee9a857d43c83fb677dba7e90a6a5d24..5fd6f89737937f12e526765b466f6fc08863189d 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -50,17 +50,12 @@ public class ChunkHolder {
     private static final List<ChunkStatus> CHUNK_STATUSES = ChunkStatus.getStatusList();
     private static final ChunkHolder.FullChunkStatus[] FULL_CHUNK_STATUSES = ChunkHolder.FullChunkStatus.values();
     private static final int BLOCKS_BEFORE_RESEND_FUDGE = 64;
-    private final AtomicReferenceArray<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> futures;
+    // Paper - rewrite chunk system
     private final LevelHeightAccessor levelHeightAccessor;
-    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> fullChunkFuture; private int fullChunkCreateCount; private volatile boolean isFullChunkReady; // Paper - cache chunk ticking stage
-    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> tickingChunkFuture; private volatile boolean isTickingReady; // Paper - cache chunk ticking stage
-    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> entityTickingChunkFuture; private volatile boolean isEntityTickingReady; // Paper - cache chunk ticking stage
-    public CompletableFuture<ChunkAccess> chunkToSave;  // Paper - public
+    // Paper - rewrite chunk system
     @Nullable
     private final DebugBuffer<ChunkHolder.ChunkSaveDebug> chunkToSaveHistory;
-    public int oldTicketLevel;
-    private int ticketLevel;
-    public volatile int queueLevel; // Paper - private->public, make volatile since this is concurrently accessed
+    // Paper - rewrite chunk system
     public final ChunkPos pos;
     private boolean hasChangedSections;
     private final ShortSet[] changedBlocksPerSection;
@@ -69,12 +64,12 @@ public class ChunkHolder {
     private final LevelLightEngine lightEngine;
     private final ChunkHolder.LevelChangeListener onLevelChange;
     public final ChunkHolder.PlayerProvider playerProvider;
-    private boolean wasAccessibleSinceLastSave;
+    // Paper - rewrite chunk system
     private boolean resendLight;
-    private CompletableFuture<Void> pendingFullStateConfirmation;
+    // Paper - rewrite chunk system
 
     public ServerLevel getWorld() { return chunkMap.level; } // Paper
-    boolean isUpdateQueued = false; // Paper
+    // Paper - rewrite chunk system
     private final ChunkMap chunkMap; // Paper
     // Paper start - no-tick view distance
     public final LevelChunk getSendingChunk() {
@@ -134,153 +129,105 @@ public class ChunkHolder {
     // Paper end - optimise anyPlayerCloseEnoughForSpawning
     long lastAutoSaveTime; // Paper - incremental autosave
     long inactiveTimeStart; // Paper - incremental autosave
-    // Paper start - optimize chunk status progression without jumping through thread pool
-    public boolean canAdvanceStatus() {
-        ChunkStatus status = getChunkHolderStatus();
-        ChunkAccess chunk = getAvailableChunkNow();
-        return chunk != null && (status == null || chunk.getStatus().isOrAfter(getNextStatus(status)));
-    }
-    // Paper end
+    // Paper - rewrite chunk system
+
+    public final io.papermc.paper.chunk.system.scheduling.NewChunkHolder newChunkHolder; // Paper - rewrite chunk system
 
-    public ChunkHolder(ChunkPos pos, int level, LevelHeightAccessor world, LevelLightEngine lightingProvider, ChunkHolder.LevelChangeListener levelUpdateListener, ChunkHolder.PlayerProvider playersWatchingChunkProvider) {
-        this.futures = new AtomicReferenceArray(ChunkHolder.CHUNK_STATUSES.size());
-        this.fullChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-        this.tickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-        this.entityTickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-        this.chunkToSave = CompletableFuture.completedFuture(null); // CraftBukkit - decompile error
+    public ChunkHolder(ChunkPos pos, LevelHeightAccessor world, LevelLightEngine lightingProvider, ChunkHolder.PlayerProvider playersWatchingChunkProvider, io.papermc.paper.chunk.system.scheduling.NewChunkHolder newChunkHolder) { // Paper - rewrite chunk system
+        this.newChunkHolder = newChunkHolder; // Paper - rewrite chunk system
         this.chunkToSaveHistory = null;
         this.blockChangedLightSectionFilter = new BitSet();
         this.skyChangedLightSectionFilter = new BitSet();
-        this.pendingFullStateConfirmation = CompletableFuture.completedFuture(null); // CraftBukkit - decompile error
+        // Paper - rewrite chunk system
         this.pos = pos;
         this.levelHeightAccessor = world;
         this.lightEngine = lightingProvider;
-        this.onLevelChange = levelUpdateListener;
+        this.onLevelChange = null; // Paper - rewrite chunk system
         this.playerProvider = playersWatchingChunkProvider;
-        this.oldTicketLevel = ChunkMap.MAX_CHUNK_DISTANCE + 1;
-        this.ticketLevel = this.oldTicketLevel;
-        this.queueLevel = this.oldTicketLevel;
-        this.setTicketLevel(level);
+        // Paper - rewrite chunk system
         this.changedBlocksPerSection = new ShortSet[world.getSectionsCount()];
         this.chunkMap = (ChunkMap)playersWatchingChunkProvider; // Paper
     }
 
     // Paper start
     public @Nullable ChunkAccess getAvailableChunkNow() {
-        // TODO can we just getStatusFuture(EMPTY)?
-        for (ChunkStatus curr = ChunkStatus.FULL, next = curr.getParent(); curr != next; curr = next, next = next.getParent()) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.getFutureIfPresentUnchecked(curr);
-            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = future.getNow(null);
-            if (either == null || either.left().isEmpty()) {
-                continue;
-            }
-            return either.left().get();
-        }
-        return null;
+        return this.newChunkHolder.getCurrentChunk(); // Paper - rewrite chunk system
     }
     // Paper end
     // CraftBukkit start
     public LevelChunk getFullChunkNow() {
-        // Note: We use the oldTicketLevel for isLoaded checks.
-        if (!ChunkHolder.getFullChunkStatus(this.oldTicketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) return null;
-        return this.getFullChunkNowUnchecked();
+        // Paper start - rewrite chunk system
+        ChunkAccess chunk = this.getAvailableChunkNow();
+        if (!this.isFullChunkReady() || !(chunk instanceof LevelChunk)) return null; // instanceof to avoid a race condition on off-main threads
+        return (LevelChunk)chunk;
+        // Paper end - rewrite chunk system
     }
 
     public LevelChunk getFullChunkNowUnchecked() {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> statusFuture = this.getFutureIfPresentUnchecked(ChunkStatus.FULL);
-        Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = (Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>) statusFuture.getNow(null);
-        return (either == null) ? null : (LevelChunk) either.left().orElse(null);
+        // Paper start - rewrite chunk system
+        ChunkAccess chunk = this.getAvailableChunkNow();
+        return chunk instanceof LevelChunk ? (LevelChunk)chunk : null;
+        // Paper end - rewrite chunk system
     }
     // CraftBukkit end
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getFutureIfPresentUnchecked(ChunkStatus leastStatus) {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(leastStatus.getIndex());
-
-        return completablefuture == null ? ChunkHolder.UNLOADED_CHUNK_FUTURE : completablefuture;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getFutureIfPresent(ChunkStatus leastStatus) {
-        return ChunkHolder.getStatus(this.ticketLevel).isOrAfter(leastStatus) ? this.getFutureIfPresentUnchecked(leastStatus) : ChunkHolder.UNLOADED_CHUNK_FUTURE;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getTickingChunkFuture() { // Paper - final for inline
-        return this.tickingChunkFuture;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getEntityTickingChunkFuture() { // Paper - final for inline
-        return this.entityTickingChunkFuture;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getFullChunkFuture() { // Paper - final for inline
-        return this.fullChunkFuture;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     @Nullable
     public final LevelChunk getTickingChunk() { // Paper - final for inline
-        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getTickingChunkFuture();
-        Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = (Either) completablefuture.getNow(null); // CraftBukkit - decompile error
-
-        return either == null ? null : (LevelChunk) either.left().orElse(null); // CraftBukkit - decompile error
+        // Paper start - rewrite chunk system
+        if (!this.isTickingReady()) {
+            return null;
+        }
+        return (LevelChunk)this.getAvailableChunkNow();
+        // Paper end - rewrite chunk system
     }
 
     @Nullable
     public final LevelChunk getFullChunk() { // Paper - final for inline
-        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFullChunkFuture();
-        Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = (Either) completablefuture.getNow(null); // CraftBukkit - decompile error
-
-        return either == null ? null : (LevelChunk) either.left().orElse(null); // CraftBukkit - decompile error
+        // Paper start - rewrite chunk system
+        if (!this.isFullChunkReady()) {
+            return null;
+        }
+        return (LevelChunk)this.getAvailableChunkNow();
+        // Paper end - rewrite chunk system
     }
 
     @Nullable
     public ChunkStatus getLastAvailableStatus() {
-        for (int i = ChunkHolder.CHUNK_STATUSES.size() - 1; i >= 0; --i) {
-            ChunkStatus chunkstatus = (ChunkStatus) ChunkHolder.CHUNK_STATUSES.get(i);
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFutureIfPresentUnchecked(chunkstatus);
-
-            if (((Either) completablefuture.getNow(ChunkHolder.UNLOADED_CHUNK)).left().isPresent()) {
-                return chunkstatus;
-            }
-        }
-
-        return null;
+        return this.newChunkHolder.getCurrentGenStatus(); // Paper - rewrite chunk system
     }
 
     // Paper start
     public ChunkStatus getChunkHolderStatus() {
-        for (ChunkStatus curr = ChunkStatus.FULL, next = curr.getParent(); curr != next; curr = next, next = next.getParent()) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.getFutureIfPresentUnchecked(curr);
-            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = future.getNow(null);
-            if (either == null || !either.left().isPresent()) {
-                continue;
-            }
-            return curr;
-        }
-
-        return null;
+        return this.newChunkHolder.getCurrentGenStatus(); // Paper - rewrite chunk system
     }
     // Paper end
 
     @Nullable
     public ChunkAccess getLastAvailable() {
-        for (int i = ChunkHolder.CHUNK_STATUSES.size() - 1; i >= 0; --i) {
-            ChunkStatus chunkstatus = (ChunkStatus) ChunkHolder.CHUNK_STATUSES.get(i);
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFutureIfPresentUnchecked(chunkstatus);
-
-            if (!completablefuture.isCompletedExceptionally()) {
-                Optional<ChunkAccess> optional = ((Either) completablefuture.getNow(ChunkHolder.UNLOADED_CHUNK)).left();
-
-                if (optional.isPresent()) {
-                    return (ChunkAccess) optional.get();
-                }
-            }
-        }
-
-        return null;
+        return this.newChunkHolder.getCurrentChunk(); // Paper - rewrite chunk system
     }
 
-    public final CompletableFuture<ChunkAccess> getChunkToSave() { // Paper - final for inline
-        return this.chunkToSave;
-    }
+    // Paper - rewrite chunk system
 
     public void blockChanged(BlockPos pos) {
         if (!pos.isInsideBuildHeightAndWorldBoundsHorizontal(levelHeightAccessor)) return; // Paper - SPIGOT-6086 for all invalid locations; avoid acquiring locks
@@ -435,61 +382,10 @@ public class ChunkHolder {
         // Paper end - per player view distance
     }
 
-    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getOrScheduleFuture(ChunkStatus targetStatus, ChunkMap chunkStorage) {
-        int i = targetStatus.getIndex();
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(i);
-
-        if (completablefuture != null) {
-            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = (Either) completablefuture.getNow(ChunkHolder.NOT_DONE_YET);
-
-            if (either == null) {
-                String s = "value in future for status: " + targetStatus + " was incorrectly set to null at chunk: " + this.pos;
-
-                throw chunkStorage.debugFuturesAndCreateReportedException(new IllegalStateException("null value previously set for chunk status"), s);
-            }
-
-            if (either == ChunkHolder.NOT_DONE_YET || either.right().isEmpty()) {
-                return completablefuture;
-            }
-        }
-
-        if (ChunkHolder.getStatus(this.ticketLevel).isOrAfter(targetStatus)) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = chunkStorage.schedule(this, targetStatus);
-
-            this.updateChunkToSave(completablefuture1, "schedule " + targetStatus);
-            this.futures.set(i, completablefuture1);
-            return completablefuture1;
-        } else {
-            return completablefuture == null ? ChunkHolder.UNLOADED_CHUNK_FUTURE : completablefuture;
-        }
-    }
-
-    protected void addSaveDependency(String thenDesc, CompletableFuture<?> then) {
-        if (this.chunkToSaveHistory != null) {
-            this.chunkToSaveHistory.push(new ChunkHolder.ChunkSaveDebug(Thread.currentThread(), then, thenDesc));
-        }
-
-        this.chunkToSave = this.chunkToSave.thenCombine(then, (ichunkaccess, object) -> {
-            return ichunkaccess;
-        });
-    }
-
-    private void updateChunkToSave(CompletableFuture<? extends Either<? extends ChunkAccess, ChunkHolder.ChunkLoadingFailure>> then, String thenDesc) {
-        if (this.chunkToSaveHistory != null) {
-            this.chunkToSaveHistory.push(new ChunkHolder.ChunkSaveDebug(Thread.currentThread(), then, thenDesc));
-        }
-
-        this.chunkToSave = this.chunkToSave.thenCombine(then, (ichunkaccess, either) -> {
-            return (ChunkAccess) either.map((ichunkaccess1) -> {
-                return ichunkaccess1;
-            }, (playerchunk_failure) -> {
-                return ichunkaccess;
-            });
-        });
-    }
+    // Paper - rewrite chunk system
 
     public ChunkHolder.FullChunkStatus getFullStatus() {
-        return ChunkHolder.getFullChunkStatus(this.ticketLevel);
+        return this.newChunkHolder.getChunkStatus(); // Paper - rewrite chunk system
     }
 
     public final ChunkPos getPos() { // Paper - final for inline
@@ -497,290 +393,10 @@ public class ChunkHolder {
     }
 
     public final int getTicketLevel() { // Paper - final for inline
-        return this.ticketLevel;
-    }
-
-    public int getQueueLevel() {
-        return this.queueLevel;
-    }
-
-    private void setQueueLevel(int level) {
-        this.queueLevel = level;
-    }
-
-    public void setTicketLevel(int level) {
-        this.ticketLevel = level;
+        return this.newChunkHolder.getTicketLevel(); // Paper - rewrite chunk system
     }
 
-    private void scheduleFullChunkPromotion(ChunkMap playerchunkmap, CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture, Executor executor, ChunkHolder.FullChunkStatus playerchunk_state) {
-        this.pendingFullStateConfirmation.cancel(false);
-        CompletableFuture<Void> completablefuture1 = new CompletableFuture();
-
-        completablefuture1.thenRunAsync(() -> {
-            // Paper start - do not allow ticket level changes
-            boolean unloadingBefore = this.chunkMap.unloadingPlayerChunk;
-            this.chunkMap.unloadingPlayerChunk = true;
-            try {
-            // Paper end  - do not allow ticket level changes
-            playerchunkmap.onFullChunkStatusChange(this.pos, playerchunk_state);
-            } finally { this.chunkMap.unloadingPlayerChunk = unloadingBefore; } // Paper - do not allow ticket level changes
-        }, executor);
-        this.pendingFullStateConfirmation = completablefuture1;
-        completablefuture.thenAccept((either) -> {
-            either.ifLeft((chunk) -> {
-                completablefuture1.complete(null); // CraftBukkit - decompile error
-            });
-        });
-    }
-
-    // Paper start
-    private boolean loadCallbackScheduled = false;
-    private boolean unloadCallbackScheduled = false;
-    // Paper end
-
-    private void demoteFullChunk(ChunkMap playerchunkmap, ChunkHolder.FullChunkStatus playerchunk_state) {
-        this.pendingFullStateConfirmation.cancel(false);
-        // Paper start - do not allow ticket level changes
-        boolean unloadingBefore = this.chunkMap.unloadingPlayerChunk;
-        this.chunkMap.unloadingPlayerChunk = true;
-        try { // Paper end  - do not allow ticket level changes
-        playerchunkmap.onFullChunkStatusChange(this.pos, playerchunk_state);
-        } finally { this.chunkMap.unloadingPlayerChunk = unloadingBefore; } // Paper - do not allow ticket level changes
-    }
-
-    protected long updateCount; // Paper - correctly handle recursion
-    protected void updateFutures(ChunkMap chunkStorage, Executor executor) {
-        io.papermc.paper.util.TickThread.ensureTickThread("Async ticket level update"); // Paper
-        long updateCount = ++this.updateCount; // Paper - correctly handle recursion
-        ChunkStatus chunkstatus = ChunkHolder.getStatus(this.oldTicketLevel);
-        ChunkStatus chunkstatus1 = ChunkHolder.getStatus(this.ticketLevel);
-        boolean flag = this.oldTicketLevel <= ChunkMap.MAX_CHUNK_DISTANCE;
-        boolean flag1 = this.ticketLevel <= ChunkMap.MAX_CHUNK_DISTANCE;
-        ChunkHolder.FullChunkStatus playerchunk_state = ChunkHolder.getFullChunkStatus(this.oldTicketLevel);
-        ChunkHolder.FullChunkStatus playerchunk_state1 = ChunkHolder.getFullChunkStatus(this.ticketLevel);
-        // CraftBukkit start
-        // ChunkUnloadEvent: Called before the chunk is unloaded: isChunkLoaded is still true and chunk can still be modified by plugins.
-        if (playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && !playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
-            this.getFutureIfPresentUnchecked(ChunkStatus.FULL).thenAccept((either) -> {
-                io.papermc.paper.util.TickThread.ensureTickThread("Async full status chunk future completion"); // Paper
-                LevelChunk chunk = (LevelChunk)either.left().orElse(null);
-                if (chunk != null && chunk.wasLoadCallbackInvoked() && ChunkHolder.this.ticketLevel > 33) { // Paper - only invoke unload if load was called
-                    // Paper  start - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                    if (ChunkHolder.this.unloadCallbackScheduled) {
-                        return;
-                    }
-                    ChunkHolder.this.unloadCallbackScheduled = true;
-                    // Paper  end - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                    chunkStorage.callbackExecutor.execute(() -> {
-                        // Paper  start - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                        ChunkHolder.this.unloadCallbackScheduled = false;
-                        if (ChunkHolder.this.ticketLevel <= 33) {
-                            return;
-                        }
-                        // Paper  end - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                        // Minecraft will apply the chunks tick lists to the world once the chunk got loaded, and then store the tick
-                        // lists again inside the chunk once the chunk becomes inaccessible and set the chunk's needsSaving flag.
-                        // These actions may however happen deferred, so we manually set the needsSaving flag already here.
-                        chunk.setUnsaved(true);
-                        chunk.unloadCallback();
-                    });
-                }
-            }).exceptionally((throwable) -> {
-                // ensure exceptions are printed, by default this is not the case
-                MinecraftServer.LOGGER.error("Failed to schedule unload callback for chunk " + ChunkHolder.this.pos, throwable);
-                return null;
-            });
-
-            // Run callback right away if the future was already done
-            chunkStorage.callbackExecutor.run();
-            // Paper start - correctly handle recursion
-            if (this.updateCount != updateCount) {
-                // something else updated ticket level for us.
-                return;
-            }
-            // Paper end - correctly handle recursion
-        }
-        // CraftBukkit end
-
-        if (flag) {
-            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = Either.right(new ChunkHolder.ChunkLoadingFailure() {
-                public String toString() {
-                    return "Unloaded ticket level " + ChunkHolder.this.pos;
-                }
-            });
-
-            for (int i = flag1 ? chunkstatus1.getIndex() + 1 : 0; i <= chunkstatus.getIndex(); ++i) {
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(i);
-
-                if (completablefuture == null) {
-                    this.futures.set(i, CompletableFuture.completedFuture(either));
-                }
-            }
-        }
-
-        boolean flag2 = playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
-        boolean flag3 = playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
-
-        boolean prevHasBeenLoaded = this.wasAccessibleSinceLastSave; // Paper
-        this.wasAccessibleSinceLastSave |= flag3;
-        // Paper start - incremental autosave
-        if (this.wasAccessibleSinceLastSave & !prevHasBeenLoaded) {
-            long timeSinceAutoSave = this.inactiveTimeStart - this.lastAutoSaveTime;
-            if (timeSinceAutoSave < 0) {
-                // safest bet is to assume autosave is needed here
-                timeSinceAutoSave = this.chunkMap.level.paperConfig().chunks.autoSaveInterval.value();
-            }
-            this.lastAutoSaveTime = this.chunkMap.level.getGameTime() - timeSinceAutoSave;
-            this.chunkMap.autoSaveQueue.add(this);
-        }
-        // Paper end
-        if (!flag2 && flag3) {
-            int expectCreateCount = ++this.fullChunkCreateCount; // Paper
-            this.fullChunkFuture = chunkStorage.prepareAccessibleChunk(this);
-            this.scheduleFullChunkPromotion(chunkStorage, this.fullChunkFuture, executor, ChunkHolder.FullChunkStatus.BORDER);
-            // Paper start - cache ticking ready status
-            this.fullChunkFuture.thenAccept(either -> {
-                io.papermc.paper.util.TickThread.ensureTickThread("Async full chunk future completion"); // Paper
-                final Optional<LevelChunk> left = either.left();
-                if (left.isPresent() && ChunkHolder.this.fullChunkCreateCount == expectCreateCount) {
-                    LevelChunk fullChunk = either.left().get();
-                    ChunkHolder.this.isFullChunkReady = true;
-                    net.minecraft.server.ChunkSystem.onChunkBorder(fullChunk, this);
-                    this.chunkMap.distanceManager.clearPriorityTickets(pos); // Paper - chunk priority
-                }
-            });
-            this.updateChunkToSave(this.fullChunkFuture, "full");
-        }
-
-        if (flag2 && !flag3) {
-            // Paper start
-            if (this.isFullChunkReady) {
-                net.minecraft.server.ChunkSystem.onChunkNotBorder(this.fullChunkFuture.join().left().get(), this); // Paper
-            }
-            // Paper end
-            this.fullChunkFuture.complete(ChunkHolder.UNLOADED_LEVEL_CHUNK);
-            this.fullChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-            ++this.fullChunkCreateCount; // Paper - cache ticking ready status
-            this.isFullChunkReady = false; // Paper - cache ticking ready status
-        }
-
-        boolean flag4 = playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.TICKING);
-        boolean flag5 = playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.TICKING);
-
-        if (!flag4 && flag5) {
-            this.tickingChunkFuture = chunkStorage.prepareTickingChunk(this);
-            this.scheduleFullChunkPromotion(chunkStorage, this.tickingChunkFuture, executor, ChunkHolder.FullChunkStatus.TICKING);
-            // Paper start - cache ticking ready status
-            this.tickingChunkFuture.thenAccept(either -> {
-                io.papermc.paper.util.TickThread.ensureTickThread("Async full chunk future completion"); // Paper
-                either.ifLeft(chunk -> {
-                    // note: Here is a very good place to add callbacks to logic waiting on this.
-                    ChunkHolder.this.isTickingReady = true;
-                    net.minecraft.server.ChunkSystem.onChunkTicking(chunk, this);
-                });
-            });
-            // Paper end
-            this.updateChunkToSave(this.tickingChunkFuture, "ticking");
-        }
-
-        if (flag4 && !flag5) {
-            // Paper start
-            if (this.isTickingReady) {
-                net.minecraft.server.ChunkSystem.onChunkNotTicking(this.tickingChunkFuture.join().left().get(), this); // Paper
-            }
-            // Paper end
-            this.tickingChunkFuture.complete(ChunkHolder.UNLOADED_LEVEL_CHUNK); this.isTickingReady = false; // Paper - cache chunk ticking stage
-            this.tickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-        }
-
-        boolean flag6 = playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
-        boolean flag7 = playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
-
-        if (!flag6 && flag7) {
-            if (this.entityTickingChunkFuture != ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE) {
-                throw (IllegalStateException) Util.pauseInIde(new IllegalStateException());
-            }
-
-            this.entityTickingChunkFuture = chunkStorage.prepareEntityTickingChunk(this.pos);
-            this.scheduleFullChunkPromotion(chunkStorage, this.entityTickingChunkFuture, executor, ChunkHolder.FullChunkStatus.ENTITY_TICKING);
-            // Paper start - cache ticking ready status
-            this.entityTickingChunkFuture.thenAccept(either -> {
-                io.papermc.paper.util.TickThread.ensureTickThread("Async full chunk future completion"); // Paper
-                either.ifLeft(chunk -> {
-                    ChunkHolder.this.isEntityTickingReady = true;
-                    net.minecraft.server.ChunkSystem.onChunkEntityTicking(chunk, this);
-                });
-            });
-            // Paper end
-            this.updateChunkToSave(this.entityTickingChunkFuture, "entity ticking");
-        }
-
-        if (flag6 && !flag7) {
-            // Paper start
-            if (this.isEntityTickingReady) {
-                net.minecraft.server.ChunkSystem.onChunkNotEntityTicking(this.entityTickingChunkFuture.join().left().get(), this);
-            }
-            // Paper end
-            this.entityTickingChunkFuture.complete(ChunkHolder.UNLOADED_LEVEL_CHUNK); this.isEntityTickingReady = false; // Paper - cache chunk ticking stage
-            this.entityTickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-        }
-
-        if (!playerchunk_state1.isOrAfter(playerchunk_state)) {
-            this.demoteFullChunk(chunkStorage, playerchunk_state1);
-        }
-
-        //this.onLevelChange.onLevelChange(this.pos, this::getQueueLevel, this.ticketLevel, this::setQueueLevel);
-        // Paper start - raise IO/load priority if priority changes, use our preferred priority
-        priorityBoost = chunkMap.distanceManager.getChunkPriority(pos);
-        int currRequestedPriority = this.requestedPriority;
-        int priority = getDemandedPriority();
-        int newRequestedPriority = this.requestedPriority = priority;
-        if (this.queueLevel > priority) {
-            int ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
-            if (priority <= 10) {
-                ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
-            } else if (priority <= 20) {
-                ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
-            }
-            chunkMap.level.asyncChunkTaskManager.raisePriority(pos.x, pos.z, ioPriority);
-            chunkMap.level.getChunkSource().getLightEngine().queue.changePriority(pos.toLong(), this.queueLevel, priority); // Paper // Restore this in chunk priority later?
-        }
-        if (currRequestedPriority != newRequestedPriority) {
-            this.onLevelChange.onLevelChange(this.pos, () -> this.queueLevel, priority, p -> this.queueLevel = p); // use preferred priority
-            int neighborsPriority = getNeighborsPriority();
-            this.neighbors.forEach((neighbor, neighborDesired) -> neighbor.setNeighborPriority(this, neighborsPriority));
-        }
-        // Paper end
-        this.oldTicketLevel = this.ticketLevel;
-        // CraftBukkit start
-        // ChunkLoadEvent: Called after the chunk is loaded: isChunkLoaded returns true and chunk is ready to be modified by plugins.
-        if (!playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
-            this.getFutureIfPresentUnchecked(ChunkStatus.FULL).thenAccept((either) -> {
-                io.papermc.paper.util.TickThread.ensureTickThread("Async full status chunk future completion"); // Paper
-                LevelChunk chunk = (LevelChunk)either.left().orElse(null);
-                if (chunk != null && ChunkHolder.this.oldTicketLevel <= 33 && !chunk.wasLoadCallbackInvoked()) { // Paper - ensure ticket level is set to loaded before calling, as now this can complete with ticket level > 33
-                    // Paper  start - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                    if (ChunkHolder.this.loadCallbackScheduled) {
-                        return;
-                    }
-                    ChunkHolder.this.loadCallbackScheduled = true;
-                    // Paper  end - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                    chunkStorage.callbackExecutor.execute(() -> {
-                        ChunkHolder.this.loadCallbackScheduled = false; // Paper  - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                        if (ChunkHolder.this.oldTicketLevel <= 33) chunk.loadCallback(); // Paper "
-                    });
-                }
-            }).exceptionally((throwable) -> {
-                // ensure exceptions are printed, by default this is not the case
-                MinecraftServer.LOGGER.error("Failed to schedule load callback for chunk " + ChunkHolder.this.pos, throwable);
-                return null;
-            });
-
-            // Run callback right away if the future was already done
-            chunkStorage.callbackExecutor.run();
-        }
-        // CraftBukkit end
-    }
+    // Paper - rewrite chunk system
 
     public static ChunkStatus getStatus(int level) {
         return level < 33 ? ChunkStatus.FULL : ChunkStatus.getStatusAroundFullChunk(level - 33);
@@ -790,62 +406,14 @@ public class ChunkHolder {
         return ChunkHolder.FULL_CHUNK_STATUSES[Mth.clamp(33 - distance + 1, (int) 0, ChunkHolder.FULL_CHUNK_STATUSES.length - 1)];
     }
 
-    public boolean wasAccessibleSinceLastSave() {
-        return this.wasAccessibleSinceLastSave;
-    }
-
-    public void refreshAccessibility() {
-        boolean prev = this.wasAccessibleSinceLastSave; // Paper
-        this.wasAccessibleSinceLastSave = ChunkHolder.getFullChunkStatus(this.ticketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
-        // Paper start - incremental autosave
-        if (prev != this.wasAccessibleSinceLastSave) {
-            if (this.wasAccessibleSinceLastSave) {
-                long timeSinceAutoSave = this.inactiveTimeStart - this.lastAutoSaveTime;
-                if (timeSinceAutoSave < 0) {
-                    // safest bet is to assume autosave is needed here
-                    timeSinceAutoSave = this.chunkMap.level.paperConfig().chunks.autoSaveInterval.value();
-                }
-                this.lastAutoSaveTime = this.chunkMap.level.getGameTime() - timeSinceAutoSave;
-                this.chunkMap.autoSaveQueue.add(this);
-            } else {
-                this.inactiveTimeStart = this.chunkMap.level.getGameTime();
-                this.chunkMap.autoSaveQueue.remove(this);
-            }
-        }
-        // Paper end
-    }
-
-    // Paper start - incremental autosave
-    public boolean setHasBeenLoaded() {
-        this.wasAccessibleSinceLastSave = getFullChunkStatus(this.ticketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
-        return this.wasAccessibleSinceLastSave;
-    }
-    // Paper end
+    // Paper - rewrite chunk system
 
     public void replaceProtoChunk(ImposterProtoChunk chunk) {
-        for (int i = 0; i < this.futures.length(); ++i) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(i);
-
-            if (completablefuture != null) {
-                Optional<ChunkAccess> optional = ((Either) completablefuture.getNow(ChunkHolder.UNLOADED_CHUNK)).left();
-
-                if (!optional.isEmpty() && optional.get() instanceof ProtoChunk) {
-                    this.futures.set(i, CompletableFuture.completedFuture(Either.left(chunk)));
-                }
-            }
-        }
-
-        this.updateChunkToSave(CompletableFuture.completedFuture(Either.left(chunk.getWrapped())), "replaceProto");
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public List<Pair<ChunkStatus, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>>> getAllFutures() {
-        List<Pair<ChunkStatus, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>>> list = new ArrayList();
-
-        for (int i = 0; i < ChunkHolder.CHUNK_STATUSES.size(); ++i) {
-            list.add(Pair.of((ChunkStatus) ChunkHolder.CHUNK_STATUSES.get(i), (CompletableFuture) this.futures.get(i)));
-        }
-
-        return list;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     @FunctionalInterface
@@ -892,95 +460,7 @@ public class ChunkHolder {
         };
     }
 
-    // Paper start - Chunk gen/load priority system
-    volatile int neighborPriority = -1;
-    volatile int priorityBoost = 0;
-    public final java.util.concurrent.ConcurrentHashMap<ChunkHolder, ChunkStatus> neighbors = new java.util.concurrent.ConcurrentHashMap<>();
-    public final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<Integer> neighborPriorities = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>();
-    int requestedPriority = ChunkMap.MAX_CHUNK_DISTANCE + 1; // this priority is possible pending, but is used to ensure needless updates are not queued
-
-    private int getDemandedPriority() {
-        int priority = neighborPriority; // if we have a neighbor priority, use it
-        int myPriority = getMyPriority();
-
-        if (priority == -1 || (ticketLevel <= 33 && priority > myPriority)) {
-            priority = myPriority;
-        }
-
-        return Math.max(1, Math.min(Math.max(ticketLevel, ChunkMap.MAX_CHUNK_DISTANCE), priority));
-    }
-
-    private int getMyPriority() {
-        if (priorityBoost == DistanceManager.URGENT_PRIORITY) {
-            return 2; // Urgent - ticket level isn't always 31 so 33-30 = 3, but allow 1 more tasks to go below this for dependents
-        }
-        return ticketLevel - priorityBoost;
-    }
-
-    private int getNeighborsPriority() {
-        return (neighborPriorities.isEmpty() ? getMyPriority() : getDemandedPriority()) + 1;
-    }
-
-    public void onNeighborRequest(ChunkHolder neighbor, ChunkStatus status) {
-        neighbor.setNeighborPriority(this, getNeighborsPriority());
-        this.neighbors.compute(neighbor, (playerChunk, currentWantedStatus) -> {
-            if (currentWantedStatus == null || !currentWantedStatus.isOrAfter(status)) {
-                //System.out.println(this + " request " + neighbor + " at " + status + " currently " + currentWantedStatus);
-                return status;
-            } else {
-                //System.out.println(this + " requested " + neighbor + " at " + status + " but thats lower than other wanted status " + currentWantedStatus);
-                return currentWantedStatus;
-            }
-        });
-
-    }
-
-    public void onNeighborDone(ChunkHolder neighbor, ChunkStatus chunkstatus, ChunkAccess chunk) {
-        this.neighbors.compute(neighbor, (playerChunk, wantedStatus) -> {
-            if (wantedStatus != null && chunkstatus.isOrAfter(wantedStatus)) {
-                //System.out.println(this + " neighbor done at " + neighbor + " for status " + chunkstatus + " wanted " + wantedStatus);
-                neighbor.removeNeighborPriority(this);
-                return null;
-            } else {
-                //System.out.println(this + " neighbor finished our previous request at " + neighbor + " for status " + chunkstatus + " but we now want instead " + wantedStatus);
-                return wantedStatus;
-            }
-        });
-    }
-
-    private void removeNeighborPriority(ChunkHolder requester) {
-        synchronized (neighborPriorities) {
-            neighborPriorities.remove(requester.pos.toLong());
-            recalcNeighborPriority();
-        }
-        checkPriority();
-    }
-
-
-    private void setNeighborPriority(ChunkHolder requester, int priority) {
-        synchronized (neighborPriorities) {
-            if (!Integer.valueOf(priority).equals(neighborPriorities.put(requester.pos.toLong(), Integer.valueOf(priority)))) {
-                recalcNeighborPriority();
-            }
-        }
-        checkPriority();
-    }
-
-    private void recalcNeighborPriority() {
-        neighborPriority = -1;
-        if (!neighborPriorities.isEmpty()) {
-            synchronized (neighborPriorities) {
-                for (Integer neighbor : neighborPriorities.values()) {
-                    if (neighbor < neighborPriority || neighborPriority == -1) {
-                        neighborPriority = neighbor;
-                    }
-                }
-            }
-        }
-    }
-    private void checkPriority() {
-        if (this.requestedPriority != getDemandedPriority()) this.chunkMap.queueHolderUpdate(this);
-    }
+    // Paper - rewrite chunk system
 
     public final double getDistance(ServerPlayer player) {
         return getDistance(player.getX(), player.getZ());
@@ -1003,33 +483,26 @@ public class ChunkHolder {
         }
         return CHUNK_STATUSES.get(status.getIndex() + 1);
     }
-    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getStatusFutureUncheckedMain(ChunkStatus chunkstatus) {
-        return ensureMain(getFutureIfPresentUnchecked(chunkstatus));
-    }
-    public <T> CompletableFuture<T> ensureMain(CompletableFuture<T> future) {
-        return future.thenApplyAsync(r -> r, chunkMap.mainInvokingExecutor);
-    }
+    // Paper - rewrite chunk system
 
     @Override
     public String toString() {
+        // Paper start - rewrite chunk system
         return "PlayerChunk{" +
-            "location=" + pos +
-            ", ticketLevel=" + ticketLevel + "/" + getStatus(this.ticketLevel) +
-            ", chunkHolderStatus=" + getChunkHolderStatus() +
-            ", neighborPriority=" + getNeighborsPriority() +
-            ", priority=(" + ticketLevel + " - " + priorityBoost +" vs N " + neighborPriority + ") = " + getDemandedPriority() + " A " + queueLevel +
+            "location=" + this.pos +
             '}';
+        // Paper end - rewrite chunk system
     }
     public final boolean isEntityTickingReady() {
-        return this.isEntityTickingReady;
+        return this.newChunkHolder.isEntityTickingReady(); // Paper - rewrite chunk system
     }
 
     public final boolean isTickingReady() {
-        return this.isTickingReady;
+        return this.newChunkHolder.isTickingReady(); // Paper - rewrite chunk system
     }
 
     public final boolean isFullChunkReady() {
-        return this.isFullChunkReady;
+        return this.newChunkHolder.isFullChunkReady(); // Paper - rewrite chunk system
     }
     // Paper end
 }
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index c2c01988bf3b6fbb0a7a4716373c2ff0cffce27d..44eafeb815a15028ffe82b96b2df8f90285471b8 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -124,37 +124,33 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private static final int MIN_VIEW_DISTANCE = 3;
     public static final int MAX_VIEW_DISTANCE = 33;
     public static final int MAX_CHUNK_DISTANCE = 33 + ChunkStatus.maxDistance();
-    // Paper start - Don't copy
-    public final com.destroystokyo.paper.util.map.QueuedChangesMapLong2Object<ChunkHolder> updatingChunks = new com.destroystokyo.paper.util.map.QueuedChangesMapLong2Object<>();
-    // Paper end - Don't copy
+    // Paper - rewrite chunk system
     public static final int FORCED_TICKET_LEVEL = 31;
     // Paper - Don't copy
-    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads;
+    // Paper - rewrite chunk system
     public final LongSet entitiesInLevel;
     public final ServerLevel level;
     private final ThreadedLevelLightEngine lightEngine;
     public final BlockableEventLoop<Runnable> mainThreadExecutor; // Paper - public
-    final java.util.concurrent.Executor mainInvokingExecutor; // Paper
+    // Paper - rewrite chunk system
     public ChunkGenerator generator;
     private RandomState randomState;
     public final Supplier<DimensionDataStorage> overworldDataStorage;
     private final PoiManager poiManager;
-    public final LongSet toDrop;
+    // Paper - rewrite chunk system
     private boolean modified;
-    private final ChunkTaskPriorityQueueSorter queueSorter;
-    private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> worldgenMailbox;
-    public final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mainThreadMailbox;
+    // Paper - rewrite chunk system
     // Paper start
-    final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mailboxLight;
+    // Paper - rewrite chunk system
     public void addLightTask(ChunkHolder playerchunk, Runnable run) {
-        this.mailboxLight.tell(ChunkTaskPriorityQueueSorter.message(playerchunk, run));
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
     // Paper end
     public final ChunkProgressListener progressListener;
     private final ChunkStatusUpdateListener chunkStatusListener;
     public final ChunkMap.ChunkDistanceManager distanceManager;
     private final AtomicInteger tickingGenerated;
-    private final StructureTemplateManager structureTemplateManager;
+    public final StructureTemplateManager structureTemplateManager; // Paper - rewrite chunk system
     private final String storageName;
     private final PlayerMap playerMap;
     public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
@@ -403,7 +399,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public final ChunkHolder getUnloadingChunkHolder(int chunkX, int chunkZ) {
-        return this.pendingUnloads.get(io.papermc.paper.util.CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        return null; // Paper - rewrite chunk system
     }
     // Paper end
 
@@ -411,9 +407,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
         super(session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
         // Paper - don't copy
-        this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
+        // Paper - rewrite chunk system
         this.entitiesInLevel = new LongOpenHashSet();
-        this.toDrop = new LongOpenHashSet();
+        // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
         this.entityMap = new Int2ObjectOpenHashMap();
@@ -440,29 +436,17 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         this.mainThreadExecutor = mainThreadExecutor;
-        // Paper start
-        this.mainInvokingExecutor = (run) -> {
-            if (MCUtil.isMainThread()) {
-                run.run();
-            } else {
-                mainThreadExecutor.execute(run);
-            }
-        };
-        // Paper end
-        ProcessorMailbox<Runnable> threadedmailbox = ProcessorMailbox.create(executor, "worldgen");
+        // Paper - rewrite chunk system
 
         Objects.requireNonNull(mainThreadExecutor);
-        ProcessorHandle<Runnable> mailbox = ProcessorHandle.of("main", mainThreadExecutor::tell);
+        // Paper - rewrite chunk system
 
         this.progressListener = worldGenerationProgressListener;
         this.chunkStatusListener = chunkStatusChangeListener;
-        ProcessorMailbox<Runnable> lightthreaded; ProcessorMailbox<Runnable> threadedmailbox1 = lightthreaded = ProcessorMailbox.create(executor, "light"); // Paper
+        // Paper - rewrite chunk system
 
-        this.queueSorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(threadedmailbox, mailbox, threadedmailbox1), executor, Integer.MAX_VALUE);
-        this.worldgenMailbox = this.queueSorter.getProcessor(threadedmailbox, false);
-        this.mainThreadMailbox = this.queueSorter.getProcessor(mailbox, false);
-        this.mailboxLight = this.queueSorter.getProcessor(lightthreaded, false);// Paper
-        this.lightEngine = new ThreadedLevelLightEngine(chunkProvider, this, this.level.dimensionType().hasSkyLight(), threadedmailbox1, this.queueSorter.getProcessor(threadedmailbox1, false));
+        // Paper - rewrite chunk system
+        this.lightEngine = new ThreadedLevelLightEngine(chunkProvider, this, this.level.dimensionType().hasSkyLight(), null, null); // Paper - rewrite chunk system
         this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor);
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(path.resolve("poi"), dataFixer, dsync, world.registryAccess(), world);
@@ -581,36 +565,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         });
     }
 
-    // Paper start - Chunk Prioritization
-    public void queueHolderUpdate(ChunkHolder playerchunk) {
-        Runnable runnable = () -> {
-            if (isUnloading(playerchunk)) {
-                return; // unloaded
-            }
-            distanceManager.pendingChunkUpdates.add(playerchunk);
-            if (!distanceManager.pollingPendingChunkUpdates) {
-                level.getChunkSource().runDistanceManagerUpdates();
-            }
-        };
-        if (MCUtil.isMainThread()) {
-            // We can't use executor here because it will not execute tasks if its currently in the middle of executing tasks...
-            runnable.run();
-        } else {
-            mainThreadExecutor.execute(runnable);
-        }
-    }
-
-    private boolean isUnloading(ChunkHolder playerchunk) {
-        return playerchunk == null || toDrop.contains(playerchunk.pos.toLong());
-    }
+    // Paper - rewrite chunk system
 
-    private void updateChunkPriorityMap(it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap map, long chunk, int level) {
-        int prev = map.getOrDefault(chunk, -1);
-        if (level > prev) {
-            map.put(chunk, level);
-        }
-    }
-    // Paper end
     // Paper start
     public void updatePlayerMobTypeMap(Entity entity) {
         if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) {
@@ -667,25 +623,22 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     @Nullable
     public ChunkHolder getUpdatingChunkIfPresent(long pos) {
-        return this.updatingChunks.getUpdating(pos); // Paper - Don't copy
+        // Paper start - rewrite chunk system
+        io.papermc.paper.chunk.system.scheduling.NewChunkHolder holder = this.level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(pos);
+        return holder == null ? null : holder.vanillaChunkHolder;
+        // Paper end - rewrite chunk system
     }
 
     @Nullable
     public ChunkHolder getVisibleChunkIfPresent(long pos) {
-        // Paper start - Don't copy
-        if (Thread.currentThread() == this.level.thread) {
-            return this.updatingChunks.getVisible(pos);
-        }
-        return this.updatingChunks.getVisibleAsync(pos);
-        // Paper end - Don't copy
+        // Paper start - rewrite chunk system
+        io.papermc.paper.chunk.system.scheduling.NewChunkHolder holder = this.level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(pos);
+        return holder == null ? null : holder.vanillaChunkHolder;
+        // Paper end - rewrite chunk system
     }
 
     protected IntSupplier getChunkQueueLevel(long pos) {
-        return () -> {
-            ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos);
-
-            return playerchunk == null ? ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1 : Math.min(playerchunk.getQueueLevel(), ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1);
-        };
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public String getChunkDebugData(ChunkPos chunkPos) {
@@ -722,84 +675,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end
 
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
-        List<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> list = new ArrayList();
-        List<ChunkHolder> list1 = new ArrayList();
-        int j = centerChunk.x;
-        int k = centerChunk.z;
-        ChunkHolder requestingNeighbor = getUpdatingChunkIfPresent(centerChunk.toLong()); // Paper
-
-        for (int l = -margin; l <= margin; ++l) {
-            for (int i1 = -margin; i1 <= margin; ++i1) {
-                int j1 = Math.max(Math.abs(i1), Math.abs(l));
-                final ChunkPos chunkcoordintpair1 = new ChunkPos(j + i1, k + l);
-                long k1 = chunkcoordintpair1.toLong();
-                ChunkHolder playerchunk = this.getUpdatingChunkIfPresent(k1);
-
-                if (playerchunk == null) {
-                    return CompletableFuture.completedFuture(Either.right(new ChunkHolder.ChunkLoadingFailure() {
-                        public String toString() {
-                            return "Unloaded " + chunkcoordintpair1;
-                        }
-                    }));
-                }
-
-                ChunkStatus chunkstatus = (ChunkStatus) distanceToStatus.apply(j1);
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = playerchunk.getOrScheduleFuture(chunkstatus, this);
-                // Paper start
-                if (requestingNeighbor != null && requestingNeighbor != playerchunk && !completablefuture.isDone()) {
-                    requestingNeighbor.onNeighborRequest(playerchunk, chunkstatus);
-                    completablefuture.thenAccept(either -> {
-                        requestingNeighbor.onNeighborDone(playerchunk, chunkstatus, either.left().orElse(null));
-                    });
-                }
-                // Paper end
-
-                list1.add(playerchunk);
-                list.add(completablefuture);
-            }
-        }
-
-        CompletableFuture<List<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> completablefuture1 = Util.sequence(list);
-        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completablefuture2 = completablefuture1.thenApply((list2) -> {
-            List<ChunkAccess> list3 = Lists.newArrayList();
-            // CraftBukkit start - decompile error
-            int cnt = 0;
-
-            for (Iterator iterator = list2.iterator(); iterator.hasNext(); ++cnt) {
-                final int l1 = cnt;
-                // CraftBukkit end
-                final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = (Either) iterator.next();
-
-                if (either == null) {
-                    throw this.debugFuturesAndCreateReportedException(new IllegalStateException("At least one of the chunk futures were null"), "n/a");
-                }
-
-                Optional<ChunkAccess> optional = either.left();
-
-                if (!optional.isPresent()) {
-                    return Either.right(new ChunkHolder.ChunkLoadingFailure() {
-                        public String toString() {
-                            ChunkPos chunkcoordintpair2 = new ChunkPos(j + l1 % (margin * 2 + 1), k + l1 / (margin * 2 + 1));
-
-                            return "Unloaded " + chunkcoordintpair2 + " " + either.right().get();
-                        }
-                    });
-                }
-
-                list3.add((ChunkAccess) optional.get());
-            }
-
-            return Either.left(list3);
-        });
-        Iterator iterator = list1.iterator();
-
-        while (iterator.hasNext()) {
-            ChunkHolder playerchunk1 = (ChunkHolder) iterator.next();
-
-            playerchunk1.addSaveDependency("getChunkRangeFuture " + centerChunk + " " + margin, completablefuture2);
-        }
-
-        return completablefuture2;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public ReportedException debugFuturesAndCreateReportedException(IllegalStateException exception, String details) {
@@ -829,65 +705,17 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareEntityTickingChunk(ChunkPos pos) {
-        return this.getChunkRangeFuture(pos, 2, (i) -> {
-            return ChunkStatus.FULL;
-        }).thenApplyAsync((either) -> {
-            return either.mapLeft((list) -> {
-                return (LevelChunk) list.get(list.size() / 2);
-            });
-        }, this.mainInvokingExecutor); // Paper
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     @Nullable
     ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int k) {
-        if (this.unloadingPlayerChunk) { net.minecraft.server.MinecraftServer.LOGGER.error("Cannot tick distance manager while unloading playerchunks", new Throwable()); throw new IllegalStateException("Cannot tick distance manager while unloading playerchunks"); } // Paper
-        if (k > ChunkMap.MAX_CHUNK_DISTANCE && level > ChunkMap.MAX_CHUNK_DISTANCE) {
-            return holder;
-        } else {
-            if (holder != null) {
-                holder.setTicketLevel(level);
-            }
-
-            if (holder != null) {
-                if (level > ChunkMap.MAX_CHUNK_DISTANCE) {
-                    this.toDrop.add(pos);
-                } else {
-                    this.toDrop.remove(pos);
-                }
-            }
-
-            if (level <= ChunkMap.MAX_CHUNK_DISTANCE && holder == null) {
-                holder = (ChunkHolder) this.pendingUnloads.remove(pos);
-                if (holder != null) {
-                    holder.setTicketLevel(level);
-                } else {
-                    holder = new ChunkHolder(new ChunkPos(pos), level, this.level, this.lightEngine, this.queueSorter, this);
-                    // Paper start
-                    net.minecraft.server.ChunkSystem.onChunkHolderCreate(this.level, holder);
-                    // Paper end
-                }
-
-                // Paper start
-                holder.onChunkAdd();
-                // Paper end
-                this.updatingChunks.queueUpdate(pos, holder); // Paper - Don't copy
-                this.modified = true;
-            }
-
-            return holder;
-        }
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     @Override
     public void close() throws IOException {
-        try {
-            this.queueSorter.close();
-            this.level.asyncChunkTaskManager.close(true); // Paper - Required since we're closing regionfiles in the next line
-            this.poiManager.close();
-        } finally {
-            super.close();
-        }
-
+        throw new UnsupportedOperationException("Use ServerChunkCache#close"); // Paper - rewrite chunk system
     }
 
     // Paper start - incremental autosave
@@ -901,100 +729,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     });
 
     protected void saveIncrementally() {
-        int savedThisTick = 0;
-        // optimized since we search far less chunks to hit ones that need to be saved
-        List<ChunkHolder> reschedule = new java.util.ArrayList<>(this.level.paperConfig().chunks.maxAutoSaveChunksPerTick);
-        long currentTick = this.level.getGameTime();
-        long maxSaveTime = currentTick - this.level.paperConfig().chunks.autoSaveInterval.value();
-
-        for (Iterator<ChunkHolder> iterator = this.autoSaveQueue.iterator(); iterator.hasNext();) {
-            ChunkHolder playerchunk = iterator.next();
-            if (playerchunk.lastAutoSaveTime > maxSaveTime) {
-                break;
-            }
-
-            iterator.remove();
-
-            ChunkAccess ichunkaccess = playerchunk.getChunkToSave().getNow(null);
-            if (ichunkaccess instanceof LevelChunk) {
-                boolean shouldSave = ((LevelChunk)ichunkaccess).lastSaveTime <= maxSaveTime;
-
-                if (shouldSave && this.save(ichunkaccess) && this.level.entityManager.storeChunkSections(playerchunk.pos.toLong(), entity -> {})) {
-                    ++savedThisTick;
-
-                    if (!playerchunk.setHasBeenLoaded()) {
-                        // do not fall through to reschedule logic
-                        playerchunk.inactiveTimeStart = currentTick;
-                        if (savedThisTick >= this.level.paperConfig().chunks.maxAutoSaveChunksPerTick) {
-                            break;
-                        }
-                        continue;
-                    }
-                }
-            }
-
-            reschedule.add(playerchunk);
-
-            if (savedThisTick >= this.level.paperConfig().chunks.maxAutoSaveChunksPerTick) {
-                break;
-            }
-        }
-
-        for (int i = 0, len = reschedule.size(); i < len; ++i) {
-            ChunkHolder playerchunk = reschedule.get(i);
-            playerchunk.lastAutoSaveTime = this.level.getGameTime();
-            this.autoSaveQueue.add(playerchunk);
-        }
+        this.level.chunkTaskScheduler.chunkHolderManager.autoSave(); // Paper - rewrite chunk system
     }
     // Paper end
 
     protected void saveAllChunks(boolean flush) {
-        // Paper start - do not overload I/O threads with too much work when saving
-        int[] saved = new int[1];
-        int maxAsyncSaves = 50;
-        Runnable onChunkSave = () -> {
-            if (++saved[0] >= maxAsyncSaves) {
-                saved[0] = 0;
-                com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.flush();
-            }
-        };
-        // Paper end - do not overload I/O threads with too much work when saving
-        if (flush) {
-            List<ChunkHolder> list = (List) net.minecraft.server.ChunkSystem.getVisibleChunkHolders(this.level).stream().filter(ChunkHolder::wasAccessibleSinceLastSave).peek(ChunkHolder::refreshAccessibility).collect(Collectors.toList()); // Paper
-            MutableBoolean mutableboolean = new MutableBoolean();
-
-            do {
-                boolean isShuttingDown = level.getServer().hasStopped(); // Paper
-                mutableboolean.setFalse();
-                list.stream().map((playerchunk) -> {
-                    CompletableFuture completablefuture;
-
-                    do {
-                        completablefuture = playerchunk.getChunkToSave();
-                        BlockableEventLoop iasynctaskhandler = this.mainThreadExecutor;
-
-                        Objects.requireNonNull(completablefuture);
-                        iasynctaskhandler.managedBlock(completablefuture::isDone);
-                    } while (completablefuture != playerchunk.getChunkToSave());
-
-                    return (ChunkAccess) completablefuture.join();
-                }).filter((ichunkaccess) -> {
-                    return ichunkaccess instanceof ImposterProtoChunk || ichunkaccess instanceof LevelChunk;
-                }).filter(this::save).forEach((ichunkaccess) -> {
-                    onChunkSave.run(); // Paper - do not overload I/O threads with too much work when saving
-                    mutableboolean.setTrue();
-                });
-            } while (mutableboolean.isTrue());
-
-            this.processUnloads(() -> {
-                return true;
-            });
-            //this.flushWorker(); // Paper - nuke IOWorker
-            this.level.asyncChunkTaskManager.flush(); // Paper - flush to preserve behavior compat with pre-async behaviour
-        } else {
-            net.minecraft.server.ChunkSystem.getVisibleChunkHolders(this.level).forEach(this::saveChunkIfNeeded);
-        }
-
+        this.level.chunkTaskScheduler.chunkHolderManager.saveAllChunks(flush, false, false); // Paper - rewrite chunk system
     }
 
     protected void tick(BooleanSupplier shouldKeepTicking) {
@@ -1015,206 +755,28 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public boolean hasWork() {
-        return this.lightEngine.hasLightWork() || !this.pendingUnloads.isEmpty() || net.minecraft.server.ChunkSystem.hasAnyChunkHolders(this.level) || this.poiManager.hasWork() || !this.toDrop.isEmpty() || !this.unloadQueue.isEmpty() || this.queueSorter.hasWork() || this.distanceManager.hasTickets(); // Paper
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     private void processUnloads(BooleanSupplier shouldKeepTicking) {
-        LongIterator longiterator = this.toDrop.iterator();
-        for (int i = 0; longiterator.hasNext() && (shouldKeepTicking.getAsBoolean() || i < 200 || this.toDrop.size() > 2000); longiterator.remove()) { // Paper - diff on change
-            long j = longiterator.nextLong();
-            ChunkHolder playerchunk = this.updatingChunks.queueRemove(j); // Paper - Don't copy
-
-            if (playerchunk != null) {
-                playerchunk.onChunkRemove(); // Paper
-                this.pendingUnloads.put(j, playerchunk);
-                this.modified = true;
-                ++i;
-                this.scheduleUnload(j, playerchunk);
-            }
-        }
-
-        int k = Math.max(100, this.unloadQueue.size() - 2000); // Paper - Unload more than just up to queue size 2000
-
-        Runnable runnable;
-
-        while ((shouldKeepTicking.getAsBoolean() || k > 0) && (runnable = (Runnable) this.unloadQueue.poll()) != null) {
-            --k;
-            runnable.run();
-        }
-
-        int l = 0;
-        // Paper - incremental chunk and player saving
+        this.level.chunkTaskScheduler.chunkHolderManager.processUnloads(); // Paper - rewrite chunk system
 
     }
 
     private void scheduleUnload(long pos, ChunkHolder holder) {
-        CompletableFuture<ChunkAccess> completablefuture = holder.getChunkToSave();
-        Consumer<ChunkAccess> consumer = (ichunkaccess) -> { // CraftBukkit - decompile error
-            CompletableFuture<ChunkAccess> completablefuture1 = holder.getChunkToSave();
-
-            if (completablefuture1 != completablefuture) {
-                this.scheduleUnload(pos, holder);
-            } else {
-                // Paper start - do not allow ticket level changes while unloading chunks
-                org.spigotmc.AsyncCatcher.catchOp("playerchunk unload");
-                boolean unloadingBefore = this.unloadingPlayerChunk;
-                this.unloadingPlayerChunk = true;
-                try {
-                    // Paper end - do not allow ticket level changes while unloading chunks
-                // Paper start
-                boolean removed;
-                if ((removed = this.pendingUnloads.remove(pos, holder)) && ichunkaccess != null) {
-                    net.minecraft.server.ChunkSystem.onChunkHolderDelete(this.level, holder);
-                    // Paper end
-                    if (ichunkaccess instanceof LevelChunk) {
-                        ((LevelChunk) ichunkaccess).setLoaded(false);
-                    }
-
-                    // Paper start - async chunk saving
-                    try {
-                        this.asyncSave(ichunkaccess);
-                    } catch (ThreadDeath ex) {
-                        throw ex; // bye
-                    } catch (Throwable ex) {
-                        LOGGER.error("Failed to prepare async save, attempting synchronous save", ex);
-                        this.save(ichunkaccess);
-                    }
-                    // Paper end - async chunk saving
-                    if (this.entitiesInLevel.remove(pos) && ichunkaccess instanceof LevelChunk) {
-                        LevelChunk chunk = (LevelChunk) ichunkaccess;
-
-                        this.level.unload(chunk);
-                    }
-                    this.autoSaveQueue.remove(holder); // Paper
-
-                    this.lightEngine.updateChunkStatus(ichunkaccess.getPos());
-                    this.lightEngine.tryScheduleUpdate();
-                    this.progressListener.onStatusChange(ichunkaccess.getPos(), (ChunkStatus) null);
-                    this.chunkSaveCooldowns.remove(ichunkaccess.getPos().toLong());
-                } else if (removed) { // Paper start
-                    net.minecraft.server.ChunkSystem.onChunkHolderDelete(this.level, holder);
-                } // Paper end
-                } finally { this.unloadingPlayerChunk = unloadingBefore; } // Paper - do not allow ticket level changes while unloading chunks
-
-            }
-        };
-        Queue queue = this.unloadQueue;
-
-        Objects.requireNonNull(this.unloadQueue);
-        completablefuture.thenAcceptAsync(consumer, queue::add).whenComplete((ovoid, throwable) -> {
-            if (throwable != null) {
-                ChunkMap.LOGGER.error("Failed to save chunk {}", holder.getPos(), throwable);
-            }
-
-        });
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     protected boolean promoteChunkMap() {
-        if (!this.modified) {
-            return false;
-        } else {
-            // Paper start - Don't copy
-            synchronized (this.updatingChunks) {
-                this.updatingChunks.performUpdates();
-            }
-            // Paper end - Don't copy
-
-            this.modified = false;
-            return true;
-        }
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> schedule(ChunkHolder holder, ChunkStatus requiredStatus) {
-        ChunkPos chunkcoordintpair = holder.getPos();
-
-        if (requiredStatus == ChunkStatus.EMPTY) {
-            return this.scheduleChunkLoad(chunkcoordintpair);
-        } else {
-            // Paper start - revert 1.17 chunk system changes
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = holder.getOrScheduleFuture(requiredStatus.getParent(), this);
-        return future.thenComposeAsync((either) -> {
-            Optional<ChunkAccess> optional = either.left();
-            if (!optional.isPresent()) {
-                return CompletableFuture.completedFuture(either);
-            }
-            // Paper end - revert 1.17 chunk system changes
-            if (requiredStatus == ChunkStatus.LIGHT) {
-                this.distanceManager.addTicket(TicketType.LIGHT, chunkcoordintpair, 33 + ChunkStatus.getDistance(ChunkStatus.LIGHT), chunkcoordintpair);
-            }
-
-            // Paper - revert 1.17 chunk system changes
-
-            if (optional.isPresent() && ((ChunkAccess) optional.get()).getStatus().isOrAfter(requiredStatus)) {
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = requiredStatus.load(this.level, this.structureTemplateManager, this.lightEngine, (ichunkaccess) -> {
-                    return this.protoChunkToFullChunk(holder);
-                }, (ChunkAccess) optional.get());
-
-                this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
-                return completablefuture;
-            } else {
-                return this.scheduleChunkGeneration(holder, requiredStatus);
-            }
-        }, this.mainThreadExecutor).thenComposeAsync(CompletableFuture::completedFuture, this.mainThreadExecutor); // Paper - revert 1.17 chunk system changes
-        }
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> scheduleChunkLoad(ChunkPos pos) {
-        // Paper start - Async chunk io
-        final java.util.function.BiFunction<ChunkSerializer.InProgressChunkHolder, Throwable, Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> syncLoadComplete = (chunkHolder, ioThrowable) -> {
-            try (Timing ignored = this.level.timings.chunkLoad.startTimingIfSync()) { // Paper
-                this.level.getProfiler().incrementCounter("chunkLoad");
-                if (ioThrowable != null) {
-                    return this.handleChunkLoadFailure(ioThrowable, pos);
-                }
-                this.poiManager.loadInData(pos, chunkHolder.poiData);
-                chunkHolder.tasks.forEach(Runnable::run);
-                this.getPoiManager().dequeueUnload(pos.longKey); // Paper
-
-                if (chunkHolder.protoChunk != null) {
-                    ProtoChunk protochunk = chunkHolder.protoChunk;
-                    this.markPosition(pos, protochunk.getStatus().getChunkType());
-                    return Either.left(protochunk);
-                }
-            } catch (Exception ex) {
-                return this.handleChunkLoadFailure(ex, pos);
-            }
-
-            return Either.left(this.createEmptyChunk(pos));
-        };
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> ret = new CompletableFuture<>();
-
-        Consumer<ChunkSerializer.InProgressChunkHolder> chunkHolderConsumer = (ChunkSerializer.InProgressChunkHolder holder) -> {
-            // Go into the chunk load queue and not server task queue so we can be popped out even faster.
-            com.destroystokyo.paper.io.chunk.ChunkTaskManager.queueChunkWaitTask(() -> {
-                try {
-                    ret.complete(syncLoadComplete.apply(holder, null));
-                } catch (Exception e) {
-                    ret.completeExceptionally(e);
-                }
-            });
-        };
-
-        CompletableFuture<CompoundTag> chunkSaveFuture = this.level.asyncChunkTaskManager.getChunkSaveFuture(pos.x, pos.z);
-        // Paper start
-        ChunkHolder playerChunk = getUpdatingChunkIfPresent(pos.toLong());
-        int chunkPriority = playerChunk != null ? playerChunk.requestedPriority : 33;
-        int priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
-
-        if (chunkPriority <= 10) {
-            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
-        } else if (chunkPriority <= 20) {
-            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
-        }
-        boolean isHighestPriority = priority == com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
-        // Paper end
-        if (chunkSaveFuture != null) {
-            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z, priority, chunkHolderConsumer, isHighestPriority, chunkSaveFuture); // Paper
-        } else {
-            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z, priority, chunkHolderConsumer, isHighestPriority); // Paper
-        }
-        this.level.asyncChunkTaskManager.raisePriority(pos.x, pos.z, priority); // Paper
-        return ret;
-        // Paper end - Async chunk io
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public static boolean isChunkDataValid(CompoundTag nbt) { // Paper - async chunk loading
@@ -1253,54 +815,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> scheduleChunkGeneration(ChunkHolder holder, ChunkStatus requiredStatus) {
-        ChunkPos chunkcoordintpair = holder.getPos();
-        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkRangeFuture(chunkcoordintpair, requiredStatus.getRange(), (i) -> {
-            return this.getDependencyStatus(requiredStatus, i);
-        });
-
-        this.level.getProfiler().incrementCounter(() -> {
-            return "chunkGenerate " + requiredStatus.getName();
-        });
-        Executor executor = (runnable) -> {
-            // Paper start - optimize chunk status progression without jumping through thread pool
-            if (holder.canAdvanceStatus()) {
-                this.mainInvokingExecutor.execute(runnable);
-                return;
-            }
-            // Paper end
-            this.worldgenMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
-        };
-
-        return completablefuture.thenComposeAsync((either) -> {
-            return (CompletionStage) either.map((list) -> {
-                try {
-                    CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = requiredStatus.generate(executor, this.level, this.generator, this.structureTemplateManager, this.lightEngine, (ichunkaccess) -> {
-                        return this.protoChunkToFullChunk(holder);
-                    }, list, false);
-
-                    this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
-                    return completablefuture1;
-                } catch (Exception exception) {
-                    exception.getStackTrace();
-                    CrashReport crashreport = CrashReport.forThrowable(exception, "Exception generating new chunk");
-                    CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Chunk to be generated");
-
-                    crashreportsystemdetails.setDetail("Location", (Object) String.format(Locale.ROOT, "%d,%d", chunkcoordintpair.x, chunkcoordintpair.z));
-                    crashreportsystemdetails.setDetail("Position hash", (Object) ChunkPos.asLong(chunkcoordintpair.x, chunkcoordintpair.z));
-                    crashreportsystemdetails.setDetail("Generator", (Object) this.generator);
-                    this.mainThreadExecutor.execute(() -> {
-                        throw new ReportedException(crashreport);
-                    });
-                    throw new ReportedException(crashreport);
-                }
-            }, (playerchunk_failure) -> {
-                this.releaseLightTicket(chunkcoordintpair);
-                return CompletableFuture.completedFuture(Either.right(playerchunk_failure));
-            });
-        }, executor).thenComposeAsync((either) -> { // Paper start - force competion on the main thread
-            return CompletableFuture.completedFuture(either);
-        }, this.mainThreadExecutor); // use the main executor, we want to ensure only one chunk callback can be completed per runnable execute
-        // Paper end - force competion on the main thread
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     protected void releaseLightTicket(ChunkPos pos) {
@@ -1311,7 +826,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }));
     }
 
-    private ChunkStatus getDependencyStatus(ChunkStatus centerChunkTargetStatus, int distance) {
+    public static ChunkStatus getDependencyStatus(ChunkStatus centerChunkTargetStatus, int distance) { // Paper -> public, static
         ChunkStatus chunkstatus1;
 
         if (distance == 0) {
@@ -1323,7 +838,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         return chunkstatus1;
     }
 
-    private static void postLoadProtoChunk(ServerLevel world, List<CompoundTag> nbt) {
+    public static void postLoadProtoChunk(ServerLevel world, List<CompoundTag> nbt) { // Paper - public
         if (!nbt.isEmpty()) {
             // CraftBukkit start - these are spawned serialized (DefinedStructure) and we don't call an add event below at the moment due to ordering complexities
             world.addWorldGenChunkEntities(EntityType.loadEntitiesRecursive(nbt, world).filter((entity) -> {
@@ -1346,46 +861,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> protoChunkToFullChunk(ChunkHolder chunkHolder) {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = chunkHolder.getFutureIfPresentUnchecked(ChunkStatus.FULL.getParent());
-
-        return completablefuture.thenApplyAsync((either) -> {
-            ChunkStatus chunkstatus = ChunkHolder.getStatus(chunkHolder.getTicketLevel());
-
-            return !chunkstatus.isOrAfter(ChunkStatus.FULL) ? ChunkHolder.UNLOADED_CHUNK : either.mapLeft((ichunkaccess) -> {
-                try (Timing ignored = level.timings.chunkPostLoad.startTimingIfSync()) { // Paper
-                ChunkPos chunkcoordintpair = chunkHolder.getPos();
-                ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
-                LevelChunk chunk;
-
-                if (protochunk instanceof ImposterProtoChunk) {
-                    chunk = ((ImposterProtoChunk) protochunk).getWrapped();
-                } else {
-                    chunk = new LevelChunk(this.level, protochunk, (chunk1) -> {
-                        ChunkMap.postLoadProtoChunk(this.level, protochunk.getEntities());
-                    });
-                    chunkHolder.replaceProtoChunk(new ImposterProtoChunk(chunk, false));
-                }
-
-                chunk.setFullStatus(() -> {
-                    return ChunkHolder.getFullChunkStatus(chunkHolder.getTicketLevel());
-                });
-                chunk.runPostLoad();
-                if (this.entitiesInLevel.add(chunkcoordintpair.toLong())) {
-                    chunk.setLoaded(true);
-                    chunk.registerAllBlockEntitiesAfterLevelLoad();
-                    chunk.registerTickContainerInLevel(this.level);
-                }
-
-                return chunk;
-                } // Paper
-            });
-        }, (runnable) -> {
-            ProcessorHandle mailbox = this.mainThreadMailbox;
-            long i = chunkHolder.getPos().toLong();
-
-            Objects.requireNonNull(chunkHolder);
-            mailbox.tell(ChunkTaskPriorityQueueSorter.message(runnable, i, () -> 1)); // Paper - final loads are always urgent!
-        });
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     // Paper start
@@ -1432,31 +908,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end
     public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareTickingChunk(ChunkHolder holder) {
-        ChunkPos chunkcoordintpair = holder.getPos();
-        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkRangeFuture(chunkcoordintpair, 1, (i) -> {
-            return ChunkStatus.FULL;
-        });
-        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = completablefuture.thenApplyAsync((either) -> {
-            return either.mapLeft((list) -> {
-                // Paper start - revert 1.18.2 diff
-                final LevelChunk chunk = (LevelChunk) list.get(list.size() / 2);
-                chunk.postProcessGeneration();
-                this.level.startTickingChunk(chunk);
-                return chunk;
-            });
-        }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, () -> ChunkMap.this.chunkLoadConversionCallbackExecutor.execute(runnable))); // Paper - delay running Chunk post processing until outside of the sorter to prevent a deadlock scenario when post processing causes another chunk request.
-        }); // Paper end - revert 1.18.2 diff
-
-        completablefuture1.thenAcceptAsync((either) -> {
-            either.ifLeft((chunk) -> {
-                this.tickingGenerated.getAndIncrement();
-                // Paper - no-tick view distance - moved to Chunk neighbour update
-            });
-        }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
-        });
-        return completablefuture1;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareAccessibleChunk(ChunkHolder holder) {
@@ -1474,32 +926,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private boolean saveChunkIfNeeded(ChunkHolder chunkHolder) {
-        if (!chunkHolder.wasAccessibleSinceLastSave()) {
-            return false;
-        } else {
-            ChunkAccess ichunkaccess = (ChunkAccess) chunkHolder.getChunkToSave().getNow(null); // CraftBukkit - decompile error
-
-            if (!(ichunkaccess instanceof ImposterProtoChunk) && !(ichunkaccess instanceof LevelChunk)) {
-                return false;
-            } else {
-                long i = ichunkaccess.getPos().toLong();
-                long j = this.chunkSaveCooldowns.getOrDefault(i, -1L);
-                long k = System.currentTimeMillis();
-
-                if (k < j) {
-                    return false;
-                } else {
-                    boolean flag = this.save(ichunkaccess);
-
-                    chunkHolder.refreshAccessibility();
-                    if (flag) {
-                        this.chunkSaveCooldowns.put(i, k + 10000L);
-                    }
-
-                    return flag;
-                }
-            }
-        }
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     // Paper start - async chunk save for unload
@@ -1507,110 +934,16 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // This is also modeled after PlayerChunkMap#save(IChunkAccess, boolean), with the intentional difference being
     // serializing the chunk is left to a worker thread.
     private void asyncSave(ChunkAccess chunk) {
-        ChunkPos chunkPos = chunk.getPos();
-        CompoundTag poiData;
-        try (Timing ignored = this.level.timings.chunkUnloadPOISerialization.startTiming()) {
-            poiData = this.poiManager.getData(chunk.getPos());
-        }
-
-        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.level, chunkPos.x, chunkPos.z,
-            poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
-
-        if (!chunk.isUnsaved()) {
-            return;
-        }
-
-        ChunkStatus chunkstatus = chunk.getStatus();
-
-        // Copied from PlayerChunkMap#save(IChunkAccess, boolean)
-        if (chunkstatus.getChunkType() != ChunkStatus.ChunkType.LEVELCHUNK) {
-            // Paper start - Optimize save by using status cache
-            if (chunkstatus == ChunkStatus.EMPTY && chunk.getAllStarts().values().stream().noneMatch(StructureStart::isValid)) {
-                return;
-            }
-        }
-
-        ChunkSerializer.AsyncSaveData asyncSaveData;
-        try (Timing ignored = this.level.timings.chunkUnloadPrepareSave.startTiming()) {
-            asyncSaveData = ChunkSerializer.getAsyncSaveData(this.level, chunk);
-        }
-
-        this.level.asyncChunkTaskManager.scheduleChunkSave(chunkPos.x, chunkPos.z, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY,
-            asyncSaveData, chunk);
-
-        chunk.setUnsaved(false);
-        chunk.setLastSaved(this.level.getGameTime()); // Paper - track last saved time
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
     // Paper end
 
     public boolean save(ChunkAccess chunk) {
-        try (co.aikar.timings.Timing ignored = this.level.timings.chunkSave.startTiming()) { // Paper
-        this.poiManager.flush(chunk.getPos());
-        if (!chunk.isUnsaved()) {
-            return false;
-        } else {
-            chunk.setLastSaved(this.level.getGameTime()); // Paper - track save time
-            chunk.setUnsaved(false);
-            ChunkPos chunkcoordintpair = chunk.getPos();
-
-            try {
-                ChunkStatus chunkstatus = chunk.getStatus();
-
-                if (chunkstatus.getChunkType() != ChunkStatus.ChunkType.LEVELCHUNK) {
-                    if (false && this.isExistingChunkFull(chunkcoordintpair)) { // Paper
-                        return false;
-                    }
-
-                    if (chunkstatus == ChunkStatus.EMPTY && chunk.getAllStarts().values().stream().noneMatch(StructureStart::isValid)) {
-                        return false;
-                    }
-                }
-
-                this.level.getProfiler().incrementCounter("chunkSave");
-                CompoundTag nbttagcompound;
-                try (co.aikar.timings.Timing ignored1 = this.level.timings.chunkSaveDataSerialization.startTiming()) { // Paper
-                    nbttagcompound = ChunkSerializer.write(this.level, chunk);
-                } // Paper
-
-                // Paper start - async chunk io
-                com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.level, chunkcoordintpair.x, chunkcoordintpair.z,
-                    null, nbttagcompound, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
-                // Paper end - async chunk io
-                this.markPosition(chunkcoordintpair, chunkstatus.getChunkType());
-                return true;
-            } catch (Exception exception) {
-                ChunkMap.LOGGER.error("Failed to save chunk {},{}", new Object[]{chunkcoordintpair.x, chunkcoordintpair.z, exception});
-                com.destroystokyo.paper.exception.ServerInternalException.reportInternalException(exception); // Paper
-                return false;
-            }
-        }
-        } // Paper
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     private boolean isExistingChunkFull(ChunkPos pos) {
-        byte b0 = this.chunkTypeCache.get(pos.toLong());
-
-        if (b0 != 0) {
-            return b0 == 1;
-        } else {
-            CompoundTag nbttagcompound;
-
-            try {
-                nbttagcompound = (CompoundTag) ((Optional) this.readChunk(pos).join()).orElse((Object) null);
-                if (nbttagcompound == null) {
-                    this.markPositionReplaceable(pos);
-                    return false;
-                }
-            } catch (Exception exception) {
-                ChunkMap.LOGGER.error("Failed to read chunk {}", pos, exception);
-                this.markPositionReplaceable(pos);
-                return false;
-            }
-
-            ChunkStatus.ChunkType chunkstatus_type = ChunkSerializer.getChunkTypeFromTag(nbttagcompound);
-
-            return this.markPosition(pos, chunkstatus_type) == 1;
-        }
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public void setViewDistance(int watchDistance) {
@@ -1667,30 +1000,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     void dumpChunks(Writer writer) throws IOException {
-        CsvOutput csvwriter = CsvOutput.builder().addColumn("x").addColumn("z").addColumn("level").addColumn("in_memory").addColumn("status").addColumn("full_status").addColumn("accessible_ready").addColumn("ticking_ready").addColumn("entity_ticking_ready").addColumn("ticket").addColumn("spawning").addColumn("block_entity_count").addColumn("ticking_ticket").addColumn("ticking_level").addColumn("block_ticks").addColumn("fluid_ticks").build(writer);
-        // Paper - replace loader system
-        Iterator<ChunkHolder> objectbidirectionaliterator = net.minecraft.server.ChunkSystem.getVisibleChunkHolders(this.level).iterator(); // Paper
-
-        while (objectbidirectionaliterator.hasNext()) {
-            ChunkHolder playerchunk = objectbidirectionaliterator.next(); // Paper
-            long i = playerchunk.pos.toLong(); // Paper
-            ChunkPos chunkcoordintpair = new ChunkPos(i);
-            // Paper
-            Optional<ChunkAccess> optional = Optional.ofNullable(playerchunk.getLastAvailable());
-            Optional<LevelChunk> optional1 = optional.flatMap((ichunkaccess) -> {
-                return ichunkaccess instanceof LevelChunk ? Optional.of((LevelChunk) ichunkaccess) : Optional.empty();
-            });
-
-            // CraftBukkit - decompile error
-            csvwriter.writeRow(chunkcoordintpair.x, chunkcoordintpair.z, playerchunk.getTicketLevel(), optional.isPresent(), optional.map(ChunkAccess::getStatus).orElse(null), optional1.map(LevelChunk::getFullStatus).orElse(null), ChunkMap.printFuture(playerchunk.getFullChunkFuture()), ChunkMap.printFuture(playerchunk.getTickingChunkFuture()), ChunkMap.printFuture(playerchunk.getEntityTickingChunkFuture()), this.distanceManager.getTicketDebugString(i), this.anyPlayerCloseEnoughForSpawning(chunkcoordintpair), optional1.map((chunk) -> {
-                return chunk.getBlockEntities().size();
-            }).orElse(0), "Use ticket level", -1000, optional1.map((chunk) -> { // Paper - replace loader system
-                return chunk.getBlockTicks().count();
-            }).orElse(0), optional1.map((chunk) -> {
-                return chunk.getFluidTicks().count();
-            }).orElse(0));
-        }
-
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     private static String printFuture(CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> future) {
@@ -1713,27 +1023,27 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     @Nullable
     @Override
     public CompoundTag readSync(ChunkPos chunkcoordintpair) throws IOException {
-        if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
-            CompoundTag ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
-                .loadChunkDataAsyncFuture(this.level, chunkcoordintpair.x, chunkcoordintpair.z, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
-                    false, true, true).join().chunkData;
-
-            if (ret == com.destroystokyo.paper.io.PaperFileIOThread.FAILURE_VALUE) {
-                throw new IOException("See logs for further detail");
-            }
-            return ret;
-        }
+        // Paper start - rewrite chunk system
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            return io.papermc.paper.chunk.system.io.RegionFileIOThread.loadData(
+                this.level, chunkcoordintpair.x, chunkcoordintpair.z, io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.getIOBlockingPriorityForCurrentThread()
+            );
+        }
+        // Paper end - rewrite chunk system
         return super.readSync(chunkcoordintpair);
     }
 
     @Override
     public void write(ChunkPos chunkcoordintpair, CompoundTag nbttagcompound) throws IOException {
-        if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
-            com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
-                this.level, chunkcoordintpair.x, chunkcoordintpair.z, null, nbttagcompound,
-                com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
+        // Paper start - rewrite chunk system
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            io.papermc.paper.chunk.system.io.RegionFileIOThread.scheduleSave(
+                this.level, chunkcoordintpair.x, chunkcoordintpair.z, nbttagcompound,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA);
             return;
         }
+        // Paper end - rewrite chunk system
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
@@ -1806,8 +1116,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public ChunkAccess getUnloadingChunk(int chunkX, int chunkZ) {
-        ChunkHolder chunkHolder = this.pendingUnloads.get(ChunkPos.asLong(chunkX, chunkZ));
-        return chunkHolder == null ? null : chunkHolder.getAvailableChunkNow();
+        return null; // Paper - rewrite chunk system
     }
     // Paper end
 
@@ -2331,7 +1640,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         @Override
         protected boolean isChunkToRemove(long pos) {
-            return ChunkMap.this.toDrop.contains(pos);
+            throw new UnsupportedOperationException(); // Paper - rewrite chunk system
         }
 
         @Nullable
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index d1b5c25b7455174e908cd6ed66789fa700190604..fe91cbde8da8cec8cb927dac551c5e83bc968aeb 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -41,131 +41,32 @@ import org.slf4j.Logger;
 import it.unimi.dsi.fastutil.longs.Long2IntLinkedOpenHashMap; // Paper
 public abstract class DistanceManager {
 
+    // Paper start - rewrite chunk system
+    public io.papermc.paper.chunk.system.scheduling.ChunkHolderManager getChunkHolderManager() {
+        return this.chunkMap.level.chunkTaskScheduler.chunkHolderManager;
+    }
+    // Paper end - rewrite chunk system
+
     static final Logger LOGGER = LogUtils.getLogger();
     private static final int ENTITY_TICKING_RANGE = 2;
     static final int PLAYER_TICKET_LEVEL = 33 + ChunkStatus.getDistance(ChunkStatus.FULL) - 2;
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
     private static final int ENTITY_TICKING_LEVEL_THRESHOLD = 32;
     private static final int BLOCK_TICKING_LEVEL_THRESHOLD = 33;
-    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap();
-    public final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
-    //private final DistanceManager.ChunkTicketTracker ticketTracker = new DistanceManager.ChunkTicketTracker(); // Paper - replace ticket level propagator
+    // Paper - rewrite chunk system
     public static final int MOB_SPAWN_RANGE = 8; // private final ChunkMapDistance.b f = new ChunkMapDistance.b(8); // Paper - no longer used
-    //private final TickingTracker tickingTicketsTracker = new TickingTracker(); // Paper - no longer used
-    //private final DistanceManager.PlayerTicketTracker playerTicketManager = new DistanceManager.PlayerTicketTracker(33); // Paper - no longer used
-    // Paper start use a queue, but still keep unique requirement
-    public final java.util.Queue<ChunkHolder> pendingChunkUpdates = new java.util.ArrayDeque<ChunkHolder>() {
-        @Override
-        public boolean add(ChunkHolder o) {
-            if (o.isUpdateQueued) return true;
-            o.isUpdateQueued = true;
-            return super.add(o);
-        }
-    };
-    // Paper end
-    final ChunkTaskPriorityQueueSorter ticketThrottler;
-    final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> ticketThrottlerInput;
-    final ProcessorHandle<ChunkTaskPriorityQueueSorter.Release> ticketThrottlerReleaser;
-    final LongSet ticketsToRelease = new LongOpenHashSet();
-    final Executor mainThreadExecutor;
-    private long ticketTickCounter;
-    private int simulationDistance = 10;
+    // Paper - rewrite chunk system
     private final ChunkMap chunkMap; // Paper
 
     protected DistanceManager(Executor workerExecutor, Executor mainThreadExecutor, ChunkMap chunkMap) {
-        Objects.requireNonNull(mainThreadExecutor);
-        ProcessorHandle<Runnable> mailbox = ProcessorHandle.of("player ticket throttler", mainThreadExecutor::execute);
-        ChunkTaskPriorityQueueSorter chunktaskqueuesorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(mailbox), workerExecutor, 4);
-
-        this.ticketThrottler = chunktaskqueuesorter;
-        this.ticketThrottlerInput = chunktaskqueuesorter.getProcessor(mailbox, true);
-        this.ticketThrottlerReleaser = chunktaskqueuesorter.getReleaseProcessor(mailbox);
-        this.mainThreadExecutor = mainThreadExecutor;
+        // Paper - rewrite chunk system
         this.chunkMap = chunkMap; // Paper
     }
 
-    // Paper start - replace ticket level propagator
-    protected final Long2IntLinkedOpenHashMap ticketLevelUpdates = new Long2IntLinkedOpenHashMap() {
-        @Override
-        protected void rehash(int newN) {
-            // no downsizing allowed
-            if (newN < this.n) {
-                return;
-            }
-            super.rehash(newN);
-        }
-    };
-    protected final io.papermc.paper.util.misc.Delayed8WayDistancePropagator2D ticketLevelPropagator = new io.papermc.paper.util.misc.Delayed8WayDistancePropagator2D(
-            (long coordinate, byte oldLevel, byte newLevel) -> {
-                DistanceManager.this.ticketLevelUpdates.putAndMoveToLast(coordinate, convertBetweenTicketLevels(newLevel));
-            }
-    );
-    // function for converting between ticket levels and propagator levels and vice versa
-    // the problem is the ticket level propagator will propagate from a set source down to zero, whereas mojang expects
-    // levels to propagate from a set value up to a maximum value. so we need to convert the levels we put into the propagator
-    // and the levels we get out of the propagator
-
-    // this maps so that GOLDEN_TICKET + 1 will be 0 in the propagator, GOLDEN_TICKET will be 1, and so on
-    // we need GOLDEN_TICKET+1 as 0 because anything >= GOLDEN_TICKET+1 should be unloaded
-    public static int convertBetweenTicketLevels(final int level) {
-        return ChunkMap.MAX_CHUNK_DISTANCE - level + 1;
-    }
-
-    protected final int getPropagatedTicketLevel(final long coordinate) {
-        return convertBetweenTicketLevels(this.ticketLevelPropagator.getLevel(coordinate));
-    }
-
-    protected final void updateTicketLevel(final long coordinate, final int ticketLevel) {
-        if (ticketLevel > ChunkMap.MAX_CHUNK_DISTANCE) {
-            this.ticketLevelPropagator.removeSource(coordinate);
-        } else {
-            this.ticketLevelPropagator.setSource(coordinate, convertBetweenTicketLevels(ticketLevel));
-        }
-    }
-    // Paper end - replace ticket level propagator
+    // Paper - rewrite chunk system
 
     protected void purgeStaleTickets() {
-        ++this.ticketTickCounter;
-        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
-        // Paper start - use optimised removeIf
-        long[] currChunk = new long[1];
-        long ticketCounter = DistanceManager.this.ticketTickCounter;
-        java.util.function.Predicate<Ticket<?>> removeIf = (ticket) -> {
-            final boolean ret = ticket.timedOut(ticketCounter);
-            if (ret) {
-                //this.tickingTicketsTracker.removeTicket(currChunk[0], ticket); // Paper - no longer used
-            }
-            return ret;
-        };
-        // Paper end - use optimised removeIf
-
-        while (objectiterator.hasNext()) {
-            Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
-            // Paper start - use optimised removeIf
-            Iterator<Ticket<?>> iterator = null;
-            currChunk[0] = entry.getLongKey();
-            boolean flag = entry.getValue().removeIf(removeIf);
-
-            while (false && iterator.hasNext()) {
-                // Paper end - use optimised removeIf
-                Ticket<?> ticket = (Ticket) iterator.next();
-
-                if (ticket.timedOut(this.ticketTickCounter)) {
-                    iterator.remove();
-                    flag = true;
-                    //this.tickingTicketsTracker.removeTicket(entry.getLongKey(), ticket); // Paper - no longer used
-                }
-            }
-
-            if (flag) {
-                this.updateTicketLevel(entry.getLongKey(), getTicketLevelAt(entry.getValue())); // Paper - replace ticket level propagator
-            }
-
-            if (((SortedArraySet) entry.getValue()).isEmpty()) {
-                objectiterator.remove();
-            }
-        }
-
+        this.getChunkHolderManager().tick(); // Paper - rewrite chunk system
     }
 
     private static int getTicketLevelAt(SortedArraySet<Ticket<?>> tickets) {
@@ -181,163 +82,28 @@ public abstract class DistanceManager {
     @Nullable
     protected abstract ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int k);
 
-    protected long ticketLevelUpdateCount; // Paper - replace ticket level propagator
+    // Paper - rewrite chunk system
     public boolean runAllUpdates(ChunkMap chunkStorage) {
-        //this.f.a(); // Paper - no longer used
-        //this.tickingTicketsTracker.runAllUpdates(); // Paper - no longer used
-        org.spigotmc.AsyncCatcher.catchOp("DistanceManagerTick"); // Paper
-        // this.playerTicketManager.runAllUpdates(); // Paper - no longer used
-        boolean flag = this.ticketLevelPropagator.propagateUpdates(); // Paper - replace ticket level propagator
-
-        if (flag) {
-            ;
-        }
-
-        // Paper start - replace level propagator
-        ticket_update_loop:
-        while (!this.ticketLevelUpdates.isEmpty()) {
-            flag = true;
-
-            boolean oldPolling = this.pollingPendingChunkUpdates;
-            this.pollingPendingChunkUpdates = true;
-            try {
-                for (java.util.Iterator<Long2IntMap.Entry> iterator = this.ticketLevelUpdates.long2IntEntrySet().fastIterator(); iterator.hasNext();) {
-                    Long2IntMap.Entry entry = iterator.next();
-                    long key = entry.getLongKey();
-                    int newLevel = entry.getIntValue();
-                    ChunkHolder chunk = this.getChunk(key);
-
-                    if (chunk == null && newLevel > ChunkMap.MAX_CHUNK_DISTANCE) {
-                        // not loaded and it shouldn't be loaded!
-                        continue;
-                    }
-
-                    int currentLevel = chunk == null ? ChunkMap.MAX_CHUNK_DISTANCE + 1 : chunk.getTicketLevel();
-
-                    if (currentLevel == newLevel) {
-                        // nothing to do
-                        continue;
-                    }
-
-                    this.updateChunkScheduling(key, newLevel, chunk, currentLevel);
-                }
-
-                long recursiveCheck = ++this.ticketLevelUpdateCount;
-                while (!this.ticketLevelUpdates.isEmpty()) {
-                    long key = this.ticketLevelUpdates.firstLongKey();
-                    int newLevel = this.ticketLevelUpdates.removeFirstInt();
-                    ChunkHolder chunk = this.getChunk(key);
-
-                    if (chunk == null) {
-                        if (newLevel <= ChunkMap.MAX_CHUNK_DISTANCE) {
-                            throw new IllegalStateException("Expected chunk holder to be created");
-                        }
-                        // not loaded and it shouldn't be loaded!
-                        continue;
-                    }
-
-                    int currentLevel = chunk.oldTicketLevel;
-
-                    if (currentLevel == newLevel) {
-                        // nothing to do
-                        continue;
-                    }
-
-                    chunk.updateFutures(chunkStorage, this.mainThreadExecutor);
-                    if (recursiveCheck != this.ticketLevelUpdateCount) {
-                        // back to the start, we must create player chunks and update the ticket level fields before
-                        // processing the actual level updates
-                        continue ticket_update_loop;
-                    }
-                }
-
-                for (;;) {
-                    if (recursiveCheck != this.ticketLevelUpdateCount) {
-                        continue ticket_update_loop;
-                    }
-                    ChunkHolder pendingUpdate = this.pendingChunkUpdates.poll();
-                    if (pendingUpdate == null) {
-                        break;
-                    }
-
-                    pendingUpdate.updateFutures(chunkStorage, this.mainThreadExecutor);
-                }
-            } finally {
-                this.pollingPendingChunkUpdates = oldPolling;
-            }
-        }
-
-        return flag;
-        // Paper end - replace level propagator
+        return this.getChunkHolderManager().processTicketUpdates(); // Paper - rewrite chunk system
     }
-    boolean pollingPendingChunkUpdates = false; // Paper - Chunk priority
+    // Paper - rewrite chunk system
 
     boolean addTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
         org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::addTicket"); // Paper
-        SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
-        int j = DistanceManager.getTicketLevelAt(arraysetsorted);
-        Ticket<?> ticket1 = (Ticket) arraysetsorted.addOrGet(ticket);
-
-        ticket1.setCreatedTick(this.ticketTickCounter);
-        if (ticket.getTicketLevel() < j) {
-            this.updateTicketLevel(i, ticket.getTicketLevel()); // Paper - replace ticket level propagator
-        }
-
-        return ticket == ticket1; // CraftBukkit
+        return this.getChunkHolderManager().addTicketAtLevel((TicketType)ticket.getType(), i, ticket.getTicketLevel(), ticket.key); // Paper - rewrite chunk system
     }
 
     boolean removeTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
         org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::removeTicket"); // Paper
-        SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
-        int oldLevel = getTicketLevelAt(arraysetsorted); // Paper
-
-        boolean removed = false; // CraftBukkit
-        if (arraysetsorted.remove(ticket)) {
-            removed = true; // CraftBukkit
-            // Paper start - delay chunk unloads for player tickets
-            long delayChunkUnloadsBy = chunkMap.level.paperConfig().chunks.delayChunkUnloadsBy.ticks();
-            if (ticket.getType() == TicketType.PLAYER && delayChunkUnloadsBy > 0) {
-                boolean hasPlayer = false;
-                for (Ticket<?> ticket1 : arraysetsorted) {
-                    if (ticket1.getType() == TicketType.PLAYER) {
-                        hasPlayer = true;
-                        break;
-                    }
-                }
-                ChunkHolder playerChunk = chunkMap.getUpdatingChunkIfPresent(i);
-                if (!hasPlayer && playerChunk != null && playerChunk.isFullChunkReady()) {
-                    Ticket<Long> delayUnload = new Ticket<Long>(TicketType.DELAY_UNLOAD, 33, i);
-                    delayUnload.delayUnloadBy = delayChunkUnloadsBy;
-                    delayUnload.setCreatedTick(this.ticketTickCounter);
-                    arraysetsorted.remove(delayUnload);
-                    // refresh ticket
-                    arraysetsorted.add(delayUnload);
-                }
-            }
-            // Paper end
-        }
-
-        if (arraysetsorted.isEmpty()) {
-            this.tickets.remove(i);
-        }
-
-        // Paper start - Chunk priority
-        int newLevel = getTicketLevelAt(arraysetsorted);
-        if (newLevel > oldLevel) {
-            this.updateTicketLevel(i, newLevel); // Paper // Paper - replace ticket level propagator
-        }
-        // Paper end
-        return removed; // CraftBukkit
+        return this.getChunkHolderManager().removeTicketAtLevel((TicketType)ticket.getType(), i, ticket.getTicketLevel(), ticket.key); // Paper - rewrite chunk system
     }
 
     public <T> void addTicket(TicketType<T> type, ChunkPos pos, int level, T argument) {
-        this.addTicket(pos.toLong(), new Ticket<>(type, level, argument));
+        this.getChunkHolderManager().addTicketAtLevel(type, pos, level, argument); // Paper - rewrite chunk system
     }
 
     public <T> void removeTicket(TicketType<T> type, ChunkPos pos, int level, T argument) {
-        Ticket<T> ticket = new Ticket<>(type, level, argument);
-
-        this.removeTicket(pos.toLong(), ticket);
+        this.getChunkHolderManager().removeTicketAtLevel(type, pos, level, argument); // Paper - rewrite chunk system
     }
 
     public <T> void addRegionTicket(TicketType<T> type, ChunkPos pos, int radius, T argument) {
@@ -346,13 +112,7 @@ public abstract class DistanceManager {
     }
 
     public <T> boolean addRegionTicketAtDistance(TicketType<T> tickettype, ChunkPos chunkcoordintpair, int i, T t0) {
-        // CraftBukkit end
-        Ticket<T> ticket = new Ticket<>(tickettype, 33 - i, t0);
-        long j = chunkcoordintpair.toLong();
-
-        boolean added = this.addTicket(j, ticket); // CraftBukkit
-        //this.tickingTicketsTracker.addTicket(j, ticket); // Paper - no longer used
-        return added; // CraftBukkit
+        return this.getChunkHolderManager().addTicketAtLevel(tickettype, chunkcoordintpair, 33 - i, t0); // Paper - rewrite chunk system
     }
 
     public <T> void removeRegionTicket(TicketType<T> type, ChunkPos pos, int radius, T argument) {
@@ -361,129 +121,13 @@ public abstract class DistanceManager {
     }
 
     public <T> boolean removeRegionTicketAtDistance(TicketType<T> tickettype, ChunkPos chunkcoordintpair, int i, T t0) {
-        // CraftBukkit end
-        Ticket<T> ticket = new Ticket<>(tickettype, 33 - i, t0);
-        long j = chunkcoordintpair.toLong();
-
-        boolean removed = this.removeTicket(j, ticket); // CraftBukkit
-        //this.tickingTicketsTracker.removeTicket(j, ticket); // Paper - no longer used
-        return removed; // CraftBukkit
-    }
-
-    private SortedArraySet<Ticket<?>> getTickets(long position) {
-        return (SortedArraySet) this.tickets.computeIfAbsent(position, (j) -> {
-            return SortedArraySet.create(4);
-        });
-    }
-
-    // Paper start - Chunk priority
-    public static final int PRIORITY_TICKET_LEVEL = ChunkMap.MAX_CHUNK_DISTANCE;
-    public static final int URGENT_PRIORITY = 29;
-    public boolean delayDistanceManagerTick = false;
-    public boolean markUrgent(ChunkPos coords) {
-        return addPriorityTicket(coords, TicketType.URGENT, URGENT_PRIORITY);
-    }
-    public boolean markHighPriority(ChunkPos coords, int priority) {
-        priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
-        return addPriorityTicket(coords, TicketType.PRIORITY, priority);
-    }
-
-    public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
-        delayDistanceManagerTick = true;
-        priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
-        int finalPriority = priority;
-        net.minecraft.server.MCUtil.getSpiralOutChunks(center.getWorldPosition(), radius).forEach(coords -> {
-            addPriorityTicket(coords, TicketType.PRIORITY, finalPriority);
-        });
-        delayDistanceManagerTick = false;
-        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
-    }
-
-    public void clearAreaPriorityTickets(ChunkPos center, int radius) {
-        delayDistanceManagerTick = true;
-        net.minecraft.server.MCUtil.getSpiralOutChunks(center.getWorldPosition(), radius).forEach(coords -> {
-            this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
-        });
-        delayDistanceManagerTick = false;
-        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
-    }
-
-    private boolean addPriorityTicket(ChunkPos coords, TicketType<ChunkPos> ticketType, int priority) {
-        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::addPriorityTicket");
-        long pair = coords.toLong();
-        ChunkHolder chunk = chunkMap.getUpdatingChunkIfPresent(pair);
-        if ((chunk != null && chunk.isFullChunkReady())) {
-            return false;
-        }
-
-        boolean success;
-        if (!(success = updatePriorityTicket(coords, ticketType, priority))) {
-            Ticket<ChunkPos> ticket = new Ticket<ChunkPos>(ticketType, PRIORITY_TICKET_LEVEL, coords);
-            ticket.priority = priority;
-            success = this.addTicket(pair, ticket);
-        } else {
-            if (chunk == null) {
-                chunk = chunkMap.getUpdatingChunkIfPresent(pair);
-            }
-            chunkMap.queueHolderUpdate(chunk);
-        }
-
-        //chunkMap.world.getWorld().spawnParticle(priority <= 15 ? org.bukkit.Particle.EXPLOSION_HUGE : org.bukkit.Particle.EXPLOSION_NORMAL, chunkMap.world.getWorld().getPlayers(), null, coords.x << 4, 70, coords.z << 4, 2, 0, 0, 0, 1, null, true);
-
-        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
-
-        return success;
+        return this.getChunkHolderManager().removeTicketAtLevel(tickettype, chunkcoordintpair, 33 - i, t0); // Paper - rewrite chunk system
     }
 
-    private boolean updatePriorityTicket(ChunkPos coords, TicketType<ChunkPos> type, int priority) {
-        SortedArraySet<Ticket<?>> tickets = this.tickets.get(coords.toLong());
-        if (tickets == null) {
-            return false;
-        }
-        for (Ticket<?> ticket : tickets) {
-            if (ticket.getType() == type) {
-                // We only support increasing, not decreasing, too complicated
-                ticket.setCreatedTick(this.ticketTickCounter);
-                ticket.priority = Math.max(ticket.priority, priority);
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    public int getChunkPriority(ChunkPos coords) {
-        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::getChunkPriority");
-        SortedArraySet<Ticket<?>> tickets = this.tickets.get(coords.toLong());
-        if (tickets == null) {
-            return 0;
-        }
-        for (Ticket<?> ticket : tickets) {
-            if (ticket.getType() == TicketType.URGENT) {
-                return URGENT_PRIORITY;
-            }
-        }
-        for (Ticket<?> ticket : tickets) {
-            if (ticket.getType() == TicketType.PRIORITY && ticket.priority > 0) {
-                return ticket.priority;
-            }
-        }
-        return 0;
-    }
-
-    public void clearPriorityTickets(ChunkPos coords) {
-        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::clearPriority");
-        this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
-    }
-
-    public void clearUrgent(ChunkPos coords) {
-        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::clearUrgent");
-        this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.URGENT, PRIORITY_TICKET_LEVEL, coords));
-    }
-    // Paper end
+    // Paper - rewrite chunk system
 
     protected void updateChunkForced(ChunkPos pos, boolean forced) {
-        Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, 31, pos);
+        Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, 31, pos, 0L); // Paper - rewrite chunk system
         long i = pos.toLong();
 
         if (forced) {
@@ -497,36 +141,15 @@ public abstract class DistanceManager {
     }
 
     public void addPlayer(SectionPos pos, ServerPlayer player) {
-        ChunkPos chunkcoordintpair = pos.chunk();
-        long i = chunkcoordintpair.toLong();
-
-        ((ObjectSet) this.playersPerChunk.computeIfAbsent(i, (j) -> {
-            return new ObjectOpenHashSet();
-        })).add(player);
-        //this.f.update(i, 0, true); // Paper - no longer used
-        //this.playerTicketManager.update(i, 0, true); // Paper - no longer used
-        //this.tickingTicketsTracker.addTicket(TicketType.PLAYER, chunkcoordintpair, this.getPlayerTicketLevel(), chunkcoordintpair); // Paper - no longer used
+        // Paper - rewrite chunk system
     }
 
     public void removePlayer(SectionPos pos, ServerPlayer player) {
-        ChunkPos chunkcoordintpair = pos.chunk();
-        long i = chunkcoordintpair.toLong();
-        ObjectSet<ServerPlayer> objectset = (ObjectSet) this.playersPerChunk.get(i);
-        if (objectset == null) return; // CraftBukkit - SPIGOT-6208
-
-        if (objectset != null) objectset.remove(player); // Paper - some state corruption happens here, don't crash, clean up gracefully.
-        if (objectset == null || objectset.isEmpty()) { // Paper
-            this.playersPerChunk.remove(i);
-            //this.f.update(i, Integer.MAX_VALUE, false); // Paper - no longer used
-            //this.playerTicketManager.update(i, Integer.MAX_VALUE, false); // Paper - no longer used
-            //this.tickingTicketsTracker.removeTicket(TicketType.PLAYER, chunkcoordintpair, this.getPlayerTicketLevel(), chunkcoordintpair); // Paper - no longer used
-        }
+        // Paper - rewrite chunk system
 
     }
 
-    private int getPlayerTicketLevel() {
-        return Math.max(0, 31 - this.simulationDistance);
-    }
+    // Paper - rewrite chunk system
 
     public boolean inEntityTickingRange(long chunkPos) {
         // Paper start - replace player chunk loader system
@@ -543,9 +166,7 @@ public abstract class DistanceManager {
     }
 
     protected String getTicketDebugString(long pos) {
-        SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) this.tickets.get(pos);
-
-        return arraysetsorted != null && !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.first()).toString() : "no_ticket";
+        return this.getChunkHolderManager().getTicketDebugString(pos); // Paper - rewrite chunk system
     }
 
     protected void updatePlayerTickets(int viewDistance) {
@@ -577,97 +198,24 @@ public abstract class DistanceManager {
     }
 
     public String getDebugStatus() {
-        return this.ticketThrottler.getDebugStatus();
+        return "No DistanceManager stats available"; // Paper - rewrite chunk system
     }
 
-    private void dumpTickets(String path) {
-        try {
-            FileOutputStream fileoutputstream = new FileOutputStream(new File(path));
-
-            try {
-                ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().iterator();
-
-                while (objectiterator.hasNext()) {
-                    Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
-                    ChunkPos chunkcoordintpair = new ChunkPos(entry.getLongKey());
-                    Iterator iterator = ((SortedArraySet) entry.getValue()).iterator();
-
-                    while (iterator.hasNext()) {
-                        Ticket<?> ticket = (Ticket) iterator.next();
-
-                        fileoutputstream.write((chunkcoordintpair.x + "\t" + chunkcoordintpair.z + "\t" + ticket.getType() + "\t" + ticket.getTicketLevel() + "\t\n").getBytes(StandardCharsets.UTF_8));
-                    }
-                }
-            } catch (Throwable throwable) {
-                try {
-                    fileoutputstream.close();
-                } catch (Throwable throwable1) {
-                    throwable.addSuppressed(throwable1);
-                }
-
-                throw throwable;
-            }
-
-            fileoutputstream.close();
-        } catch (IOException ioexception) {
-            DistanceManager.LOGGER.error("Failed to dump tickets to {}", path, ioexception);
-        }
-
-    }
+    // Paper - rewrite chunk system
 
     // Paper - replace player chunk loader
 
     public void removeTicketsOnClosing() {
-        ImmutableSet<TicketType<?>> immutableset = ImmutableSet.of(TicketType.UNKNOWN, TicketType.POST_TELEPORT, TicketType.LIGHT, TicketType.FUTURE_AWAIT, TicketType.ASYNC_LOAD, TicketType.REQUIRED_LOAD, TicketType.CHUNK_RELIGHT, ca.spottedleaf.starlight.common.light.StarLightInterface.CHUNK_WORK_TICKET); // Paper - add additional tickets to preserve
-        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
-
-        while (objectiterator.hasNext()) {
-            Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
-            Iterator<Ticket<?>> iterator = ((SortedArraySet) entry.getValue()).iterator();
-            boolean flag = false;
-
-            while (iterator.hasNext()) {
-                Ticket<?> ticket = (Ticket) iterator.next();
-
-                if (!immutableset.contains(ticket.getType())) {
-                    iterator.remove();
-                    flag = true;
-                    // this.tickingTicketsTracker.removeTicket(entry.getLongKey(), ticket); // Paper - no longer used
-                }
-            }
-
-            if (flag) {
-                this.updateTicketLevel(entry.getLongKey(), DistanceManager.getTicketLevelAt((SortedArraySet) entry.getValue())); // Paper - replace ticket level propagator
-            }
-
-            if (((SortedArraySet) entry.getValue()).isEmpty()) {
-                objectiterator.remove();
-            }
-        }
-
+        // Paper - rewrite chunk system - this stupid hack ain't needed anymore
     }
 
     public boolean hasTickets() {
-        return !this.tickets.isEmpty();
+        return this.getChunkHolderManager().hasTickets(); // Paper - rewrite chunk system
     }
 
     // CraftBukkit start
     public <T> void removeAllTicketsFor(TicketType<T> ticketType, int ticketLevel, T ticketIdentifier) {
-        Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
-
-        for (java.util.Iterator<Entry<SortedArraySet<Ticket<?>>>> iterator = this.tickets.long2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            Entry<SortedArraySet<Ticket<?>>> entry = iterator.next();
-            SortedArraySet<Ticket<?>> tickets = entry.getValue();
-            if (tickets.remove(target)) {
-                // copied from removeTicket
-                this.updateTicketLevel(entry.getLongKey(), getTicketLevelAt(tickets)); // Paper - replace ticket level propagator
-
-                // can't use entry after it's removed
-                if (tickets.isEmpty()) {
-                    iterator.remove();
-                }
-            }
-        }
+        this.getChunkHolderManager().removeAllTicketsFor(ticketType, ticketLevel, ticketIdentifier); // Paper - rewrite chunk system
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index efcb80efc69a1e5ffc81b579bf535fd94e8144d7..1ebdac637f8b7aa40895ba8e4cc4c28810c5d90c 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -367,7 +367,7 @@ public class ServerChunkCache extends ChunkSource {
     public LevelChunk getChunkAtIfLoadedImmediately(int x, int z) {
         long k = ChunkPos.asLong(x, z);
 
-        if (Thread.currentThread() == this.mainThread) {
+        if (io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -410,37 +410,14 @@ public class ServerChunkCache extends ChunkSource {
 
         return ret;
     }
-
-    public boolean markUrgent(ChunkPos coords) {
-        return this.distanceManager.markUrgent(coords);
-    }
-
-    public boolean markHighPriority(ChunkPos coords, int priority) {
-        return this.distanceManager.markHighPriority(coords, priority);
-    }
-
-    public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
-        this.distanceManager.markAreaHighPriority(center, priority, radius);
-    }
-
-    public void clearAreaPriorityTickets(ChunkPos center, int radius) {
-        this.distanceManager.clearAreaPriorityTickets(center, radius);
-    }
-
-    public void clearPriorityTickets(ChunkPos coords) {
-        this.distanceManager.clearPriorityTickets(coords);
-    }
-
-    public void clearUrgent(ChunkPos coords) {
-        this.distanceManager.clearUrgent(coords);
-    }
+    // Paper - rewrite chunk system
     // Paper end - async chunk io
 
     @Nullable
     @Override
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
-        if (Thread.currentThread() != this.mainThread) {
+        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunk(x, z, leastStatus, create);
             }, this.mainThreadProcessor).join();
@@ -458,14 +435,7 @@ public class ServerChunkCache extends ChunkSource {
 
             ChunkAccess ichunkaccess;
 
-            for (int l = 0; l < 4; ++l) {
-                if (k == this.lastChunkPos[l] && leastStatus == this.lastChunkStatus[l]) {
-                    ichunkaccess = this.lastChunk[l];
-                    if (ichunkaccess != null) { // CraftBukkit - the chunk can become accessible in the meantime TODO for non-null chunks it might also make sense to check that the chunk's state hasn't changed in the meantime
-                        return ichunkaccess;
-                    }
-                }
-            }
+            // Paper - rewrite chunk system - there are no correct callbacks to remove items from cache in the new chunk system
 
             gameprofilerfiller.incrementCounter("getChunkCacheMiss");
             CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkFutureMainThread(x, z, leastStatus, create, true); // Paper
@@ -474,18 +444,15 @@ public class ServerChunkCache extends ChunkSource {
             Objects.requireNonNull(completablefuture);
             if (!completablefuture.isDone()) { // Paper
                 // Paper start - async chunk io/loading
-                ChunkPos pair = new ChunkPos(x1, z1); // Paper - Chunk priority
-                this.distanceManager.markUrgent(pair); // Paper - Chunk priority
-                this.level.asyncChunkTaskManager.raisePriority(x1, z1, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
-                com.destroystokyo.paper.io.chunk.ChunkTaskManager.pushChunkWait(this.level, x1, z1);
+                // Paper - rewrite chunk system
+                io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.pushChunkWait(this.level, x1, z1); // Paper - rewrite chunk system
                 // Paper end
                 com.destroystokyo.paper.io.SyncLoadFinder.logSyncLoad(this.level, x1, z1); // Paper - sync load info
                 this.level.timings.syncChunkLoad.startTiming(); // Paper
             chunkproviderserver_b.managedBlock(completablefuture::isDone);
-                com.destroystokyo.paper.io.chunk.ChunkTaskManager.popChunkWait(); // Paper - async chunk debug
+                io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.popChunkWait(); // Paper - async chunk debug  // Paper - rewrite chunk system
                 this.level.timings.syncChunkLoad.stopTiming(); // Paper
-                this.distanceManager.clearPriorityTickets(pair); // Paper - Chunk priority
-                this.distanceManager.clearUrgent(pair); // Paper - Chunk priority
+                // Paper - rewrite chunk system
             } // Paper
             ichunkaccess = (ChunkAccess) ((Either) completablefuture.join()).map((ichunkaccess1) -> {
                 return ichunkaccess1;
@@ -504,7 +471,7 @@ public class ServerChunkCache extends ChunkSource {
     @Nullable
     @Override
     public LevelChunk getChunkNow(int chunkX, int chunkZ) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             return null;
         } else {
             return this.getChunkAtIfLoadedMainThread(chunkX, chunkZ); // Paper - optimise for loaded chunks
@@ -518,7 +485,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFuture(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) {
-        boolean flag1 = Thread.currentThread() == this.mainThread;
+        boolean flag1 = io.papermc.paper.util.TickThread.isTickThread(); // Paper - rewrite chunk system
         CompletableFuture completablefuture;
 
         if (flag1) {
@@ -538,74 +505,55 @@ public class ServerChunkCache extends ChunkSource {
         return completablefuture;
     }
 
-    private long syncLoadCounter; // Paper - prevent plugin unloads from removing our ticket
+    // Paper - rewrite chunk system
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFutureMainThread(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) {
         // Paper start - add isUrgent - old sig left in place for dirty nms plugins
         return getChunkFutureMainThread(chunkX, chunkZ, leastStatus, create, false);
     }
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFutureMainThread(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create, boolean isUrgent) {
-        // Paper end
-        ChunkPos chunkcoordintpair = new ChunkPos(chunkX, chunkZ);
-        long k = chunkcoordintpair.toLong();
-        int l = 33 + ChunkStatus.getDistance(leastStatus);
-        ChunkHolder playerchunk = this.getVisibleChunkIfPresent(k);
+        // Paper start - rewrite chunk system
+        io.papermc.paper.util.TickThread.ensureTickThread(this.level, chunkX, chunkZ, "Scheduling chunk load off-main");
+        int minLevel = 33 + ChunkStatus.getDistance(leastStatus);
+        io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder = this.level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(chunkX, chunkZ);
 
-        // CraftBukkit start - don't add new ticket for currently unloading chunk
-        boolean currentlyUnloading = false;
-        if (playerchunk != null) {
-            ChunkHolder.FullChunkStatus oldChunkState = ChunkHolder.getFullChunkStatus(playerchunk.oldTicketLevel);
-            ChunkHolder.FullChunkStatus currentChunkState = ChunkHolder.getFullChunkStatus(playerchunk.getTicketLevel());
-            currentlyUnloading = (oldChunkState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && !currentChunkState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER));
+        boolean needsFullScheduling = leastStatus == ChunkStatus.FULL && (chunkHolder == null || !chunkHolder.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.BORDER));
+
+        if ((chunkHolder == null || chunkHolder.getTicketLevel() > minLevel || needsFullScheduling) && !create) {
+            return ChunkHolder.UNLOADED_CHUNK_FUTURE;
         }
-        final Long identifier; // Paper - prevent plugin unloads from removing our ticket
-        if (create && !currentlyUnloading) {
-            // CraftBukkit end
-            this.distanceManager.addTicket(TicketType.UNKNOWN, chunkcoordintpair, l, chunkcoordintpair);
-            identifier = Long.valueOf(this.syncLoadCounter++); // Paper - prevent plugin unloads from removing our ticket
-            this.distanceManager.addTicket(TicketType.REQUIRED_LOAD, chunkcoordintpair, l, identifier); // Paper - prevent plugin unloads from removing our ticket
-            if (isUrgent) this.distanceManager.markUrgent(chunkcoordintpair); // Paper - Chunk priority
-            if (this.chunkAbsent(playerchunk, l)) {
-                ProfilerFiller gameprofilerfiller = this.level.getProfiler();
-
-                gameprofilerfiller.push("chunkLoad");
-                distanceManager.delayDistanceManagerTick = false; // Paper - Chunk priority - ensure this is never false
-                this.runDistanceManagerUpdates();
-                playerchunk = this.getVisibleChunkIfPresent(k);
-                gameprofilerfiller.pop();
-                if (this.chunkAbsent(playerchunk, l)) {
-                    this.distanceManager.removeTicket(TicketType.REQUIRED_LOAD, chunkcoordintpair, l, identifier); // Paper
-                    throw (IllegalStateException) Util.pauseInIde(new IllegalStateException("No chunk holder after ticket has been added"));
+
+        io.papermc.paper.chunk.system.scheduling.NewChunkHolder.ChunkCompletion chunkCompletion = chunkHolder == null ? null : chunkHolder.getLastChunkCompletion();
+        if (needsFullScheduling || chunkCompletion == null || !chunkCompletion.genStatus().isOrAfter(leastStatus)) {
+            // schedule
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> ret = new CompletableFuture<>();
+            Consumer<ChunkAccess> complete = (ChunkAccess chunk) -> {
+                if (chunk == null) {
+                    ret.complete(Either.right(ChunkHolder.ChunkLoadingFailure.UNLOADED));
+                } else {
+                    ret.complete(Either.left(chunk));
                 }
-            }
+            };
 
-        } else { identifier = null; } // Paper - prevent plugin unloads from removing our ticket
-        // Paper start - Chunk priority
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.chunkAbsent(playerchunk, l) ? ChunkHolder.UNLOADED_CHUNK_FUTURE : playerchunk.getOrScheduleFuture(leastStatus, this.chunkMap);
-        // Paper start - prevent plugin unloads from removing our ticket
-        if (create && !currentlyUnloading) {
-            future.thenAcceptAsync((either) -> {
-                ServerChunkCache.this.distanceManager.removeTicket(TicketType.REQUIRED_LOAD, chunkcoordintpair, l, identifier);
-            }, ServerChunkCache.this.mainThreadProcessor);
-        }
-        // Paper end - prevent plugin unloads from removing our ticket
-        if (isUrgent) {
-            future.thenAccept(either -> this.distanceManager.clearUrgent(chunkcoordintpair));
+            this.level.chunkTaskScheduler.scheduleChunkLoad(
+                chunkX, chunkZ, leastStatus, true,
+                isUrgent ? ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.BLOCKING : ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL,
+                complete
+            );
+
+            return ret;
+        } else {
+            // can return now
+            return CompletableFuture.completedFuture(Either.left(chunkCompletion.chunk()));
         }
-        return future;
-        // Paper end
+        // Paper end - rewrite chunk system
     }
 
-    private boolean chunkAbsent(@Nullable ChunkHolder holder, int maxLevel) {
-        return holder == null || holder.oldTicketLevel > maxLevel; // CraftBukkit using oldTicketLevel for isLoaded checks
-    }
+    // Paper - rewrite chunk system
 
     @Override
     public boolean hasChunk(int x, int z) {
-        ChunkHolder playerchunk = this.getVisibleChunkIfPresent((new ChunkPos(x, z)).toLong());
-        int k = 33 + ChunkStatus.getDistance(ChunkStatus.FULL);
-
-        return !this.chunkAbsent(playerchunk, k);
+        return this.getChunkAtIfLoadedImmediately(x, z) != null; // Paper - rewrite chunk system
     }
 
     @Override
@@ -616,22 +564,13 @@ public class ServerChunkCache extends ChunkSource {
         if (playerchunk == null) {
             return null;
         } else {
-            int l = ServerChunkCache.CHUNK_STATUSES.size() - 1;
-
-            while (true) {
-                ChunkStatus chunkstatus = (ChunkStatus) ServerChunkCache.CHUNK_STATUSES.get(l);
-                Optional<ChunkAccess> optional = ((Either) playerchunk.getFutureIfPresentUnchecked(chunkstatus).getNow(ChunkHolder.UNLOADED_CHUNK)).left();
-
-                if (optional.isPresent()) {
-                    return (BlockGetter) optional.get();
-                }
-
-                if (chunkstatus == ChunkStatus.LIGHT.getParent()) {
-                    return null;
-                }
-
-                --l;
+            // Paper start - rewrite chunk system
+            ChunkStatus status = playerchunk.getChunkHolderStatus();
+            if (status != null && !status.isOrAfter(ChunkStatus.LIGHT.getParent())) {
+                return null;
             }
+            return playerchunk.getAvailableChunkNow();
+            // Paper end - rewrite chunk system
         }
     }
 
@@ -645,19 +584,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public boolean runDistanceManagerUpdates() {
-        if (distanceManager.delayDistanceManagerTick) return false; // Paper - Chunk priority
-        if (this.chunkMap.unloadingPlayerChunk) { LOGGER.error("Cannot tick distance manager while unloading playerchunks", new Throwable()); throw new IllegalStateException("Cannot tick distance manager while unloading playerchunks"); } // Paper
-        co.aikar.timings.MinecraftTimings.distanceManagerTick.startTiming(); try { // Paper - add timings for distance manager
-        boolean flag = this.distanceManager.runAllUpdates(this.chunkMap);
-        boolean flag1 = this.chunkMap.promoteChunkMap();
-
-        if (!flag && !flag1) {
-            return false;
-        } else {
-            this.clearCache();
-            return true;
-        }
-        } finally { co.aikar.timings.MinecraftTimings.distanceManagerTick.stopTiming(); } // Paper - add timings for distance manager
+        return this.level.chunkTaskScheduler.chunkHolderManager.processTicketUpdates(); // Paper - rewrite chunk system
     }
 
     // Paper start
@@ -695,13 +622,8 @@ public class ServerChunkCache extends ChunkSource {
         this.close(true);
     }
 
-    public void close(boolean save) throws IOException {
-        if (save) {
-            this.save(true);
-        }
-        // CraftBukkit end
-        this.lightEngine.close();
-        this.chunkMap.close();
+    public void close(boolean save) { // Paper - rewrite chunk system
+        this.level.chunkTaskScheduler.chunkHolderManager.close(save, true); // Paper - rewrite chunk system
     }
 
     // CraftBukkit start - modelled on below
@@ -912,7 +834,12 @@ public class ServerChunkCache extends ChunkSource {
         ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos);
 
         if (playerchunk != null) {
-            ((Either) playerchunk.getFullChunkFuture().getNow(ChunkHolder.UNLOADED_LEVEL_CHUNK)).left().ifPresent(chunkConsumer);
+            // Paper start - rewrite chunk system
+            LevelChunk chunk = playerchunk.getFullChunk();
+            if (chunk != null) {
+                chunkConsumer.accept(chunk);
+            }
+            // Paper end - rewrite chunk system
         }
 
     }
@@ -1074,20 +1001,11 @@ public class ServerChunkCache extends ChunkSource {
         @Override
         // CraftBukkit start - process pending Chunk loadCallback() and unloadCallback() after each run task
         public boolean pollTask() {
-        try {
-            boolean execChunkTask = com.destroystokyo.paper.io.chunk.ChunkTaskManager.pollChunkWaitQueue() || ServerChunkCache.this.level.asyncChunkTaskManager.pollNextChunkTask(); // Paper
-            ServerChunkCache.this.chunkMap.playerChunkManager.tickMidTick(); // Paper
+            ServerChunkCache.this.chunkMap.playerChunkManager.tickMidTick();
             if (ServerChunkCache.this.runDistanceManagerUpdates()) {
                 return true;
-            } else {
-                ServerChunkCache.this.lightEngine.tryScheduleUpdate();
-                return super.pollTask() || execChunkTask; // Paper
             }
-        } finally {
-            chunkMap.chunkLoadConversionCallbackExecutor.run(); // Paper - Add chunk load conversion callback executor to prevent deadlock due to recursion in the chunk task queue sorter
-            chunkMap.callbackExecutor.run();
-        }
-        // CraftBukkit end
+            return super.pollTask() | ServerChunkCache.this.level.chunkTaskScheduler.executeMainThreadTask(); // Paper - rewrite chunk system
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 96bb0e56f12437037b598cd7baabf369e5994517..395d23fe32688add753b32b621dd8a38a9fbb553 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -191,7 +191,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     private final MinecraftServer server;
     public final PrimaryLevelData serverLevelData; // CraftBukkit - type
     final EntityTickList entityTickList;
-    public final PersistentEntitySectionManager<Entity> entityManager;
+    //public final PersistentEntitySectionManager<Entity> entityManager; // Paper - rewrite chunk system
     public boolean noSave;
     private final SleepStatus sleepStatus;
     private int emptyTime;
@@ -323,79 +323,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
         }
     }
-
-    // Paper start - Asynchronous IO
-    public final com.destroystokyo.paper.io.PaperFileIOThread.ChunkDataController poiDataController = new com.destroystokyo.paper.io.PaperFileIOThread.ChunkDataController() {
-        @Override
-        public void writeData(int x, int z, net.minecraft.nbt.CompoundTag compound) throws java.io.IOException {
-            ServerLevel.this.getChunkSource().chunkMap.getPoiManager().write(new ChunkPos(x, z), compound);
-        }
-
-        @Override
-        public net.minecraft.nbt.CompoundTag readData(int x, int z) throws java.io.IOException {
-            return ServerLevel.this.getChunkSource().chunkMap.getPoiManager().read(new ChunkPos(x, z));
-        }
-
-        @Override
-        public <T> T computeForRegionFile(int chunkX, int chunkZ, java.util.function.Function<net.minecraft.world.level.chunk.storage.RegionFile, T> function) {
-            synchronized (ServerLevel.this.getChunkSource().chunkMap.getPoiManager()) {
-                net.minecraft.world.level.chunk.storage.RegionFile file;
-
-                try {
-                    file = ServerLevel.this.getChunkSource().chunkMap.getPoiManager().getRegionFile(new ChunkPos(chunkX, chunkZ), false);
-                } catch (java.io.IOException ex) {
-                    throw new RuntimeException(ex);
-                }
-
-                return function.apply(file);
-            }
-        }
-
-        @Override
-        public <T> T computeForRegionFileIfLoaded(int chunkX, int chunkZ, java.util.function.Function<net.minecraft.world.level.chunk.storage.RegionFile, T> function) {
-            synchronized (ServerLevel.this.getChunkSource().chunkMap.getPoiManager()) {
-                net.minecraft.world.level.chunk.storage.RegionFile file = ServerLevel.this.getChunkSource().chunkMap.getPoiManager().getRegionFileIfLoaded(new ChunkPos(chunkX, chunkZ));
-                return function.apply(file);
-            }
-        }
-    };
-
-    public final com.destroystokyo.paper.io.PaperFileIOThread.ChunkDataController chunkDataController = new com.destroystokyo.paper.io.PaperFileIOThread.ChunkDataController() {
-        @Override
-        public void writeData(int x, int z, net.minecraft.nbt.CompoundTag compound) throws java.io.IOException {
-            ServerLevel.this.getChunkSource().chunkMap.write(new ChunkPos(x, z), compound);
-        }
-
-        @Override
-        public net.minecraft.nbt.CompoundTag readData(int x, int z) throws java.io.IOException {
-            return ServerLevel.this.getChunkSource().chunkMap.readSync(new ChunkPos(x, z));
-        }
-
-        @Override
-        public <T> T computeForRegionFile(int chunkX, int chunkZ, java.util.function.Function<net.minecraft.world.level.chunk.storage.RegionFile, T> function) {
-            synchronized (ServerLevel.this.getChunkSource().chunkMap) {
-                net.minecraft.world.level.chunk.storage.RegionFile file;
-
-                try {
-                    file = ServerLevel.this.getChunkSource().chunkMap.regionFileCache.getRegionFile(new ChunkPos(chunkX, chunkZ), false);
-                } catch (java.io.IOException ex) {
-                    throw new RuntimeException(ex);
-                }
-
-                return function.apply(file);
-            }
-        }
-
-        @Override
-        public <T> T computeForRegionFileIfLoaded(int chunkX, int chunkZ, java.util.function.Function<net.minecraft.world.level.chunk.storage.RegionFile, T> function) {
-            synchronized (ServerLevel.this.getChunkSource().chunkMap) {
-                net.minecraft.world.level.chunk.storage.RegionFile file = ServerLevel.this.getChunkSource().chunkMap.regionFileCache.getRegionFileIfLoaded(new ChunkPos(chunkX, chunkZ));
-                return function.apply(file);
-            }
-        }
-    };
-    public final com.destroystokyo.paper.io.chunk.ChunkTaskManager asyncChunkTaskManager;
-    // Paper end
+    // Paper end - rewrite chunk system
     // Paper start
     @Override
     public boolean hasChunk(int chunkX, int chunkZ) {
@@ -490,6 +418,108 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
     // Paper end - optimise get nearest players for entity AI
 
+    // Paper start - rewrite chunk system
+    public final io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler chunkTaskScheduler;
+    public final io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController chunkDataControllerNew
+        = new io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA) {
+
+        @Override
+        public net.minecraft.world.level.chunk.storage.RegionFileStorage getCache() {
+            return ServerLevel.this.getChunkSource().chunkMap.regionFileCache;
+        }
+
+        @Override
+        public void writeData(int chunkX, int chunkZ, net.minecraft.nbt.CompoundTag compound) throws IOException {
+            ServerLevel.this.getChunkSource().chunkMap.write(new ChunkPos(chunkX, chunkZ), compound);
+        }
+
+        @Override
+        public net.minecraft.nbt.CompoundTag readData(int chunkX, int chunkZ) throws IOException {
+            return ServerLevel.this.getChunkSource().chunkMap.readSync(new ChunkPos(chunkX, chunkZ));
+        }
+    };
+    public final io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController poiDataControllerNew
+        = new io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA) {
+
+        @Override
+        public net.minecraft.world.level.chunk.storage.RegionFileStorage getCache() {
+            return ServerLevel.this.getChunkSource().chunkMap.getPoiManager();
+        }
+
+        @Override
+        public void writeData(int chunkX, int chunkZ, net.minecraft.nbt.CompoundTag compound) throws IOException {
+            ServerLevel.this.getChunkSource().chunkMap.getPoiManager().write(new ChunkPos(chunkX, chunkZ), compound);
+        }
+
+        @Override
+        public net.minecraft.nbt.CompoundTag readData(int chunkX, int chunkZ) throws IOException {
+            return ServerLevel.this.getChunkSource().chunkMap.getPoiManager().read(new ChunkPos(chunkX, chunkZ));
+        }
+    };
+    public final io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController entityDataControllerNew
+        = new io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.ENTITY_DATA) {
+
+        @Override
+        public net.minecraft.world.level.chunk.storage.RegionFileStorage getCache() {
+            return ServerLevel.this.entityStorage;
+        }
+
+        @Override
+        public void writeData(int chunkX, int chunkZ, net.minecraft.nbt.CompoundTag compound) throws IOException {
+            ServerLevel.this.writeEntityChunk(chunkX, chunkZ, compound);
+        }
+
+        @Override
+        public net.minecraft.nbt.CompoundTag readData(int chunkX, int chunkZ) throws IOException {
+            return ServerLevel.this.readEntityChunk(chunkX, chunkZ);
+        }
+    };
+    private final EntityRegionFileStorage entityStorage;
+
+    private static final class EntityRegionFileStorage extends net.minecraft.world.level.chunk.storage.RegionFileStorage {
+
+        public EntityRegionFileStorage(Path directory, boolean dsync) {
+            super(directory, dsync);
+        }
+
+        protected void write(ChunkPos pos, net.minecraft.nbt.CompoundTag nbt) throws IOException {
+            ChunkPos nbtPos = nbt == null ? null : EntityStorage.readChunkPos(nbt);
+            if (nbtPos != null && !pos.equals(nbtPos)) {
+                throw new IllegalArgumentException(
+                    "Entity chunk coordinate and serialized data do not have matching coordinates, trying to serialize coordinate " + pos.toString()
+                        + " but compound says coordinate is " + nbtPos + " for world: " + this
+                );
+            }
+            super.write(pos, nbt);
+        }
+    }
+
+    private void writeEntityChunk(int chunkX, int chunkZ, net.minecraft.nbt.CompoundTag compound) throws IOException {
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            io.papermc.paper.chunk.system.io.RegionFileIOThread.scheduleSave(
+                this, chunkX, chunkZ, compound,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.ENTITY_DATA);
+            return;
+        }
+        this.entityStorage.write(new ChunkPos(chunkX, chunkZ), compound);
+    }
+
+    private net.minecraft.nbt.CompoundTag readEntityChunk(int chunkX, int chunkZ) throws IOException {
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            return io.papermc.paper.chunk.system.io.RegionFileIOThread.loadData(
+                this, chunkX, chunkZ, io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.ENTITY_DATA,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.getIOBlockingPriorityForCurrentThread()
+            );
+        }
+        return this.entityStorage.read(new ChunkPos(chunkX, chunkZ));
+    }
+
+    private final io.papermc.paper.chunk.system.entity.EntityLookup entityLookup;
+    public final io.papermc.paper.chunk.system.entity.EntityLookup getEntityLookup() {
+        return this.entityLookup;
+    }
+    // Paper end - rewrite chunk system
+
     // Add env and gen to constructor, IWorldDataServer -> WorldDataServer
     public ServerLevel(MinecraftServer minecraftserver, Executor executor, LevelStorageSource.LevelStorageAccess convertable_conversionsession, PrimaryLevelData iworlddataserver, ResourceKey<Level> resourcekey, LevelStem worlddimension, ChunkProgressListener worldloadlistener, boolean flag, long i, List<CustomSpawner> list, boolean flag1, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider) {
         // Holder holder = worlddimension.typeHolder(); // CraftBukkit - decompile error
@@ -532,16 +562,16 @@ public class ServerLevel extends Level implements WorldGenLevel {
         // CraftBukkit end
         boolean flag2 = minecraftserver.forceSynchronousWrites();
         DataFixer datafixer = minecraftserver.getFixerUpper();
-        EntityPersistentStorage<Entity> entitypersistentstorage = new EntityStorage(this, convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), datafixer, flag2, minecraftserver);
+        this.entityStorage = new EntityRegionFileStorage(convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), flag2); // Paper - rewrite chunk system  //EntityPersistentStorage<Entity> entitypersistentstorage = new EntityStorage(this, convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), datafixer, flag2, minecraftserver);
 
-        this.entityManager = new PersistentEntitySectionManager<>(Entity.class, new ServerLevel.EntityCallbacks(), entitypersistentstorage, this.entitySliceManager); // Paper
+        // this.entityManager = new PersistentEntitySectionManager<>(Entity.class, new ServerLevel.EntityCallbacks(), entitypersistentstorage, this.entitySliceManager); // Paper // Paper - rewrite chunk system
         StructureTemplateManager structuretemplatemanager = minecraftserver.getStructureManager();
         int j = this.spigotConfig.viewDistance; // Spigot
         int k = this.spigotConfig.simulationDistance; // Spigot
-        PersistentEntitySectionManager persistententitysectionmanager = this.entityManager;
+        //PersistentEntitySectionManager persistententitysectionmanager = this.entityManager; // Paper - rewrite chunk system
 
-        Objects.requireNonNull(this.entityManager);
-        this.chunkSource = new ServerChunkCache(this, convertable_conversionsession, datafixer, structuretemplatemanager, executor, chunkgenerator, j, k, flag2, worldloadlistener, persistententitysectionmanager::updateChunkStatus, () -> {
+        //Objects.requireNonNull(this.entityManager); // Paper - rewrite chunk system
+        this.chunkSource = new ServerChunkCache(this, convertable_conversionsession, datafixer, structuretemplatemanager, executor, chunkgenerator, j, k, flag2, worldloadlistener, null, () -> { // Paper - rewrite chunk system
             return minecraftserver.overworld().getDataStorage();
         });
         chunkgenerator.ensureStructuresGenerated(this.chunkSource.randomState());
@@ -571,7 +601,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
         this.sleepStatus = new SleepStatus();
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
 
-        this.asyncChunkTaskManager = new com.destroystokyo.paper.io.chunk.ChunkTaskManager(this); // Paper
+        this.chunkTaskScheduler = new io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler(this, io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.workerThreads); // Paper - rewrite chunk system
+        this.entityLookup = new io.papermc.paper.chunk.system.entity.EntityLookup(this, new EntityCallbacks()); // Paper - rewrite chunk system
     }
 
     public void setWeatherParameters(int clearDuration, int rainDuration, boolean raining, boolean thundering) {
@@ -708,7 +739,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
 
         gameprofilerfiller.push("entityManagement");
-        this.entityManager.tick();
+        //this.entityManager.tick(); // Paper - rewrite chunk system
         gameprofilerfiller.popPush("gameEvents");
         this.sendGameEvents();
         gameprofilerfiller.pop();
@@ -1126,7 +1157,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public void tickNonPassenger(Entity entity) {
         // Paper start - log detailed entity tick information
         io.papermc.paper.util.TickThread.ensureTickThread("Cannot tick an entity off-main");
-        if (!entity.isRemoved()) this.entityManager.updateNavigatorsInRegion(entity); // Paper - optimise notify
+        //if (!entity.isRemoved()) this.entityManager.updateNavigatorsInRegion(entity); // Paper - optimise notify // Paper - rewrite chunk system
         try {
             if (currentlyTickingEntity.get() == null) {
                 currentlyTickingEntity.lazySet(entity);
@@ -1260,6 +1291,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
     // Paper end
 
     public void save(@Nullable ProgressListener progressListener, boolean flush, boolean savingDisabled) {
+        // Paper start - rewrite chunk system - add close param
+        this.save(progressListener, flush, savingDisabled, false);
+    }
+    public void save(@Nullable ProgressListener progressListener, boolean flush, boolean savingDisabled, boolean close) {
+        // Paper end - rewrite chunk system - add close param
         ServerChunkCache chunkproviderserver = this.getChunkSource();
 
         if (!savingDisabled) {
@@ -1275,14 +1311,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
 
                 timings.worldSaveChunks.startTiming(); // Paper
-            chunkproviderserver.save(flush);
+            if (!close) chunkproviderserver.save(flush); // Paper - rewrite chunk system
+            if (close) chunkproviderserver.close(true); // Paper - rewrite chunk system
                 timings.worldSaveChunks.stopTiming(); // Paper
             }// Paper
-            if (flush) {
-                this.entityManager.saveAll();
-            } else {
-                this.entityManager.autoSave();
-            }
+            // Paper - rewrite chunk system - entity saving moved into ChunkHolder
 
         }
         // Paper start
@@ -1407,7 +1440,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             this.removePlayerImmediately((ServerPlayer) entity, Entity.RemovalReason.DISCARDED);
         }
 
-        this.entityManager.addNewEntity(player);
+        this.entityLookup.addNewEntity(player); // Paper - rewite chunk system
     }
 
     // CraftBukkit start
@@ -1452,7 +1485,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
             // CraftBukkit end
 
-            return this.entityManager.addNewEntity(entity);
+            return this.entityLookup.addNewEntity(entity); // Paper - rewrite chunk system
         }
     }
 
@@ -1464,10 +1497,10 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public boolean tryAddFreshEntityWithPassengers(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
         // CraftBukkit end
         Stream<UUID> stream = entity.getSelfAndPassengers().map(Entity::getUUID); // CraftBukkit - decompile error
-        PersistentEntitySectionManager persistententitysectionmanager = this.entityManager;
+        //PersistentEntitySectionManager persistententitysectionmanager = this.entityManager; // Paper - rewrite chunk system
 
-        Objects.requireNonNull(this.entityManager);
-        if (stream.anyMatch(persistententitysectionmanager::isLoaded)) {
+        //Objects.requireNonNull(this.entityManager); // Paper - rewrite chunk system
+        if (stream.anyMatch(this.entityLookup::hasEntity)) { // Paper - rewrite chunk system
             return false;
         } else {
             this.addFreshEntityWithPassengers(entity, reason); // CraftBukkit
@@ -2157,7 +2190,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 }
             }
 
-            bufferedwriter.write(String.format(Locale.ROOT, "entities: %s\n", this.entityManager.gatherStats()));
+            bufferedwriter.write(String.format(Locale.ROOT, "entities: %s\n", this.entityLookup.getDebugInfo())); // Paper - rewrite chunk system
             bufferedwriter.write(String.format(Locale.ROOT, "block_entity_tickers: %d\n", this.blockEntityTickers.size()));
             bufferedwriter.write(String.format(Locale.ROOT, "block_ticks: %d\n", this.getBlockTicks().count()));
             bufferedwriter.write(String.format(Locale.ROOT, "fluid_ticks: %d\n", this.getFluidTicks().count()));
@@ -2206,7 +2239,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         BufferedWriter bufferedwriter2 = Files.newBufferedWriter(path1);
 
         try {
-            playerchunkmap.dumpChunks(bufferedwriter2);
+            //playerchunkmap.dumpChunks(bufferedwriter2); // Paper - rewrite chunk system
         } catch (Throwable throwable4) {
             if (bufferedwriter2 != null) {
                 try {
@@ -2227,7 +2260,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         BufferedWriter bufferedwriter3 = Files.newBufferedWriter(path2);
 
         try {
-            this.entityManager.dumpSections(bufferedwriter3);
+            //this.entityManager.dumpSections(bufferedwriter3); // Paper - rewrite chunk system
         } catch (Throwable throwable6) {
             if (bufferedwriter3 != null) {
                 try {
@@ -2369,7 +2402,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @VisibleForTesting
     public String getWatchdogStats() {
-        return String.format(Locale.ROOT, "players: %s, entities: %s [%s], block_entities: %d [%s], block_ticks: %d, fluid_ticks: %d, chunk_source: %s", this.players.size(), this.entityManager.gatherStats(), ServerLevel.getTypeCount(this.entityManager.getEntityGetter().getAll(), (entity) -> {
+        return String.format(Locale.ROOT, "players: %s, entities: %s [%s], block_entities: %d [%s], block_ticks: %d, fluid_ticks: %d, chunk_source: %s", this.players.size(), this.entityLookup.getDebugInfo(), ServerLevel.getTypeCount(this.entityLookup.getAll(), (entity) -> { // Paper - rewrite chunk system
             return Registry.ENTITY_TYPE.getKey(entity.getType()).toString();
         }), this.blockEntityTickers.size(), ServerLevel.getTypeCount(this.blockEntityTickers, TickingBlockEntity::getType), this.getBlockTicks().count(), this.getFluidTicks().count(), this.gatherChunkSourceStats());
     }
@@ -2429,15 +2462,15 @@ public class ServerLevel extends Level implements WorldGenLevel {
     @Override
     public LevelEntityGetter<Entity> getEntities() {
         org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot
-        return this.entityManager.getEntityGetter();
+        return this.entityLookup; // Paper - rewrite chunk system
     }
 
     public void addLegacyChunkEntities(Stream<Entity> entities) {
-        this.entityManager.addLegacyChunkEntities(entities);
+        this.entityLookup.addLegacyChunkEntities(entities.toList()); // Paper - rewrite chunk system
     }
 
     public void addWorldGenChunkEntities(Stream<Entity> entities) {
-        this.entityManager.addWorldGenChunkEntities(entities);
+        this.entityLookup.addWorldGenChunkEntities(entities.toList()); // Paper - rewrite chunk system
     }
 
     public void startTickingChunk(LevelChunk chunk) {
@@ -2453,18 +2486,20 @@ public class ServerLevel extends Level implements WorldGenLevel {
     @Override
     public void close() throws IOException {
         super.close();
-        this.entityManager.close();
+        //this.entityManager.close(); // Paper - rewrite chunk system
     }
 
     @Override
     public String gatherChunkSourceStats() {
         String s = this.chunkSource.gatherStats();
 
-        return "Chunks[S] W: " + s + " E: " + this.entityManager.gatherStats();
+        return "Chunks[S] W: " + s + " E: " + this.entityLookup.getDebugInfo(); // Paper - rewrite chunk system
     }
 
     public boolean areEntitiesLoaded(long chunkPos) {
-        return this.entityManager.areEntitiesLoaded(chunkPos);
+        // Paper start - rewrite chunk system
+        return this.getChunkIfLoadedImmediately(ChunkPos.getX(chunkPos), ChunkPos.getZ(chunkPos)) != null;
+        // Paper end - rewrite chunk system
     }
 
     private boolean isPositionTickingWithEntitiesLoaded(long chunkPos) {
@@ -2475,15 +2510,24 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     public boolean isPositionEntityTicking(BlockPos pos) {
-        return this.entityManager.canPositionTick(ChunkPos.asLong(pos)) && this.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(ChunkPos.asLong(pos)); // Paper
+        // Paper start - rewrite chunk system
+        ChunkHolder chunkHolder = this.chunkSource.chunkMap.getVisibleChunkIfPresent(io.papermc.paper.util.CoordinateUtils.getChunkKey(pos));
+        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        // Paper end - rewrite chunk system
     }
 
     public boolean isNaturalSpawningAllowed(BlockPos pos) {
-        return this.entityManager.canPositionTick(ChunkPos.asLong(pos)); // Paper
+        // Paper start - rewrite chunk system
+        ChunkHolder chunkHolder = this.chunkSource.chunkMap.getVisibleChunkIfPresent(io.papermc.paper.util.CoordinateUtils.getChunkKey(pos));
+        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        // Paper end - rewrite chunk system
     }
 
     public boolean isNaturalSpawningAllowed(ChunkPos pos) {
-        return this.entityManager.canPositionTick(pos.toLong()); // Paper
+        // Paper start - rewrite chunk system
+        ChunkHolder chunkHolder = this.chunkSource.chunkMap.getVisibleChunkIfPresent(io.papermc.paper.util.CoordinateUtils.getChunkKey(pos));
+        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        // Paper end - rewrite chunk system
     }
 
     // Paper start - optimize redstone (Alternate Current)
@@ -2506,12 +2550,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
         public void onTickingStart(Entity entity) {
             if (entity instanceof net.minecraft.world.entity.Marker) return; // Paper - Don't tick markers
             ServerLevel.this.entityTickList.add(entity);
-            ServerLevel.this.entityManager.addNavigatorsIfPathingToRegion(entity); // Paper - optimise notify
+            //ServerLevel.this.entityManager.addNavigatorsIfPathingToRegion(entity); // Paper - optimise notify // Paper - rewrite chunk system
         }
 
         public void onTickingEnd(Entity entity) {
             ServerLevel.this.entityTickList.remove(entity);
-            ServerLevel.this.entityManager.removeNavigatorsFromData(entity); // Paper - optimise notify
+            //ServerLevel.this.entityManager.removeNavigatorsFromData(entity); // Paper - optimise notify // Paper - rewrite chunk system
             // Paper start - Reset pearls when they stop being ticked
             if (paperConfig().fixes.disableUnloadedChunkEnderpearlExploit && entity instanceof net.minecraft.world.entity.projectile.ThrownEnderpearl pearl) {
                 pearl.cachedOwner = null;
diff --git a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
index b57bffce30154b196b879209c1ce559d0b82456e..9b8035b7b2668cd31f70b021c4db6900f44fc7f7 100644
--- a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
+++ b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
@@ -36,149 +36,22 @@ import net.minecraft.world.level.chunk.ChunkStatus;
 
 public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCloseable {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final ProcessorMailbox<Runnable> taskMailbox;
-    // Paper start
-    private static final int MAX_PRIORITIES = ChunkMap.MAX_CHUNK_DISTANCE + 2;
-
-    static class ChunkLightQueue {
-        public boolean shouldFastUpdate;
-        java.util.ArrayDeque<Runnable> pre = new java.util.ArrayDeque<Runnable>();
-        java.util.ArrayDeque<Runnable> post = new java.util.ArrayDeque<Runnable>();
-
-        ChunkLightQueue(long chunk) {}
-    }
-
-    static class PendingLightTask {
-        long chunkId;
-        IntSupplier priority;
-        Runnable pre;
-        Runnable post;
-        boolean fastUpdate;
-
-        public PendingLightTask(long chunkId, IntSupplier priority, Runnable pre, Runnable post, boolean fastUpdate) {
-            this.chunkId = chunkId;
-            this.priority = priority;
-            this.pre = pre;
-            this.post = post;
-            this.fastUpdate = fastUpdate;
-        }
-    }
-
-
-    // Retain the chunks priority level for queued light tasks
-    class LightQueue {
-        private int size = 0;
-        private final it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<ChunkLightQueue>[] buckets = new it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap[MAX_PRIORITIES];
-        private final java.util.concurrent.ConcurrentLinkedQueue<PendingLightTask> pendingTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
-        private final java.util.concurrent.ConcurrentLinkedQueue<Runnable> priorityChanges = new java.util.concurrent.ConcurrentLinkedQueue<>();
-
-        private LightQueue() {
-            for (int i = 0; i < buckets.length; i++) {
-                buckets[i] = new it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<>();
-            }
-        }
-
-        public void changePriority(long pair, int currentPriority, int priority) {
-            this.priorityChanges.add(() -> {
-                ChunkLightQueue remove = this.buckets[currentPriority].remove(pair);
-                if (remove != null) {
-                    ChunkLightQueue existing = this.buckets[Math.max(1, priority)].put(pair, remove);
-                    if (existing != null) {
-                        remove.pre.addAll(existing.pre);
-                        remove.post.addAll(existing.post);
-                    }
-                }
-            });
-        }
-
-        public final void addChunk(long chunkId, IntSupplier priority, Runnable pre, Runnable post) {
-            pendingTasks.add(new PendingLightTask(chunkId, priority, pre, post, true));
-            tryScheduleUpdate();
-        }
-
-        public final void add(long chunkId, IntSupplier priority, ThreadedLevelLightEngine.TaskType type, Runnable run) {
-            pendingTasks.add(new PendingLightTask(chunkId, priority, type == TaskType.PRE_UPDATE ? run : null, type == TaskType.POST_UPDATE ? run : null, false));
-        }
-        public final void add(PendingLightTask update) {
-            int priority = update.priority.getAsInt();
-            ChunkLightQueue lightQueue = this.buckets[priority].computeIfAbsent(update.chunkId, ChunkLightQueue::new);
-
-            if (update.pre != null) {
-                this.size++;
-                lightQueue.pre.add(update.pre);
-            }
-            if (update.post != null) {
-                this.size++;
-                lightQueue.post.add(update.post);
-            }
-            if (update.fastUpdate) {
-                lightQueue.shouldFastUpdate = true;
-            }
-        }
-
-        public final boolean isEmpty() {
-            return this.size == 0 && this.pendingTasks.isEmpty();
-        }
-
-        public final int size() {
-            return this.size;
-        }
-
-        public boolean poll(java.util.List<Runnable> pre, java.util.List<Runnable> post) {
-            PendingLightTask pending;
-            while ((pending = pendingTasks.poll()) != null) {
-                add(pending);
-            }
-            Runnable run;
-            while ((run = priorityChanges.poll()) != null) {
-                run.run();
-            }
-            boolean hasWork = false;
-            it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<ChunkLightQueue>[] buckets = this.buckets;
-            int priority = 0;
-            while (priority < MAX_PRIORITIES && !isEmpty()) {
-                it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<ChunkLightQueue> bucket = buckets[priority];
-                if (bucket.isEmpty()) {
-                    priority++;
-                    if (hasWork) {
-                        return true;
-                    } else {
-                        continue;
-                    }
-                }
-                ChunkLightQueue queue = bucket.removeFirst();
-                this.size -= queue.pre.size() + queue.post.size();
-                pre.addAll(queue.pre);
-                post.addAll(queue.post);
-                queue.pre.clear();
-                queue.post.clear();
-                hasWork = true;
-                if (queue.shouldFastUpdate) {
-                    return true;
-                }
-            }
-            return hasWork;
-        }
-    }
-
-    final LightQueue queue = new LightQueue();
-    // Paper end
-    private final ChunkMap chunkMap; private final ChunkMap playerChunkMap; // Paper
-    private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> sorterMailbox;
+    // Paper - rewrite chunk system
+    private final ChunkMap chunkMap; // Paper - rewrite chunk system
+    // Paper - rewrite chunk system
     private volatile int taskPerBatch = 5;
-    private final AtomicBoolean scheduled = new AtomicBoolean();
+    // Paper - rewrite chunk system
 
     // Paper start - replace light engine impl
-    protected final ca.spottedleaf.starlight.common.light.StarLightInterface theLightEngine;
+    public final ca.spottedleaf.starlight.common.light.StarLightInterface theLightEngine;
     public final boolean hasBlockLight;
     public final boolean hasSkyLight;
     // Paper end - replace light engine impl
 
     public ThreadedLevelLightEngine(LightChunkGetter chunkProvider, ChunkMap chunkStorage, boolean hasBlockLight, ProcessorMailbox<Runnable> processor, ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> executor) {
         super(chunkProvider, false, false); // Paper - destroy vanilla light engine state
-        this.chunkMap = chunkStorage; this.playerChunkMap = chunkMap; // Paper
-        this.sorterMailbox = executor;
-        this.taskMailbox = processor;
+        this.chunkMap = chunkStorage; // Paper - rewrite chunk system
+        // Paper - rewrite chunk system
         // Paper start - replace light engine impl
         this.hasBlockLight = true;
         this.hasSkyLight = hasBlockLight; // Nice variable name.
@@ -222,7 +95,7 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
             ++totalChunks;
         }
 
-        this.taskMailbox.tell(() -> {
+        this.chunkMap.level.chunkTaskScheduler.lightExecutor.queueRunnable(() -> { // Paper - rewrite chunk system
             this.theLightEngine.relightChunks(chunks, (ChunkPos chunkPos) -> {
                 chunkLightCallback.accept(chunkPos);
                 ((java.util.concurrent.Executor)((ServerLevel)this.theLightEngine.getWorld()).getChunkSource().mainThreadProcessor).execute(() -> {
@@ -285,9 +158,7 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
             for (int dz = -1; dz <= 1; ++dz) {
                 ChunkHolder neighbour = world.getChunkSource().chunkMap.getUpdatingChunkIfPresent(CoordinateUtils.getChunkKey(dx + chunkX, dz + chunkZ));
                 if (neighbour != null) {
-                    neighbour.chunkToSave = neighbour.chunkToSave.thenCombine(updateFuture, (final ChunkAccess curr, final Void ignore) -> {
-                        return curr;
-                    });
+                    // Paper - rewrite chunk system - not needed, light ticket will keep these chunks loaded
                 }
             }
         }
@@ -311,7 +182,7 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
     @Override
     public boolean hasLightWork() {
         // route to new light engine
-        return this.theLightEngine.hasUpdates() || !this.queue.isEmpty();
+        return this.theLightEngine.hasUpdates(); // Paper - rewrite chunk system
     }
 
     @Override
@@ -408,13 +279,11 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
     }
 
     private void addTask(int x, int z, ThreadedLevelLightEngine.TaskType stage, Runnable task) {
-        this.addTask(x, z, this.chunkMap.getChunkQueueLevel(ChunkPos.asLong(x, z)), stage, task);
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     private void addTask(int x, int z, IntSupplier completedLevelSupplier, ThreadedLevelLightEngine.TaskType stage, Runnable task) {
-        // Paper start - replace method
-        this.queue.add(ChunkPos.asLong(x, z), completedLevelSupplier, stage, task);
-        // Paper end
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     @Override
@@ -472,74 +341,17 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
                 }
             });
         }
-        // Paper end - replace light engine impl
-        ChunkPos chunkPos = chunk.getPos();
-        // Paper start
-        //ichunkaccess.b(false); // Don't need to disable this
-        long pair = chunkPos.toLong();
-        CompletableFuture<ChunkAccess> future = new CompletableFuture<>();
-        IntSupplier prioritySupplier = playerChunkMap.getChunkQueueLevel(pair);
-        boolean[] skippedPre = {false};
-        this.queue.addChunk(pair, prioritySupplier, Util.name(() -> {
-            // Paper end
-            LevelChunkSection[] levelChunkSections = chunk.getSections();
-
-            for(int i = 0; i < chunk.getSectionsCount(); ++i) {
-                LevelChunkSection levelChunkSection = levelChunkSections[i];
-                if (!levelChunkSection.hasOnlyAir()) {
-                    int j = this.levelHeightAccessor.getSectionYFromSectionIndex(i);
-                    super.updateSectionStatus(SectionPos.of(chunkPos, j), false);
-                }
-            }
-
-            super.enableLightSources(chunkPos, true);
-            if (!excludeBlocks) {
-                chunk.getLights().forEach((pos) -> {
-                    super.onBlockEmissionIncrease(pos, chunk.getLightEmission(pos));
-                });
-            }
-
-        }, () -> {
-            return "lightChunk " + chunkPos + " " + excludeBlocks;
-            // Paper start  - merge the 2 together
-        }), () -> {
-            this.chunkMap.releaseLightTicket(chunkPos); // Paper - moved from below, we want to call this even when returning early
-            if (skippedPre[0]) return; // Paper - future's already complete
-            chunk.setLightCorrect(true);
-            super.retainData(chunkPos, false);
-            //this.chunkMap.releaseLightTicket(chunkPos); // Paper - moved up
-            future.complete(chunk);
-        });
-        return future;
-        // Paper end
+        throw new InternalError(); // Paper - rewrite chunk system
     }
 
     public void tryScheduleUpdate() {
-        if (this.hasLightWork() && this.scheduled.compareAndSet(false, true)) { // Paper  // Paper - rewrite light engine
-            this.taskMailbox.tell(() -> {
-                this.runUpdate();
-                this.scheduled.set(false);
-                tryScheduleUpdate(); // Paper - if we still have work to do, do it!
-            });
-        }
+        // Paper - rewrite chunk system
 
     }
 
-    // Paper start - replace impl
-    private final java.util.List<Runnable> pre = new java.util.ArrayList<>();
-    private final java.util.List<Runnable> post = new java.util.ArrayList<>();
+    // Paper - rewrite chunk system
     private void runUpdate() {
-        if (queue.poll(pre, post)) {
-            pre.forEach(Runnable::run);
-            pre.clear();
-            this.theLightEngine.propagateChanges(); // Paper - rewrite light engine
-            post.forEach(Runnable::run);
-            post.clear();
-        } else {
-            // might have level updates to go still
-            this.theLightEngine.propagateChanges(); // Paper - rewrite light engine
-        }
-        // Paper end
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public void setTaskPerBatch(int taskBatchSize) {
diff --git a/src/main/java/net/minecraft/server/level/Ticket.java b/src/main/java/net/minecraft/server/level/Ticket.java
index 2b2b7851d5f68bcdb41d58bcc64740ba58bf1ef4..28edbae568a06ec040795d75f24de8b4218da141 100644
--- a/src/main/java/net/minecraft/server/level/Ticket.java
+++ b/src/main/java/net/minecraft/server/level/Ticket.java
@@ -6,15 +6,16 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
     private final TicketType<T> type;
     private final int ticketLevel;
     public final T key;
-    public long createdTick;
-    public long delayUnloadBy; // Paper
-    public int priority; // Paper - Chunk priority
+    // Paper start - rewrite chunk system
+    public final long removalTick;
 
-    protected Ticket(TicketType<T> type, int level, T argument) {
+    public Ticket(TicketType<T> type, int level, T argument, long removalTick) {
+        this.removalTick = removalTick;
+        // Paper end - rewrite chunk system
         this.type = type;
         this.ticketLevel = level;
         this.key = argument;
-        this.delayUnloadBy = type.timeout; // Paper
+        // Paper - rewrite chunk system
     }
 
     @Override
@@ -47,7 +48,7 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
 
     @Override
     public String toString() {
-        return "Ticket[" + this.type + " " + this.ticketLevel + " (" + this.key + ")] at " + this.createdTick;
+        return "Ticket[" + this.type + " " + this.ticketLevel + " (" + this.key + ")] to die on " + this.removalTick; // Paper - rewrite chunk system
     }
 
     public TicketType<T> getType() {
@@ -59,11 +60,10 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
     }
 
     protected void setCreatedTick(long tickCreated) {
-        this.createdTick = tickCreated;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     protected boolean timedOut(long currentTick) {
-        long l = delayUnloadBy; // Paper
-        return l != 0L && currentTick - this.createdTick > l;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 }
diff --git a/src/main/java/net/minecraft/server/level/TicketType.java b/src/main/java/net/minecraft/server/level/TicketType.java
index ae46429264e6a7e5c88b6b6a41a6df4db7b3e70d..548f88e007374ee09d5e31f68139fa3ba13e3751 100644
--- a/src/main/java/net/minecraft/server/level/TicketType.java
+++ b/src/main/java/net/minecraft/server/level/TicketType.java
@@ -33,6 +33,11 @@ public class TicketType<T> {
     public static final TicketType<Long> DELAY_UNLOAD = create("delay_unload", Long::compareTo, 300); // Paper
     public static final TicketType<Long> REQUIRED_LOAD = create("required_load", Long::compareTo); // Paper - make sure getChunkAt does not fail
     public static final TicketType<Long> CHUNK_RELIGHT = create("light_update", Long::compareTo); // Paper - ensure chunks stay loaded for lighting
+    public static final TicketType<Long> CHUNK_LOAD = create("chunk_load", Long::compareTo); // Paper - rewrite chunk system
+    public static final TicketType<Long> STATUS_UPGRADE = create("status_upgrade", Long::compareTo); // Paper - rewrite chunk system
+    public static final TicketType<Long> ENTITY_LOAD = create("entity_load", Long::compareTo); // Paper - rewrite chunk system
+    public static final TicketType<Long> POI_LOAD = create("poi_load", Long::compareTo); // Paper - rewrite chunk system
+    public static final TicketType<Unit> UNLOAD_COOLDOWN = create("unload_cooldown", (u1, u2) -> 0, 10 * 20); // Paper - rewrite chunk system
 
     public static <T> TicketType<T> create(String name, Comparator<T> argumentComparator) {
         return new TicketType<>(name, argumentComparator, 0L);
diff --git a/src/main/java/net/minecraft/util/SortedArraySet.java b/src/main/java/net/minecraft/util/SortedArraySet.java
index 5f1c4c6b9e36f2d6ec43b82cc0e2cae24b800dc4..5fcbb4fd003603408c48408230a17b692fabd519 100644
--- a/src/main/java/net/minecraft/util/SortedArraySet.java
+++ b/src/main/java/net/minecraft/util/SortedArraySet.java
@@ -145,6 +145,31 @@ public class SortedArraySet<T> extends AbstractSet<T> {
         }
     }
 
+    // Paper start - rewrite chunk system
+    public T replace(T object) {
+        int i = this.findIndex(object);
+        if (i >= 0) {
+            T old = this.contents[i];
+            this.contents[i] = object;
+            return old;
+        } else {
+            this.addInternal(object, getInsertionPosition(i));
+            return object;
+        }
+    }
+
+    public T removeAndGet(T object) {
+        int i = this.findIndex(object);
+        if (i >= 0) {
+            final T ret = this.contents[i];
+            this.removeInternal(i);
+            return ret;
+        } else {
+            return null;
+        }
+    }
+    // Paper end - rewrite chunk system
+
     @Override
     public boolean remove(Object object) {
         int i = this.findIndex((T)object);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index a3f1aef9d8f254747bd6580e8e3087a5c6829128..7fa0713f28e3fab685aba8660b7ac40f6da61ae8 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -539,6 +539,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public int sectionX = Integer.MIN_VALUE;
     public int sectionY = Integer.MIN_VALUE;
     public int sectionZ = Integer.MIN_VALUE;
+
+    public boolean updatingSectionStatus = false;
     // Paper end
 
     public Entity(EntityType<?> type, Level world) {
@@ -3900,6 +3902,16 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         };
     }
 
+    // Paper start - rewrite chunk system
+    public boolean hasAnyPlayerPassengers() {
+        // copied from below
+        if (this.passengers.isEmpty()) { return false; }
+        return this.getIndirectPassengersStream().anyMatch((entity) -> {
+            return entity instanceof Player;
+        });
+    }
+    // Paper end - rewrite chunk system
+
     public boolean hasExactlyOnePlayerPassenger() {
         if (this.passengers.isEmpty()) { return false; } // Paper
         return this.getIndirectPassengersStream().filter((entity) -> {
@@ -4231,6 +4243,12 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             return;
         }
         // Paper end - block invalid positions
+        // Paper start - rewrite chunk system
+        if (this.updatingSectionStatus) {
+            LOGGER.error("Refusing to update position for entity " + this + " to position " + new Vec3(x, y, z) + " since it is processing a section status update", new Throwable());
+            return;
+        }
+        // Paper end - rewrite chunk system
         // Paper end
         // Paper start - fix MC-4
         if (this instanceof ItemEntity) {
@@ -4345,6 +4363,13 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
     @Override
     public final void setRemoved(Entity.RemovalReason reason) {
+        // Paper start - rewrite chunk system
+        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot remove entity off-main");
+        if (this.updatingSectionStatus) {
+            LOGGER.warn("Entity " + this + " is currently prevented from being added/removed to world since it is processing section status updates", new Throwable());
+            return;
+        }
+        // Paper end - rewrite chunk system
         if (this.removalReason == null) {
             this.removalReason = reason;
         }
@@ -4353,7 +4378,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             this.stopRiding();
         }
 
-        this.getPassengers().forEach(Entity::stopRiding);
+        if (reason != RemovalReason.UNLOADED_TO_CHUNK) this.getPassengers().forEach(Entity::stopRiding); // Paper - chunk system - don't adjust passenger state when unloading, it's just not safe (and messes with our logic in entity chunk unload)
         this.levelCallback.onRemove(reason);
     }
 
@@ -4368,7 +4393,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
     @Override
     public boolean shouldBeSaved() {
-        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.isPassenger() ? false : !this.isVehicle() || !this.hasExactlyOnePlayerPassenger());
+        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.isPassenger() ? false : !this.isVehicle() || !this.hasAnyPlayerPassengers()); // Paper - rewrite chunk system - it should check if the entity has ANY player passengers
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 210b0cdd4831421c8f43c3d823ac8e962b56bbbc..c8198424f7d30e546f7e1839be72d65a01461960 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -1,12 +1,11 @@
 package net.minecraft.world.entity.ai.village.poi;
 
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import io.papermc.paper.chunk.system.scheduling.ChunkHolderManager;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
+
 import java.nio.file.Path;
 import java.util.Comparator;
 import java.util.List;
@@ -55,7 +54,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         }
     }
     // Paper end - unload poi data
-    private final LongSet loadedChunks = new LongOpenHashSet();
+    // Paper - rewrite chunk system
     public final net.minecraft.server.level.ServerLevel world; // Paper // Paper public
 
     public PoiManager(Path path, DataFixer dataFixer, boolean dsync, RegistryAccess registryManager, LevelHeightAccessor world) {
@@ -64,119 +63,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         this.world = (net.minecraft.server.level.ServerLevel)world; // Paper
     }
 
-    // Paper start - actually unload POI data
-    private final java.util.TreeSet<QueuedUnload> queuedUnloads = new java.util.TreeSet<>();
-    private final Long2ObjectOpenHashMap<QueuedUnload> queuedUnloadsByCoordinate = new Long2ObjectOpenHashMap<>();
-
-    static final class QueuedUnload implements Comparable<QueuedUnload> {
-
-        private final long unloadTick;
-        private final long coordinate;
-
-        public QueuedUnload(long unloadTick, long coordinate) {
-            this.unloadTick = unloadTick;
-            this.coordinate = coordinate;
-        }
-
-        @Override
-        public int compareTo(QueuedUnload other) {
-            if (other.unloadTick == this.unloadTick) {
-                return Long.compare(this.coordinate, other.coordinate);
-            } else {
-                return Long.compare(this.unloadTick, other.unloadTick);
-            }
-        }
-
-        @Override
-        public int hashCode() {
-            int hash = 1;
-            hash = hash * 31 + Long.hashCode(this.unloadTick);
-            hash = hash * 31 + Long.hashCode(this.coordinate);
-            return hash;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (obj == null || obj.getClass() != QueuedUnload.class) {
-                return false;
-            }
-            QueuedUnload other = (QueuedUnload)obj;
-            return other.unloadTick == this.unloadTick && other.coordinate == this.coordinate;
-        }
-    }
-
-    long determineDelay(long coordinate) {
-        if (this.isEmpty(coordinate)) {
-            return 5 * 60 * 20;
-        } else {
-            return 60 * 20;
-        }
-    }
-
-    public void queueUnload(long coordinate, long minTarget) {
-        io.papermc.paper.util.TickThread.softEnsureTickThread("async poi unload queue");
-        QueuedUnload unload = new QueuedUnload(minTarget + this.determineDelay(coordinate), coordinate);
-        QueuedUnload existing = this.queuedUnloadsByCoordinate.put(coordinate, unload);
-        if (existing != null) {
-            this.queuedUnloads.remove(existing);
-        }
-        this.queuedUnloads.add(unload);
-    }
-
-    public void dequeueUnload(long coordinate) {
-        io.papermc.paper.util.TickThread.softEnsureTickThread("async poi unload dequeue");
-        QueuedUnload unload = this.queuedUnloadsByCoordinate.remove(coordinate);
-        if (unload != null) {
-            this.queuedUnloads.remove(unload);
-        }
-    }
-
-    public void pollUnloads(BooleanSupplier canSleepForTick) {
-        io.papermc.paper.util.TickThread.softEnsureTickThread("async poi unload");
-        long currentTick = net.minecraft.server.MinecraftServer.currentTickLong;
-        net.minecraft.server.level.ServerChunkCache chunkProvider = this.world.getChunkSource();
-        net.minecraft.server.level.ChunkMap playerChunkMap = chunkProvider.chunkMap;
-        // copied target determination from PlayerChunkMap
-
-        java.util.Iterator<QueuedUnload> iterator = this.queuedUnloads.iterator();
-        for (int i = 0; iterator.hasNext() && (i < 200 || this.queuedUnloads.size() > 2000 || canSleepForTick.getAsBoolean()); i++) {
-            QueuedUnload unload = iterator.next();
-            if (unload.unloadTick > currentTick) {
-                break;
-            }
-
-            long coordinate = unload.coordinate;
-
-            iterator.remove();
-            this.queuedUnloadsByCoordinate.remove(coordinate);
-
-            if (playerChunkMap.getUnloadingChunkHolder(net.minecraft.server.MCUtil.getCoordinateX(coordinate), net.minecraft.server.MCUtil.getCoordinateZ(coordinate)) != null
-                || playerChunkMap.getUpdatingChunkIfPresent(coordinate) != null) {
-                continue;
-            }
-
-            this.unloadData(coordinate);
-        }
-    }
-
-    @Override
-    public void unloadData(long coordinate) {
-        io.papermc.paper.util.TickThread.softEnsureTickThread("async unloading poi data");
-        super.unloadData(coordinate);
-    }
-
-    @Override
-    protected void onUnload(long coordinate) {
-        io.papermc.paper.util.TickThread.softEnsureTickThread("async poi unload callback");
-        this.loadedChunks.remove(coordinate);
-        int chunkX = net.minecraft.server.MCUtil.getCoordinateX(coordinate);
-        int chunkZ = net.minecraft.server.MCUtil.getCoordinateZ(coordinate);
-        for (int section = this.levelHeightAccessor.getMinSection(); section < this.levelHeightAccessor.getMaxSection(); ++section) {
-            long sectionPos = SectionPos.asLong(chunkX, section, chunkZ);
-            this.updateDistanceTracking(sectionPos);
-        }
-    }
-    // Paper end - actually unload POI data
+    // Paper - rewrite chunk system
 
     public void add(BlockPos pos, Holder<PoiType> type) {
         this.getOrCreate(SectionPos.asLong(pos)).add(pos, type);
@@ -346,6 +233,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
 
     @Override
     public void tick(BooleanSupplier shouldKeepTicking) {
+        /* // Paper start - rewrite chunk system, unload state is handled by the chunk holder now
         // Paper start - async chunk io
         while (!this.dirty.isEmpty() && shouldKeepTicking.getAsBoolean() && !this.world.noSave()) { // Paper - unload POI data - don't write to disk if saving is disabled
             ChunkPos chunkcoordintpair = SectionPos.of(this.dirty.firstLong()).chunk();
@@ -362,13 +250,106 @@ public class PoiManager extends SectionStorage<PoiSection> {
             this.pollUnloads(shouldKeepTicking);
         }
         // Paper end - unload POI data
+         */ // Paper end - rewrite chunk system, unload state is handled by the chunk holder now
         // Paper end
         this.villageDistanceTracker.propagateUpdates(); // Paper - replace distance tracking until
     }
 
+    // Paper start - rewrite chunk system
+    @Override
+    public Optional<PoiSection> get(long pos) {
+        int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
+        int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
+        int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
+
+        io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Accessing poi chunk off-main");
+
+        ChunkHolderManager manager =
+            this.world.chunkTaskScheduler.chunkHolderManager;
+        io.papermc.paper.chunk.system.poi.PoiChunk ret = manager.getPoiChunkIfLoaded(chunkX, chunkZ, true);
+
+        return ret == null ? Optional.empty() : ret.getSectionForVanilla(chunkY);
+    }
+
+    @Override
+    public Optional<PoiSection> getOrLoad(long pos) {
+        int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
+        int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
+        int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
+
+        io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Accessing poi chunk off-main");
+
+        ChunkHolderManager manager =
+            this.world.chunkTaskScheduler.chunkHolderManager;
+
+        if (chunkY >= io.papermc.paper.util.WorldUtil.getMinSection(this.world) &&
+            chunkY <= io.papermc.paper.util.WorldUtil.getMaxSection(this.world)) {
+            io.papermc.paper.chunk.system.poi.PoiChunk ret = manager.getPoiChunkIfLoaded(chunkX, chunkZ, true);
+            if (ret != null) {
+                return ret.getSectionForVanilla(chunkY);
+            } else {
+                return manager.loadPoiChunk(chunkX, chunkZ).getSectionForVanilla(chunkY);
+            }
+        }
+        // retain vanilla behavior: do not load section if out of bounds!
+        return Optional.empty();
+    }
+
+    @Override
+    protected PoiSection getOrCreate(long pos) {
+        int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
+        int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
+        int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
+
+        io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Accessing poi chunk off-main");
+
+        ChunkHolderManager manager =
+            this.world.chunkTaskScheduler.chunkHolderManager;
+
+        io.papermc.paper.chunk.system.poi.PoiChunk ret = manager.getPoiChunkIfLoaded(chunkX, chunkZ, true);
+        if (ret != null) {
+            return ret.getOrCreateSection(chunkY);
+        } else {
+            return manager.loadPoiChunk(chunkX, chunkZ).getOrCreateSection(chunkY);
+        }
+    }
+
+    @Override
+    public void onUnload(long coordinate) { // Paper - rewrite chunk system
+        int chunkX = net.minecraft.server.MCUtil.getCoordinateX(coordinate);
+        int chunkZ = net.minecraft.server.MCUtil.getCoordinateZ(coordinate);
+        io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Unloading poi chunk off-main");
+        for (int section = this.levelHeightAccessor.getMinSection(); section < this.levelHeightAccessor.getMaxSection(); ++section) {
+            long sectionPos = SectionPos.asLong(chunkX, section, chunkZ);
+            this.updateDistanceTracking(sectionPos);
+        }
+    }
+
+    public void loadInPoiChunk(io.papermc.paper.chunk.system.poi.PoiChunk poiChunk) {
+        int chunkX = poiChunk.chunkX;
+        int chunkZ = poiChunk.chunkZ;
+        io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Loading poi chunk off-main");
+        for (int sectionY = this.levelHeightAccessor.getMinSection(); sectionY < this.levelHeightAccessor.getMaxSection(); ++sectionY) {
+            PoiSection section = poiChunk.getSection(sectionY);
+            if (section != null && !section.isEmpty()) {
+                this.onSectionLoad(SectionPos.asLong(chunkX, sectionY, chunkZ));
+            }
+        }
+    }
+    // Paper end - rewrite chunk system
+
     @Override
-    protected void setDirty(long pos) {
-        super.setDirty(pos);
+    public void setDirty(long pos) { // Paper - rewrite chunk system
+        // Paper start - rewrite chunk system
+        int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
+        int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
+        ChunkHolderManager manager =
+            this.world.chunkTaskScheduler.chunkHolderManager;
+        io.papermc.paper.chunk.system.poi.PoiChunk chunk = manager.getPoiChunkIfLoaded(chunkX, chunkZ, false);
+        if (chunk != null) {
+            chunk.setDirty(true);
+        }
+        // Paper end - rewrite chunk system
         this.updateDistanceTracking(pos); // Paper - move to new distance tracking util
     }
 
@@ -416,7 +397,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         }).map((pair) -> {
             return pair.getFirst().chunk();
         }).filter((chunkPos) -> {
-            return this.loadedChunks.add(chunkPos.toLong());
+            return true; // Paper - rewrite chunk system
         }).forEach((chunkPos) -> {
             world.getChunk(chunkPos.x, chunkPos.z, ChunkStatus.EMPTY);
         });
@@ -459,27 +440,27 @@ public class PoiManager extends SectionStorage<PoiSection> {
     @javax.annotation.Nullable
     @Override
     public net.minecraft.nbt.CompoundTag read(ChunkPos chunkcoordintpair) throws java.io.IOException {
-        if (this.world != null && Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
-            net.minecraft.nbt.CompoundTag ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
-                .loadChunkDataAsyncFuture(this.world, chunkcoordintpair.x, chunkcoordintpair.z, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
-                    true, false, true).join().poiData;
-
-            if (ret == com.destroystokyo.paper.io.PaperFileIOThread.FAILURE_VALUE) {
-                throw new java.io.IOException("See logs for further detail");
-            }
-            return ret;
+        // Paper start - rewrite chunk system
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            return io.papermc.paper.chunk.system.io.RegionFileIOThread.loadData(
+                this.world, chunkcoordintpair.x, chunkcoordintpair.z, io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.getIOBlockingPriorityForCurrentThread()
+            );
         }
+        // Paper end - rewrite chunk system
         return super.read(chunkcoordintpair);
     }
 
     @Override
     public void write(ChunkPos chunkcoordintpair, net.minecraft.nbt.CompoundTag nbttagcompound) throws java.io.IOException {
-        if (this.world != null && Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
-            com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
-                this.world, chunkcoordintpair.x, chunkcoordintpair.z, nbttagcompound, null,
-                com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
+        // Paper start - rewrite chunk system
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            io.papermc.paper.chunk.system.io.RegionFileIOThread.scheduleSave(
+                this.world, chunkcoordintpair.x, chunkcoordintpair.z, nbttagcompound,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA);
             return;
         }
+        // Paper end - rewrite chunk system
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
index b71a4027a0eed467a3707c59315092ddecfd6bf3..2e410b21564a067ed04f4179908fba8389062f4c 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
@@ -29,6 +29,7 @@ public class PoiSection {
     private final Map<Holder<PoiType>, Set<PoiRecord>> byType = Maps.newHashMap(); public final Map<Holder<PoiType>, Set<PoiRecord>> getData() { return this.byType; } // Paper - public accessor
     private final Runnable setDirty;
     private boolean isValid;
+    public final Optional<PoiSection> noAllocateOptional = Optional.of(this); // Paper - rewrite chunk system
 
     public static Codec<PoiSection> codec(Runnable updateListener) {
         return RecordCodecBuilder.<PoiSection>create((instance) -> { // Paper - decompile fix
@@ -46,6 +47,12 @@ public class PoiSection {
         this(updateListener, true, ImmutableList.of());
     }
 
+    // Paper start - isEmpty
+    public boolean isEmpty() {
+        return this.isValid && this.records.isEmpty() && this.byType.isEmpty();
+    }
+    // Paper end
+
     private PoiSection(Runnable updateListener, boolean valid, List<PoiRecord> pois) {
         this.setDirty = updateListener;
         this.isValid = valid;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index ceb1f18ec16ddcda792ef0393b5f4649fbef3017..54908304e60cb6c956f6f4cac0a144a6f6c3547a 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -356,7 +356,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
         this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
         this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
-        this.entitySliceManager = new io.papermc.paper.world.EntitySliceManager((ServerLevel)this); // Paper
+       // this.entitySliceManager = new io.papermc.paper.world.EntitySliceManager((ServerLevel)this); // Paper // Paper - rewrite chunk system
     }
 
     // Paper start
@@ -961,7 +961,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         }
         // Paper end
         // CraftBukkit end
-        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && Thread.currentThread() != this.thread ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE));
+        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && !io.papermc.paper.util.TickThread.isTickThread() ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE)); // Paper - rewrite chunk system
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
@@ -1052,7 +1052,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public List<Entity> getEntities(@Nullable Entity except, AABB box, Predicate<? super Entity> predicate) {
         this.getProfiler().incrementCounter("getEntities");
         List<Entity> list = Lists.newArrayList();
-        this.entitySliceManager.getEntities(except, box, list, predicate); // Paper - optimise this call
+        ((ServerLevel)this).getEntityLookup().getEntities(except, box, list, predicate); // Paper - optimise this call
         return list;
     }
 
@@ -1063,7 +1063,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
         // Paper start - optimise this call
         if (filter instanceof net.minecraft.world.entity.EntityType) {
-            this.entitySliceManager.getEntities((net.minecraft.world.entity.EntityType)filter, box, list, predicate);
+            ((ServerLevel)this).getEntityLookup().getEntities((net.minecraft.world.entity.EntityType)filter, box, list, predicate);
         } else {
             Predicate<? super T> test = (obj) -> {
                 return filter.tryCast(obj) != null;
@@ -1071,9 +1071,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
             predicate = predicate == null ? test : test.and((Predicate)predicate);
             Class base;
             if (filter == null || (base = filter.getBaseClass()) == null || base == Entity.class) {
-                this.entitySliceManager.getEntities((Entity) null, box, (List)list, (Predicate)predicate);
+                ((ServerLevel)this).getEntityLookup().getEntities((Entity) null, box, (List)list, (Predicate)predicate);
             } else {
-                this.entitySliceManager.getEntities(base, null, box, (List)list, (Predicate)predicate); // Paper - optimise this call
+                ((ServerLevel)this).getEntityLookup().getEntities(base, null, box, (List)list, (Predicate)predicate); // Paper - optimise this call
             }
         }
         // Paper end - optimise this call
@@ -1413,10 +1413,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     }
 
     // Paper start
-    protected final io.papermc.paper.world.EntitySliceManager entitySliceManager;
+    //protected final io.papermc.paper.world.EntitySliceManager entitySliceManager; // Paper - rewrite chunk system
 
     public org.bukkit.entity.Entity[] getChunkEntities(int chunkX, int chunkZ) {
-        io.papermc.paper.world.ChunkEntitySlices slices = this.entitySliceManager.getChunk(chunkX, chunkZ);
+        io.papermc.paper.world.ChunkEntitySlices slices = ((ServerLevel)this).getEntityLookup().getChunk(chunkX, chunkZ);
         if (slices == null) {
             return new org.bukkit.entity.Entity[0];
         }
@@ -1426,30 +1426,30 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     @Override
     public List<Entity> getHardCollidingEntities(Entity except, AABB box, Predicate<? super Entity> predicate) {
         List<Entity> ret = new java.util.ArrayList<>();
-        this.entitySliceManager.getEntities(except, box, ret, predicate);
+        ((ServerLevel)this).getEntityLookup().getEntities(except, box, ret, predicate);
         return ret;
     }
 
     @Override
     public void getEntities(Entity except, AABB box, Predicate<? super Entity> predicate, List<Entity> into) {
-        this.entitySliceManager.getEntities(except, box, into, predicate);
+        ((ServerLevel)this).getEntityLookup().getEntities(except, box, into, predicate);
     }
 
     @Override
     public void getHardCollidingEntities(Entity except, AABB box, Predicate<? super Entity> predicate, List<Entity> into) {
-        this.entitySliceManager.getHardCollidingEntities(except, box, into, predicate);
+        ((ServerLevel)this).getEntityLookup().getHardCollidingEntities(except, box, into, predicate);
     }
 
     @Override
     public <T> void getEntitiesByClass(Class<? extends T> clazz, Entity except, final AABB box, List<? super T> into,
                                        Predicate<? super T> predicate) {
-        this.entitySliceManager.getEntities((Class)clazz, except, box, (List)into, (Predicate)predicate);
+        ((ServerLevel)this).getEntityLookup().getEntities((Class)clazz, except, box, (List)into, (Predicate)predicate);
     }
 
     @Override
     public <T extends Entity> List<T> getEntitiesOfClass(Class<T> entityClass, AABB box, Predicate<? super T> predicate) {
         List<T> ret = new java.util.ArrayList<>();
-        this.entitySliceManager.getEntities(entityClass, null, box, ret, predicate);
+        ((ServerLevel)this).getEntityLookup().getEntities(entityClass, null, box, ret, predicate);
         return ret;
     }
     // Paper end
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
index 19ffd93b7bc745d9a6822f1e5642d2f640f61df7..cb64b46eb874bb7ce22cdbf9e9629c929a05fb61 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -294,7 +294,7 @@ public abstract class ChunkGenerator {
         return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("init_biomes", () -> {
             chunk.fillBiomesFromNoise(this.biomeSource, noiseConfig.sampler());
             return chunk;
-        }), Util.backgroundExecutor());
+        }), executor); // Paper - run with supplied executor
     }
 
     public abstract void applyCarvers(WorldGenRegion chunkRegion, long seed, RandomState noiseConfig, BiomeManager biomeAccess, StructureManager structureAccessor, ChunkAccess chunk, GenerationStep.Carving carverStep);
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
index e6240f891e396d91e31b02fdf3084be77e9d6697..00cb9dafc711607f28529ea9afbcdb492b1b2595 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -29,6 +29,30 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemp
 
 public class ChunkStatus {
 
+    // Paper start - rewrite chunk system
+    public boolean isParallelCapable; // Paper
+    public int writeRadius = -1;
+    public int loadRange = 0;
+
+    protected static final java.util.List<ChunkStatus> statuses = new java.util.ArrayList<>();
+
+    private ChunkStatus nextStatus;
+
+    public final ChunkStatus getNextStatus() {
+        return this.nextStatus;
+    }
+
+    public final boolean isEmptyLoadStatus() {
+        return this.loadingTask == PASSTHROUGH_LOAD_TASK;
+    }
+
+    public final boolean isEmptyGenStatus() {
+        return this == ChunkStatus.EMPTY || this == ChunkStatus.HEIGHTMAPS || this == ChunkStatus.LIQUID_CARVERS;
+    }
+
+    public final java.util.concurrent.atomic.AtomicBoolean warnedAboutNoImmediateComplete = new java.util.concurrent.atomic.AtomicBoolean();
+    // Paper end - rewrite chunk system
+
     public static final int MAX_STRUCTURE_DISTANCE = 8;
     private static final EnumSet<Heightmap.Types> PRE_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR_WG, Heightmap.Types.WORLD_SURFACE_WG);
     public static final EnumSet<Heightmap.Types> POST_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES);
@@ -150,10 +174,8 @@ public class ChunkStatus {
             protochunk.setStatus(chunkstatus);
         }
 
-        return lightenginethreaded.retainData(ichunkaccess).thenApply(Either::left);
-    }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
-        return lightenginethreaded.retainData(ichunkaccess).thenApply(Either::left);
-    });
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess)); // Paper - rewrite chunk system
+    }); // Paper - rewrite chunk system
     public static final ChunkStatus LIGHT = ChunkStatus.register("light", ChunkStatus.FEATURES, 1, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> {
         return ChunkStatus.lightChunk(chunkstatus, lightenginethreaded, ichunkaccess);
     }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
@@ -255,6 +277,13 @@ public class ChunkStatus {
         this.chunkType = chunkType;
         this.heightmapsAfter = heightMapTypes;
         this.index = previous == null ? 0 : previous.getIndex() + 1;
+        // Paper start
+        this.nextStatus = this;
+        if (statuses.size() > 0) {
+            statuses.get(statuses.size() - 1).nextStatus = this;
+        }
+        statuses.add(this);
+        // Paper end
     }
 
     public int getIndex() {
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 2292cb0e0c1a3e0ed34b941f028136bfb0bff13e..51bd7314743431600c7d5c5959eb18ed6edba661 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -25,6 +25,7 @@ import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkPacketData;
+import net.minecraft.server.ChunkSystem;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerChunkCache;
 import net.minecraft.server.level.ServerLevel;
@@ -830,6 +831,64 @@ public class LevelChunk extends ChunkAccess {
 
     }
 
+    // Paper start - new load callbacks
+    private io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder;
+    public io.papermc.paper.chunk.system.scheduling.NewChunkHolder getChunkHolder() {
+        return this.chunkHolder;
+    }
+
+    public void setChunkHolder(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        if (chunkHolder == null) {
+            throw new NullPointerException("Chunkholder cannot be null");
+        }
+        if (this.chunkHolder != null) {
+            throw new IllegalStateException("Already have chunkholder: " + this.chunkHolder + ", cannot replace with " + chunkHolder);
+        }
+        this.chunkHolder = chunkHolder;
+        this.playerChunk = chunkHolder.vanillaChunkHolder;
+    }
+
+    /* Note: We skip the light neighbour chunk loading done for the vanilla full chunk */
+    /* Starlight does not need these chunks for lighting purposes because of edge checks */
+
+    public void onChunkLoad(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        // figure out how this should interface with:
+        // the entity chunk load event // -> moved to the FULL status
+        // the chunk load event // -> stays here
+        // any entity add to world events // -> in FULL status
+        this.loadCallback();
+        ChunkSystem.onChunkBorder(this, chunkHolder.vanillaChunkHolder);
+    }
+
+    public void onChunkUnload(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        // figure out how this should interface with:
+        // the entity chunk load event // -> moved to chunk unload to disk (not written yet)
+        // the chunk load event // -> stays here
+        // any entity add to world events // -> goes into the unload logic, it will completely explode
+        // etc later
+        this.unloadCallback();
+        ChunkSystem.onChunkNotBorder(this, chunkHolder.vanillaChunkHolder);
+    }
+
+    public void onChunkTicking(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        this.postProcessGeneration();
+        this.level.startTickingChunk(this);
+        ChunkSystem.onChunkTicking(this, chunkHolder.vanillaChunkHolder);
+    }
+
+    public void onChunkNotTicking(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        ChunkSystem.onChunkNotTicking(this, chunkHolder.vanillaChunkHolder);
+    }
+
+    public void onChunkEntityTicking(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        ChunkSystem.onChunkEntityTicking(this, chunkHolder.vanillaChunkHolder);
+    }
+
+    public void onChunkNotEntityTicking(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        ChunkSystem.onChunkNotEntityTicking(this, chunkHolder.vanillaChunkHolder);
+    }
+    // Paper end - new load callbacks
+
     // CraftBukkit start
     public void loadCallback() {
         if (this.loadedTicketLevel) { LOGGER.error("Double calling chunk load!", new Throwable()); } // Paper
@@ -860,6 +919,7 @@ public class LevelChunk extends ChunkAccess {
              * no way of creating a CraftWorld/CraftServer at that point.
              */
             server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(this.bukkitChunk, this.needsDecoration));
+            this.chunkHolder.getEntityChunk().callEntitiesLoadEvent(); // Paper - rewrite chunk system
 
             if (this.needsDecoration) {
                 try (co.aikar.timings.Timing ignored = this.level.timings.chunkLoadPopulate.startTiming()) { // Paper
@@ -890,6 +950,7 @@ public class LevelChunk extends ChunkAccess {
     public void unloadCallback() {
         if (!this.loadedTicketLevel) { LOGGER.error("Double calling chunk unload!", new Throwable()); } // Paper
         org.bukkit.Server server = this.level.getCraftServer();
+        this.chunkHolder.getEntityChunk().callEntitiesUnloadEvent(); // Paper - rewrite chunk system
         org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(this.bukkitChunk, this.isUnsaved());
         server.getPluginManager().callEvent(unloadEvent);
         // note: saving can be prevented, but not forced if no saving is actually required
@@ -1072,7 +1133,7 @@ public class LevelChunk extends ChunkAccess {
     }
 
     public ChunkHolder.FullChunkStatus getFullStatus() {
-        return this.fullStatus == null ? ChunkHolder.FullChunkStatus.BORDER : (ChunkHolder.FullChunkStatus) this.fullStatus.get();
+        return this.chunkHolder == null ? ChunkHolder.FullChunkStatus.INACCESSIBLE : this.chunkHolder.getChunkStatus(); // Paper - rewrite chunk system
     }
 
     public void setFullStatus(Supplier<ChunkHolder.FullChunkStatus> levelTypeProvider) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
index b230a3d475357d2ffd340f9a89934ea7227e69d0..6e9af1401918995e3c268eea7d4a74af94707242 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
@@ -197,7 +197,7 @@ public class ChunkStorage implements AutoCloseable {
     }
 
     public void flushWorker() {
-        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.flush(); // Paper - nuke IO worker
+        io.papermc.paper.chunk.system.io.RegionFileIOThread.flush(); // Paper - rewrite chunk system
     }
 
     public void close() throws IOException {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
index 2bc0384728f89b7c64a8beec78a1b77dc063d37b..5bb0adfa7175ecce67a67d3835df468db7d95902 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -61,13 +61,21 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
 
                 CompoundTag compoundTag = this.upgradeChunkTag(nbt.get());
                 ListTag listTag = compoundTag.getList("Entities", 10);
-                List<Entity> list = EntityType.loadEntitiesRecursive(listTag, this.level).collect(ImmutableList.toImmutableList());
+                List<Entity> list = readEntities(this.level, compoundTag); // Paper - rewrite chunk system, move to method
                 return new ChunkEntities<>(pos, list);
             }
         }, this.entityDeserializerQueue::tell);
     }
 
-    private static ChunkPos readChunkPos(CompoundTag chunkNbt) {
+    // Paper start - rewrite chunk system
+    public static List<Entity> readEntities(ServerLevel level, CompoundTag compoundTag) {
+        ListTag listTag = compoundTag.getList("Entities", 10);
+        List<Entity> list = EntityType.loadEntitiesRecursive(listTag, level).collect(ImmutableList.toImmutableList());
+        return list;
+    }
+    // Paper end - rewrite chunk system
+
+    public static ChunkPos readChunkPos(CompoundTag chunkNbt) { // Paper - public
         int[] is = chunkNbt.getIntArray("Position");
         return new ChunkPos(is[0], is[1]);
     }
@@ -89,29 +97,10 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
             }
 
         } else {
-            ListTag listTag = new ListTag();
-            final java.util.Map<net.minecraft.world.entity.EntityType<?>, Integer> savedEntityCounts = new java.util.HashMap<>(); // Paper
-            dataList.getEntities().forEach((entity) -> {
-                // Paper start
-                final EntityType<?> entityType = entity.getType();
-                final int saveLimit = this.level.paperConfig().chunks.entityPerChunkSaveLimit.getOrDefault(entityType, -1);
-                if (saveLimit > -1) {
-                    if (savedEntityCounts.getOrDefault(entityType, 0) >= saveLimit) {
-                        return;
-                    }
-                    savedEntityCounts.merge(entityType, 1, Integer::sum);
-                }
-                // Paper end
-                CompoundTag compoundTag = new CompoundTag();
-                if (entity.save(compoundTag)) {
-                    listTag.add(compoundTag);
-                }
-
-            });
-            CompoundTag compoundTag = new CompoundTag();
-            compoundTag.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
-            compoundTag.put("Entities", listTag);
-            writeChunkPos(compoundTag, chunkPos);
+            // Paper start - rewrite chunk system
+            // set force = true, we expect non-null compound here
+            CompoundTag compoundTag = saveEntityChunk0(dataList.getEntities().toList(), chunkPos, this.level, true);
+            // Paper end - rewrite chunk system
             this.worker.store(chunkPos, compoundTag).exceptionally((ex) -> {
                 LOGGER.error("Failed to store chunk {}", chunkPos, ex);
                 return null;
@@ -120,13 +109,63 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
         }
     }
 
+    // Paper start - rewrite chunk system
+    public static void copyEntities(final CompoundTag from, final CompoundTag into) {
+        if (from == null) {
+            return;
+        }
+        final ListTag entitiesFrom = from.getList("Entities", net.minecraft.nbt.Tag.TAG_COMPOUND);
+        if (entitiesFrom == null || entitiesFrom.isEmpty()) {
+            return;
+        }
+
+        final ListTag entitiesInto = into.getList("Entities", net.minecraft.nbt.Tag.TAG_COMPOUND);
+        into.put("Entities", entitiesInto); // this is in case into doesn't have any entities
+        entitiesInto.addAll(0, entitiesFrom.copy()); // need to copy, this is coming from the save thread
+    }
+
+    public static CompoundTag saveEntityChunk(List<Entity> entities, ChunkPos chunkPos, ServerLevel level) {
+        return saveEntityChunk0(entities, chunkPos, level, false);
+    }
+    private static CompoundTag saveEntityChunk0(List<Entity> entities, ChunkPos chunkPos, ServerLevel level, boolean force) {
+        if (!force && entities.isEmpty()) {
+            return null;
+        }
+        ListTag listTag = new ListTag();
+        final java.util.Map<net.minecraft.world.entity.EntityType<?>, Integer> savedEntityCounts = new java.util.HashMap<>(); // Paper
+        entities.forEach((entity) -> { // Diff here - use entities param
+            // Paper start
+            final EntityType<?> entityType = entity.getType();
+            final int saveLimit = level.paperConfig().chunks.entityPerChunkSaveLimit.getOrDefault(entityType, -1); // Diff here - use level
+            if (saveLimit > -1) {
+                if (savedEntityCounts.getOrDefault(entityType, 0) >= saveLimit) {
+                    return;
+                }
+                savedEntityCounts.merge(entityType, 1, Integer::sum);
+            }
+            // Paper end
+            CompoundTag compoundTag = new CompoundTag();
+            if (entity.save(compoundTag)) {
+                listTag.add(compoundTag);
+            }
+
+        });
+        CompoundTag compoundTag = new CompoundTag();
+        compoundTag.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
+        compoundTag.put("Entities", listTag);
+        writeChunkPos(compoundTag, chunkPos);
+
+        return !force && listTag.isEmpty() ? null : compoundTag;
+    }
+    // Paper end - rewrite chunk system
+
     @Override
     public void flush(boolean sync) {
         this.worker.synchronize(sync).join();
         this.entityDeserializerQueue.runAll();
     }
 
-    private CompoundTag upgradeChunkTag(CompoundTag chunkNbt) {
+    public static CompoundTag upgradeChunkTag(CompoundTag chunkNbt) { // Paper - public and static
         int i = getVersion(chunkNbt);
         return ca.spottedleaf.dataconverter.minecraft.MCDataConverter.convertTag(ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.ENTITY_CHUNK, chunkNbt, i, SharedConstants.getCurrentVersion().getWorldVersion()); // Paper - route to new converter system
     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index fc32a11e9c18f0a910ef519c817dd150b03c2102..022cb05743682b9f042643fbf1b320e81946e44c 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -28,7 +28,7 @@ public class RegionFileStorage implements AutoCloseable {
 
     private final boolean isChunkData; // Paper
 
-    RegionFileStorage(Path directory, boolean dsync) {
+    protected RegionFileStorage(Path directory, boolean dsync) { // Paper - protected constructor
         // Paper start - add isChunkData param
         this(directory, dsync, false);
     }
@@ -285,7 +285,11 @@ public class RegionFileStorage implements AutoCloseable {
     }
 
     protected void write(ChunkPos pos, @Nullable CompoundTag nbt) throws IOException {
-        RegionFile regionfile = this.getRegionFile(pos, false, true); // CraftBukkit // Paper
+        RegionFile regionfile = this.getRegionFile(pos, nbt == null, true); // CraftBukkit // Paper // Paper start - rewrite chunk system
+        if (nbt == null && regionfile == null) {
+            return;
+        }
+        // Paper end - rewrite chunk system
         try { // Paper
         int attempts = 0; Exception laste = null; while (attempts++ < 5) { try { // Paper
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
index 954819db8ada38ef2c832151be8a96492e76390a..707c54d19ae27046fce65df31173befe41b4b542 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
@@ -44,7 +44,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
     private final Function<Runnable, R> factory;
     private final DataFixer fixerUpper;
     private final DataFixTypes type;
-    private final RegistryAccess registryAccess;
+    public final RegistryAccess registryAccess; // Paper - rewrite chunk system
     protected final LevelHeightAccessor levelHeightAccessor;
 
     public SectionStorage(Path path, Function<Runnable, Codec<R>> codecFactory, Function<Runnable, R> factory, DataFixer dataFixer, DataFixTypes dataFixTypes, boolean dsync, RegistryAccess dynamicRegistryManager, LevelHeightAccessor world) {
@@ -151,9 +151,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
     }
 
     private void readColumn(ChunkPos pos) {
-        Optional<CompoundTag> optional = this.tryRead(pos).join();
-        RegistryOps<Tag> registryOps = RegistryOps.create(NbtOps.INSTANCE, this.registryAccess);
-        this.readColumn(pos, registryOps, optional.orElse((CompoundTag)null));
+        throw new IllegalStateException("Only chunk system can load in state, offending class:" + this.getClass().getName()); // Paper - rewrite chunk system
     }
 
     private CompletableFuture<Optional<CompoundTag>> tryRead(ChunkPos pos) {
@@ -173,6 +171,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
     // Paper end - aync chnnk i
 
     private <T> void readColumn(ChunkPos pos, DynamicOps<T> ops, @Nullable T data) {
+        if (true) throw new IllegalStateException("Only chunk system can load in state, offending class:" + this.getClass().getName());
         if (data == null) {
             for(int i = this.levelHeightAccessor.getMinSection(); i < this.levelHeightAccessor.getMaxSection(); ++i) {
                 this.storage.put(getKey(pos, i), Optional.empty());
@@ -209,7 +208,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
                 });
             }
         }
-        if (this instanceof net.minecraft.world.entity.ai.village.poi.PoiManager) { ((net.minecraft.world.entity.ai.village.poi.PoiManager)this).queueUnload(pos.longKey, net.minecraft.server.MinecraftServer.currentTickLong + 1); } // Paper - unload POI data
+        // Paper - rewrite chunk system
 
     }
 
@@ -278,7 +277,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
     }
 
     private static int getVersion(Dynamic<?> dynamic) {
-        return dynamic.get("DataVersion").asInt(1945);
+        return dynamic.get("DataVersion").asInt(1945); // Paper - diff on change, constant used in ChunkLoadTask
     }
 
     public void flush(ChunkPos pos) {
@@ -300,20 +299,5 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
         super.close(); // Paper - nuke I/O worker - call super.close method which is responsible for closing used files.
     }
 
-    // Paper start - get data function
-    public CompoundTag getData(ChunkPos chunkcoordintpair) {
-        // Note: Copied from above
-        // This is checking if the data needs to be written, then it builds it later in getDataInternal(ChunkCoordIntPair)
-        if (!this.dirty.isEmpty()) {
-            for (int i = this.levelHeightAccessor.getMinSection(); i < this.levelHeightAccessor.getMaxSection(); ++i) {
-                long j = SectionPos.of(chunkcoordintpair, i).asLong();
-
-                if (this.dirty.contains(j)) {
-                    return this.getDataInternal(chunkcoordintpair);
-                }
-            }
-        }
-        return null;
-    }
-    // Paper end
+    // Paper - rewrite chunk system
 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
index 575efe82a7219e256afd8362984eb26795445119..cf87490a446285132daaf9d90154ac6d477a62fe 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -90,7 +90,7 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
         return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("init_biomes", () -> {
             this.doCreateBiomes(blender, noiseConfig, structureAccessor, chunk);
             return chunk;
-        }), Util.backgroundExecutor());
+        }), executor); // Paper - run with supplied executor
     }
 
     private void doCreateBiomes(Blender blender, RandomState noiseConfig, StructureManager structureAccessor, ChunkAccess chunk) {
@@ -289,7 +289,7 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
 
             return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("wgen_fill_noise", () -> {
                 return this.doFill(blender, structureAccessor, noiseConfig, chunk, j, k);
-            }), Util.backgroundExecutor()).whenCompleteAsync((ichunkaccess1, throwable) -> {
+            }), executor).whenCompleteAsync((ichunkaccess1, throwable) -> { // Paper - run with supplied executor
                 Iterator iterator = set.iterator();
 
                 while (iterator.hasNext()) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 4c109bbc4694e9d3d8804cc64650f79abf315e3a..505e3fdb09b8553c3684be426f508b3cdfffcf50 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -121,7 +121,7 @@ public class CraftChunk implements Chunk {
 
     @Override
     public boolean isEntitiesLoaded() {
-        return this.getCraftWorld().getHandle().entityManager.areEntitiesLoaded(ChunkPos.asLong(x, z));
+        return this.getCraftWorld().getHandle().areEntitiesLoaded(io.papermc.paper.util.CoordinateUtils.getChunkKey(this.x, this.z)); // Paper - rewrite chunk system
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 33ff57359093335ff8d8ceb4ee3b107dfbc18c79..e6fda639b878effdba7e58431f71d14ff398bab8 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1256,7 +1256,7 @@ public final class CraftServer implements Server {
 
         internal.keepSpawnInMemory = creator.keepSpawnLoaded().toBooleanOrElse(internal.getWorld().getKeepSpawnInMemory()); // Paper
         this.getServer().prepareLevels(internal.getChunkSource().chunkMap.progressListener, internal);
-        internal.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API
+        //internal.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API // Paper - rewrite chunk system
 
         this.pluginManager.callEvent(new WorldLoadEvent(internal.getWorld()));
         return internal.getWorld();
@@ -1301,7 +1301,7 @@ public final class CraftServer implements Server {
             }
 
             handle.getChunkSource().close(save);
-            handle.entityManager.close(save); // SPIGOT-6722: close entityManager
+            // handle.entityManager.close(save); // SPIGOT-6722: close entityManager // Paper - rewrite chunk system
             handle.convertable.close();
         } catch (Exception ex) {
             this.getLogger().log(Level.SEVERE, null, ex);
@@ -2185,7 +2185,7 @@ public final class CraftServer implements Server {
 
     @Override
     public boolean isPrimaryThread() {
-        return Thread.currentThread().equals(console.serverThread) || Thread.currentThread().equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return io.papermc.paper.util.TickThread.isTickThread(); // Paper - rewrite chunk system
     }
 
     // Paper start
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 1b6ae90acffa06502902e11473b65c8431616b05..55bfb6e72f0083da0173f0980263124a8e82502a 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -630,20 +630,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public Collection<Plugin> getPluginChunkTickets(int x, int z) {
         DistanceManager chunkDistanceManager = this.world.getChunkSource().chunkMap.distanceManager;
-        SortedArraySet<Ticket<?>> tickets = chunkDistanceManager.tickets.get(ChunkPos.asLong(x, z));
-
-        if (tickets == null) {
-            return Collections.emptyList();
-        }
-
-        ImmutableList.Builder<Plugin> ret = ImmutableList.builder();
-        for (Ticket<?> ticket : tickets) {
-            if (ticket.getType() == TicketType.PLUGIN_TICKET) {
-                ret.add((Plugin) ticket.key);
-            }
-        }
-
-        return ret.build();
+        return chunkDistanceManager.getChunkHolderManager().getPluginChunkTickets(x, z); // Paper - rewrite chunk system
     }
 
     @Override
@@ -651,7 +638,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         Map<Plugin, ImmutableList.Builder<Chunk>> ret = new HashMap<>();
         DistanceManager chunkDistanceManager = this.world.getChunkSource().chunkMap.distanceManager;
 
-        for (Long2ObjectMap.Entry<SortedArraySet<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.long2ObjectEntrySet()) {
+        for (Long2ObjectMap.Entry<SortedArraySet<Ticket<?>>> chunkTickets : chunkDistanceManager.getChunkHolderManager().getTicketsCopy().long2ObjectEntrySet()) { // Paper - rewrite chunk system
             long chunkKey = chunkTickets.getLongKey();
             SortedArraySet<Ticket<?>> tickets = chunkTickets.getValue();
 
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
index 19b938f9b86552034c2a0e4af40e342a17f56504..382879562a808290cc4dd59dcd5022c6c22fb169 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
@@ -256,7 +256,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
             return ichunkaccess1;
         };
 
-        return future == null ? CompletableFuture.supplyAsync(() -> function.apply(chunk), net.minecraft.Util.backgroundExecutor()) : future.thenApply(function);
+        return future == null ? CompletableFuture.supplyAsync(() -> function.apply(chunk), executor) : future.thenApply(function); // Paper - run with supplied executor
     }
 
     @Override
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 0c41413ad32f8f6a094462fcd637dd3229abda45..c02a04d284734b5f545b64307ed4aea337c1465f 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -10,7 +10,7 @@ public class AsyncCatcher
 
     public static void catchOp(String reason)
     {
-        if ( (AsyncCatcher.enabled || io.papermc.paper.util.TickThread.STRICT_THREAD_CHECKS) && Thread.currentThread() != MinecraftServer.getServer().serverThread ) // Paper
+        if ( !io.papermc.paper.util.TickThread.isTickThread() ) // Paper // Paper - rewrite chunk system
         {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable()); // Paper
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index 03931dfd5b900fbbbd86c5cf3a4febffeb23cabc..ad67abc55292d32928c654290684125c4405f3f5 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -8,7 +8,7 @@ import java.util.logging.Logger;
 import net.minecraft.server.MinecraftServer;
 import org.bukkit.Bukkit;
 
-public class WatchdogThread extends Thread
+public final class WatchdogThread extends io.papermc.paper.util.TickThread // Paper - rewrite chunk system
 {
 
     public static final boolean DISABLE_WATCHDOG = Boolean.getBoolean("disable.watchdog"); // Paper
@@ -191,7 +191,7 @@ public class WatchdogThread extends Thread
                 // Paper end - Different message for short timeout
                 log.log( Level.SEVERE, "------------------------------" );
                 log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Rubia!):" ); // Paper // Rubia
-                com.destroystokyo.paper.io.chunk.ChunkTaskManager.dumpAllChunkLoadInfo(); // Paper
+                io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(isLongTimeout); // Paper // Paper - rewrite chunk system
                 this.dumpTickingInfo(); // Paper - log detailed tick information
                 WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( server.serverThread.getId(), Integer.MAX_VALUE ), log );
                 log.log( Level.SEVERE, "------------------------------" );
